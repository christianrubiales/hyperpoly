{
  "version-used": "<span style=\"color: gray\"><em>1.13</em></span>",
  "version": "$ rustc <span style=\"white-space: pre-wrap;\">--</span>version",
  "implicit-prologue": "<span style=\"color: gray\"><em>none</em></span>",

"grammar-invocation": {
  "interpreter": "<span style=\"color: gray\"><em>none</em></span>",
  "compiler": "$ cat hello.rs<br />fn main() {<br /><span style=\"white-space: pre-wrap;\">  </span>println!(\"Hello, world!\");<br />}<br /><br />$ rustc hello.rs<br /><br />$ ./hello<br />Hello, world!",
  "statement-terminator": ";<br /><br /><span style=\"color: gray\"><em>Newlines are not statement terminators; they are permitted wherever spaces or tabs are permitted to separate tokens.</em></span>",
  "blocks": "{ }",
  "end-of-line-comment": "<span style=\"white-space: pre-wrap;\">//</span> <span style=\"color: gray\"><em>comment</em></span>",
  "multiple-line-comment": "/* <span style=\"color: gray\"><em>comment line</em></span><br />/* <span style=\"color: gray\"><em>nested comment</em></span> */<br />*/"
},
"var-expr": {
  "value": "let pi: f64 = 3.14;",
  "variable": "let mut n: i32 = 3;<br />n += 1;",
  "assignment": "let mut i: i32 = 0;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> compiler warns if assignment value not used</span><br />i = 3;",
  "parallel-assignment": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> only in variable definition:</span><br />let (m, n) = (3, 7);",
  "swap": "let tmp;<br />tmp = x;<br />x = y;<br />y = tmp;",
  "compound-assignment": "<span style=\"color: gray\"><em>arithmetic:</em></span><br />+= -= *= /= %=<br /><br /><span style=\"color: gray\"><em>string</em>:</span><br />+=",
  "unit": "()<br />()",
  "conditional-expression": "if x &gt; 0 { x } else { -x }",
  "branch-type-mismatch": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> does not compile:</span><br />if true { \"hello\" } else { 3 }",
  "null": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Option types only:</span><br />None",
  "nullable-type": "let a: Vec&lt;Option&lt;i32<span style=\"white-space: pre-wrap;\">&gt;&gt;</span> =<br /><span style=\"white-space: pre-wrap;\">  </span>vec![Some(3_i32), None, Some(-4_i32)];",
  "null-test": "let a = vec![Some(1_i32), None];<br /><br />match a[0] {<br /><span style=\"white-space: pre-wrap;\">  </span>None =&gt; println!(\"a[0] is none\"),<br /><span style=\"white-space: pre-wrap;\">  </span>Some(i) =&gt; println!(\"a[0]: {}\", i),<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> simple comparison also works:</span><br />if a[1] == None {<br /><span style=\"white-space: pre-wrap;\">  </span>println!(\"a[1] is none\");<br />}",
  "coalesce": "let a = vec![Some(1_i32), None];<br />let i: i32 = a[1].unwrap_or(0_i32);",
  "nullif": "",
  "expr-type-declaration": ""
},
"arithmetic-logic": {
  "boolean-type": "bool",
  "true-false": "true false",
  "falsehoods": "false",
  "logical-op": "<span style=\"white-space: pre-wrap;\">&amp;&amp; || !</span><br /><br /><span style=\"color: gray\"><em><span style=\"white-space: pre-wrap;\">&amp;&amp; and ||</span> are short-circuit operators.</em></span>",
  "relational-op": "== != &lt; &gt; &lt;= &gt;=",
  "min-max": "",
  "int-type": "i8<br />i16<br />i32<br />i64",
  "unsigned-int-type": "u8<br />u16<br />u32<br />u64",
  "int-literal": "-4<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> specify size:</span><br />-4_i32",
  "float-type": "f32<br />f64",
  "arith-op": "+ - * / %",
  "add-int-float": "let n: i32 = 3;<br />let x = n as f64;<br />let y = x + 0.5;",
  "int-div": "7 / 3<br />7 % 3",
  "int-div-zero": "<span style=\"color: gray\"><em>runtime error</em></span>",
  "float-div": "7_f64 / 3_f64",
  "float-div-zero": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> these are float values but not literals:</span><br />inf, Nan, or -inf",
  "power": "let n = 2_i64.pow(32_u32);<br />let x1 = 3.14_f64.powi(32_i32);<br />let x2 = 3.14_f64.powf(3.5_f64);",
  "sqrt": "let x = 2_f64.sqrt();",
  "sqrt-negative-one": "let x = (-1_f64).sqrt();<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> No negative literals and unary negation has lower<br /><span style=\"white-space: pre-wrap;\">//</span> precedence that a method, so this is -1:</span><br />let y = -1_f64.sqrt();",
  "transcendental-func": "let x = 0.5_f64;<br /><br />x.exp() x.ln() x.log2() x.log10()<br />x.sin() x.cos() x.tan()<br />x.asin() x.acos() x.atan()<br />x.atan2(3.1_f64)",
  "transcendental-const": "std::f64::consts::PI<br />std::f64::consts::E",
  "float-truncation": "3.77_f64.trunc()<br />3.77_f64.round()<br />3.77_f64.floor()<br />3.77_f64.ceil()",
  "abs-val": "-7_i32.abs()<br />-7.1_f64.abs()<br />-7_i32.signum()<br />-7.1_f64.signum()",
  "int-overflow": "<span style=\"color: gray\"><em>panic</em></span>",
  "float-overflow": "<span style=\"color: gray\"><em>evaluates to</em> std::f32::INFINITY <em>or</em> std::f64::INFINITY</span>",
  "arbitrary-len-int": "",
  "arbitrary-len-int-op": "",
  "random-num": "use std::rand;<br /><br />let n = rand::random::&lt;uint&gt;() % 100u;<br />let x = rand::random::&lt;f64&gt;();<br /><span style=\"color: gray\"><em>??</em></span>",
  "random-seed": "",
  "bit-op": "<span style=\"white-space: pre-wrap;\">&lt;&lt; &gt;&gt; &amp; | ^ !</span>",
  "binary-octal-hex-literals": "0b101010<br />0o52<br />0x21",
  "radix": ""
},
"strings": {
  "str-type": "String<br /><br /><span style=\"color: gray\"><em>string reference:</em></span><br />&amp;str",
  "str-literal": "let s: &amp;str = \"don't say \\\"no\\\"\";<br />let s2: String = \"don't say \\\"no\\\"\".to_string();",
  "newline-in-str-literal": "let s: &amp;str = \"first line<br />second line\";<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> foobar:</span><br />let s2: &amp;str = \"foo\\<br /><span style=\"white-space: pre-wrap;\">  </span>bar\";",
  "str-esc": "\\0 \\\\ \\t \\n \\r \\\" \\\\<br />\\x<span style=\"color: gray\"><em>hh</em></span> \\u<span style=\"color: gray\"><em>hhhh</em></span> \\U<span style=\"color: gray\"><em>hhhhhhhh</em></span>",
  "format-str": "let s = format!(\"foo {} {} {}\", \"bar\", 7, 3.14_f32);",
  "str-concat": "let s1: String = \"hello\".to_string();<br />let s2: &amp;str = \" world\";<br />let s: String = s1 + s2;",
  "str-replicate": "",
  "translate-case": "s.to_uppercase()<br />s.to_lowercase()",
  "capitalize": "",
  "trim": "",
  "pad": "",
  "num-to-str": "",
  "str-to-num": "let n = \"12\".parse::&lt;i32&gt;().unwrap();<br />let x = \".037\".parse::&lt;f64&gt;().unwrap();<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> parse() returns an Option type.<br /><span style=\"white-space: pre-wrap;\">//</span> unrwap() panics if parse() returns None.</span>",
  "join": "",
  "split": "",
  "char-type": "",
  "char-literal": "",
  "str-len": "",
  "index-substr": "",
  "substr": "",
  "extract-char": "",
  "chr-ord": ""
},
"dates-time": {
  "dates-time-types": "extern crate chrono;<br /><br />chrono::DateTime",
  "current-date-time": "extern crate chrono;<br /><br />let dt = Local::now();<br />let dt_utc = UTC::now();",
  "current-unix-epoch": "extern crate chrono;<br /><br />let dt = UTC::now();<br />let t = dt.timestamp();",
  "to-unix-epoch,-from-unix-epoch": "extern crate chrono;<br /><br />let t = dt.timestamp();<br />let dt2 = chrono::NaiveDateTime::from_timestamp(t, 0);",
  "format-date": "dt.format(\"%Y-%m-%d %H:%M:%S\")",
  "parse-date": "",
  "date-subtraction": "",
  "add-duration": "",
  "date-parts": "",
  "time-parts": "",
  "build-broken-down-datetime": ""
},
"fixed-length-arrays": {
  "array-literal": "let nums = [1i32, 2i32, 3i32];",
  "array-size": "",
  "array-lookup": "nums[0]",
  "array-update": "let mut nums = [1i32, 2i32, 3i32];<br /><br />a[2] = 4;",
  "array-out-of-bounds": "<span style=\"color: gray\"><em>compilation error</em></span>"
},
"resizable-arrays": {
  "declare-array": "let mut a = Vec::new();<br />let mut a2: Vec&lt;i32&gt; = Vec::new();",
  "array-literal": "let mut a = vec![1, 2, 3];",
  "array-size": "a.len()",
  "array-lookup": "a[0]",
  "array-update": "a[0] = 4;",
  "array-out-of-bounds": "let mut a = vec![1, 2, 3];<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> thread panics:</span><br />let n = a[7];<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> returns None:</span><br />let n = a.get(7);",
  "array-element-index": "",
  "slice-array": "",
  "slice-array-to-end": "",
  "array-back": "let mut a: Vec&lt;i32&gt; = vec![1, 2, 3];<br />a.push(4);<br />let n = a.pop();",
  "array-front": "",
  "concatenate-array": "",
  "copy-array": "let a: Vec&lt;i32&gt; = vec![1, 2, 3];<br />let mut a2 = a.clone();<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> a[0] does not change:</span><br />a2[0] = 4;",
  "iterate-over-array": "let a: Vec&lt;i32&gt; = vec![1, 2, 3];<br />for i in a {<br /><span style=\"white-space: pre-wrap;\">  </span>println!(\"i: {}\", i);<br />}",
  "iterate-indices-elem": "",
  "reverse-array": "let mut a: Vec&lt;i32&gt; = vec![1, 2, 3];<br />a.reverse();",
  "sort-array": "let mut a: Vec&lt;i32&gt; = vec![3, 1, 4, 2];<br />a.sort();",
  "array-dedupe": "",
  "array-membership": "if a.contains(&amp;7) {<br /><span style=\"white-space: pre-wrap;\">  </span>println!(\"contains 7\");<br />}",
  "array-intersection": "",
  "array-union": "",
  "array-relative-complement": "",
  "map": "",
  "filter": "",
  "array-fold-left": "",
  "array-fold-right": "",
  "array-shuffle": "",
  "array-flatten": "",
  "array-zip": ""
},
"lists": {
  "list-literal": "",
  "empty-list": "",
  "empty-list-test": "",
  "cons": "",
  "head": "",
  "tail": "",
  "head-tail-empty-list": "",
  "list-length": "",
  "nth-elem-of-list": "",
  "list-elem-index": "",
  "update-list": "",
  "concat-list": "",
  "list-last": "",
  "list-take": "",
  "list-drop": "",
  "iterate-over-list": "",
  "reverse-list": "",
  "sort-list": "",
  "map-list": "",
  "filter-list": "",
  "fold-list-left": "",
  "fold-list-right": "",
  "list-member": "",
  "universal-test-list": "",
  "existential-test-list": "",
  "zip-list": ""
},
"tuples": {
  "tuple-literal": "(1, \"hello\", true)",
  "tuple-type": "let tup: (i32, &amp;str, bool) = (1, \"hello\", true);",
  "tuple-lookup": "let tup = (1, \"hello\", true);<br />let n: i32 = tup.0",
  "deconstruct-tuple": "let tup = (1, \"hello\", true);<br />let (n, s, b) = tup;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> use underscores for unneeded elements:</span><br />let (n, _, _) = tup;"
},
"dictionaries": {
  "declare-dict": "let mut dict = std::collections::HashMap::new();",
  "dict-literal": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> no dict literal</span><br />let mut dict = std::collections::HashMap::new();<br />dict.insert(\"t\", 1);<br />dict.insert(\"f\", 0);",
  "dict-size": "dict.len()",
  "dict-lookup": "",
  "dict-update": "",
  "dict-out-of-bounds": "",
  "dict-is-key-present": "",
  "dict-delete": "",
  "dict-iterate": "",
  "dict-key-val": ""
},
"functions": {
  "def-func": "fn add(x: f64, y: f64) -&gt; f64 {<br /><span style=\"white-space: pre-wrap;\">  </span>x + y<br />}",
  "invoke-func": "add(3.7, 2.8)",
  "define-function-with-block-body": "",
  "nest-func": "fn add_one(x: f64) -&gt; f64 {<br /><br /><span style=\"white-space: pre-wrap;\">  </span>fn add(x1: f64, y1: f64) -&gt; f64 {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>x1 + y1<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br /><span style=\"white-space: pre-wrap;\">  </span>add(x, 1.0)<br />}",
  "named-parameter": "",
  "named-parameter-default-value": "",
  "variable-num-arg": "",
  "overload-function": "",
  "retval": "<span style=\"color: gray\">return <em>arg; otherwise last expression evaluated and not followed by semicolon; otherwise unit ()</em></span>",
  "multiple-retval": "",
  "recursive-function": "",
  "anonymous-function": "",
  "invoke-anonymous-func": "",
  "func-as-val": "",
  "infix-operator-in-prefix-position": "",
  "function-in-infix-position": "",
  "currying": "",
  "lazy-evaluation": ""
},
"execution-control": {
  "if": "let signum: i32;<br /><br />if i &gt; 0 {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 1<br />} else if i == 0 {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 0<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = -1<br />}",
  "while": "let mut i: i32 = 0;<br /><br />while i &lt; 10 {<br /><span style=\"white-space: pre-wrap;\">  </span>i += 1<br />}",
  "for": "let mut n: i32 = 1;<br /><br />for i in range(1i, 11i) {<br /><span style=\"white-space: pre-wrap;\">  </span>n *= i;<br />}",
  "infinite-loop": "loop {<br /><br />}",
  "break-continue": "break continue"
},
"exceptions": {
  "raise-error": "panic!(\"bam!\");",
  "handle-error": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> does not catch all panics:</span><br />let result = std::panic::catch_unwind(<span style=\"white-space: pre-wrap;\">||</span> {<br /><span style=\"white-space: pre-wrap;\">  </span>panic!(\"bam!\");<br />});<br /><br />if result.is_ok() {<br /><span style=\"white-space: pre-wrap;\">  </span>println!(\"no panic\");<br />}",
  "standard-exceptions": "",
  "assert": "assert!(1 == 0);"
},
"concurrency": {
},
"file-handles": {
  "standard-file-handles": "use std::io;<br /><br />io::stdin<br />io::stdout<br />io::stderr",
  "read-line-from-stdin": "use std::io;<br /><br />let s = io::stdin().read_line().ok().expect(\"Failed to read line\");",
  "write-line-to-stdout": "println!(\"Hello, World!\");<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> argument of println! must be a literal.<br /><span style=\"white-space: pre-wrap;\">//</span> To print a variable:</span><br />let s = \"Hello, World!\";<br />println!(\"{}\", s);",
  "write-formatted-string-to-stdout": "",
  "open-file-for-reading": "",
  "open-file-for-writing": "",
  "open-file-for-appending": "",
  "close-file": "",
  "close-file-implicitly": "",
  "read-line": "",
  "iterate-over-file-by-line": "",
  "read-file-into-array-of-strings": "",
  "read-file-into-string": "",
  "write-string": "",
  "write-line": "",
  "flush-file-handle": "",
  "get-and-set-filehandle-position": ""
},
"files": {
  "file-test,-regular-file-test": "",
  "file-size": "",
  "is-file-readable,-writable,-executable": "",
  "set-file-permissions": "",
  "copy-file,-remove-file,-rename-file": "",
  "create-symlink,-symlink-test,-readlink": "",
  "generate-unused-file-name": ""
},
"directories": {
  "build-pathname": "",
  "dirname-and-basename": "",
  "iterate-over-directory-by-file": "",
  "make-directory": "",
  "remove-empty-directory": "",
  "remove-directory-and-contents": "",
  "directory-test": "",
  "temporary-directory": ""
},
"processes-environment": {
  "command-line-arguments": "",
  "program-name": "",
  "getopt": "",
  "env-var": "",
  "pid": "",
  "user-id-name": "",
  "exit": "",
  "signal-handler": "",
  "external-cmd": "",
  "escaped-external-cmd": "",
  "backticks": ""
},
"libraries-namespaces": {
  "define-namespace": "",
  "define-child-namespace": "",
  "reference-identifier-in-another-file": "",
  "import-definitions": "",
  "import-all-definitions-in-namespace": "",
  "import-namespace": "",
  "shadow-avoidance": "",
  "library-path-environment-variable": "",
  "create-package": "",
  "inspect-package": "",
  "install-package": "$ cat Cargo.toml<br />[package]<br />name = \"main\"<br />version = \"0.1.0\"<br />authors = [\"Bob <span style=\"white-space: pre-wrap;\">&lt;bob@foo.com&gt;</span>\"]<br />[dependencies]<br />chrono = \"0.2.25\"<br /><br />$ cat src/main.rs<br />extern crate chrono;<br />fn main() {<br /><span style=\"white-space: pre-wrap;\">  </span>let t = chrono::UTC::now();<br /><span style=\"white-space: pre-wrap;\">  </span>println!(\"t: {}\", t.format(\"%Y-%m-%d\"));<br />}<br /><br />$ cargo build",
  "list-installed-packages": ""
},
"user-defined-types": {
  "type-synonym": "",
  "sum-type": "enum DayOfWeek {<br /><span style=\"white-space: pre-wrap;\">  </span>Mon, Tue, Wed, Thu, Fri, Sat, Sun<br />}<br /><br />let dow: DayOfWeek = Mon;",
  "tuple-product-type-with-one-field": "",
  "tuple-product-type-with-two-fields": "",
  "record-product-type": "",
  "record-product-type-literal": "",
  "product-type-member-access": "",
  "product-type-member-assignment": "",
  "generic-type": "",
  "recursive-type": "",
  "pattern-match-sum-type": "let msg = match col {<br /><span style=\"white-space: pre-wrap;\">  </span>Red =&gt; \"red\",<br /><span style=\"white-space: pre-wrap;\">  </span>Blue =&gt; \"blue\",<br /><span style=\"white-space: pre-wrap;\">  </span>Green =&gt; \"green\",<br />};",
  "pattern-match-product-type": "",
  "pattern-match-guard": "",
  "pattern-match-catchall": "let msg = match col {<br /><span style=\"white-space: pre-wrap;\">  </span>Red =&gt; \"red\",<br /><span style=\"white-space: pre-wrap;\">  </span>_ =&gt; \"not red\",<br />};"
},
"objects": {
  "define-class": "",
  "create-object": "",
  "invoke-method": "",
  "define-class-variable-and-method": "",
  "invoke-class-method": ""
},
"inheritance-polymorphism": {
  "subclass": "",
  "abstract-base-class": "",
  "mixin": ""
},
"unit-tests": {
  "test-class": "",
  "run-all-tests,-run-test-suite": "",
  "exception-assertion": "",
  "setup": "",
  "teardown": ""
},
"debugging-profiling": {
  "lint": "",
  "run-debugger": "",
  "profile-code": "",
  "memory-tool": ""
},
"repl": {
  "invoke-repl": "",
  "previous-values": "",
  "help": "",
  "quit": "",
  "inspect-type": ""
}
}
