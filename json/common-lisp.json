{
  "version-used": "<span style=\"color: gray\"><em>SBCL 1.2</em></span>",
  "show-version": "$ sbcl <span style=\"white-space: pre-wrap;\">--</span>version",

"grammar-execution": {
  "compiler": "",
  "standalone-executable": "(sb-ext:save-lisp-and-die<br /><span style=\"white-space: pre-wrap;\">  </span>\"<span style=\"color: gray\"><em>executable</em></span>\"<br /><span style=\"white-space: pre-wrap;\">  </span>:executable t<br /><span style=\"white-space: pre-wrap;\">  </span>:toplevel '<span style=\"color: gray\"><em>function</em></span>)",
  "interpreter": "$ sbcl <span style=\"white-space: pre-wrap;\">--</span>script foo.lisp",
  "shebang": "#!/usr/bin/env sbcl <span style=\"white-space: pre-wrap;\">--</span>script",
  "repl": "$ sbcl",
  "cmd-line-program": "",
  "word-separator": "<span style=\"color: gray\"><em>whitespace</em></span>",
  "eol-comment": "(+ 1 1) <span style=\"color: gray\">; adding</span>",
  "multiple-line-comment": "(+ 1 #| adding |# 1)"
},
"var-expr": {
  "id": "<span style=\"color: gray\"><em>case insensitive, cannot start with digit</em></span><br /><br /><span style=\"color: gray\"><em>excluded characters:</em></span><br />SP ( ) \" , ' <span style=\"white-space: pre-wrap;\">`</span> : ; # | \\<br /><br /><span style=\"color: gray\"><em>reserved for user macros:</em></span><br />? ! [ ] { }",
  "quoted-id": "(setq |white space symbol| 3)<br /><br />(setq white\\ space\\ symbol 3)",
  "local-var": "<span style=\"color: gray\">; parallel assignment:</span><br />(let ((x 3) (y 4))<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))<br /><br /><span style=\"color: gray\">; sequential assignment:</span><br />(let* ((x 3) (y (* x x)))<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))",
  "global-var": "(defparameter *x* 3)<br /><br /><span style=\"color: gray\">; doesn't change x if already set:</span><br />(defvar *x* 3)",
  "rm-var": "(makunbound 'x)",
  "null": "nil '()",
  "null-test": "(null x)",
  "id-as-val": "'x<br />(quote x)",
  "id-test": "(symbolp 'x)",
  "identifier-equality-test": "(eq 'x 'x)",
  "non-referential-id": ":foo",
  "id-attr": "(set 'x 13)<br /><br />(setf (get 'x :desc) \"unlucky\")<br />(get 'x :desc)<br />(remprop 'x :desc)"
},
"arithmetic-logic": {
  "true-false": "t nil",
  "falsehoods": "nil ()",
  "logical-op": "(or (not t) (and t nil))",
  "relational-op": "<span style=\"white-space: pre-wrap;\">=</span> /= &lt; &gt; &lt;= &gt;=",
  "min-max": "(min 1 2 3)<br />(max 1 2 3)",
  "num-predicates": "numberp integerp<br />rationalp floatp<br />realp complexp",
  "arith-op": "+ - * / mod",
  "int-div": "(truncate 7 3)<br />(rem 7 3)",
  "int-div-zero": "<span style=\"color: gray\">division-by-zero <em>error</em></span>",
  "float-div": "<span style=\"color: gray\"><em>rational:</em></span><br />(/ 7 3)<br /><br /><span style=\"color: gray\"><em>float:</em></span><br />(/ 7 (* 3 1.0))",
  "float-div-zero": "<span style=\"color: gray\">division-by-zero <em>error</em></span>",
  "power": "(expt 2 32)",
  "sqrt": "(sqrt 2)",
  "sqrt-negative-one": "#c(0.0 1.0)",
  "transcendental-func": "exp log sin cos tan asin acos atan atan",
  "float-truncation": "<span style=\"color: gray\"><em>return two values, first is integer:</em></span><br />truncate round ceiling floor",
  "abs-val": "abs signum",
  "int-overflow": "<span style=\"color: gray\"><em>none; arbitrary-precision integers</em></span>",
  "float-overflow": "<span style=\"color: gray\">floating-point-overflow <em>error</em></span>",
  "rational-construction": "(/ 3 7)<br /><br /><span style=\"color: gray\">; literal:</span><br />3/7",
  "rational-decomposition": "(numerator 3/7)<br />(denominator 3/7)",
  "complex-construction": "#c(1 2)",
  "complex-decomposition": "(realpart #c(1 2))<br />(imagpart #c(1 2))<br />(phase #c(1 2))<br />(abs #c(1 2))<br />(conjugate #c(1 2))",
  "random-num": "(random 100)<br />(random 1.0)<br /><span style=\"color: gray\"><em>none</em></span>",
  "random-seed": "(setq *random-state*<br /><span style=\"white-space: pre-wrap;\">  </span>(sb-ext:seed-random-state 17))",
  "bit-op": "ash <span style=\"color: gray\"><em>left shift when 2nd argument positive</em></span> logand logior logxor lognot",
  "binary-octal-hex-literals": "#b101010<br />#o52<br />#x2a",
  "radix": "(format nil \"~7r\" 42)"
},
"strings": {
  "str-test": "(stringp \"foo\")",
  "str-literal": "\"foo bar\"",
  "newline-in-str-literal": "<span style=\"color: gray\"><em>yes</em></span>",
  "str-literal-esc": "\\\" \\\\",
  "str-ctor": "",
  "fmt-str": "(format nil \"~a: ~a ~,2f\" \"Foo\" 7 13.457)",
  "fmt-specifiers": "<span style=\"color: gray\">~a<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>any type, human readable<br />~s<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>any time, read parseable<br />~%<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>newline<br />~~<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>tilde<br />~c<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>character<br />~,5f<span style=\"white-space: pre-wrap;\">  </span>5 digits right of decimal mark<br />~d<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>decimal<br />~x<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>hex<br />~o<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>octal<br />~b<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>binary</span>",
  "compare-str": "(string= \"foo\" \"bar\")<br />(string&lt; \"foo\" \"bar\")",
  "str-concat": "(concatenate 'string \"foo \" \"bar \" \"bar\")",
  "str-replicate": "make-string 3 :initial-element #\\f)",
  "translate-case": "(string-downcase \"FOO\")<br />(string-upcase \"foo\")",
  "capitalize": "<span style=\"color: gray\">; \"Foo Bar\":</span><br />(string-capitalize \"foo bar\")",
  "trim": "(string-trim<br /><span style=\"white-space: pre-wrap;\">  </span>'(#\\space #\\tab #\\newline)<br /><span style=\"white-space: pre-wrap;\">  </span>\" foo \")",
  "pad": "(format nil \"~10a\" \"foo\")<br />(format nil \"~10@a\" \"foo\")",
  "num-to-str": "(concatenate 'string<br /><span style=\"white-space: pre-wrap;\">  </span>\"value: \"<br /><span style=\"white-space: pre-wrap;\">  </span>(princ-to-string 8))",
  "str-to-num": "(+ 7 (parse-integer \"12\"))<br /><span style=\"white-space: pre-wrap;\"> </span><br />(+ 73.9 (read-from-string \".037\"))",
  "split": "(cl-ppcre:split<br /><span style=\"white-space: pre-wrap;\">  </span>\"[ \\t\\n]+\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"foo bar baz\")",
  "str-join": "(reduce<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (m o)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(concatenate 'string m \" \" o))<br /><span style=\"white-space: pre-wrap;\">  </span>'(\"foo\" \"bar\" \"baz\"))",
  "str-len": "(length \"foo\")",
  "index-substr": "(search \"bar\" \"foo bar\")",
  "extract-substr": "(subseq \"foo bar\" 4 7)",
  "char-literal": "#\\a #\\space #\\newline #\\backspace #\\tab #\\linefeed #\\page #\\return #\\rubout",
  "char-test": "(characterp #\\x)<br />(alpha-char-p #\\x)<br />(alphanumericp #\\x)<br />(digit-char-p #\\7)<br />(lower-case-p #\\x)<br />(upper-case-p #\\X)",
  "chr-ord": "(code-char 97)<br />(char-code #\\a)",
  "str-to-char-array": "",
  "lookup-char": "(char \"foo\" 0)"
},
"regexes": {
  "regex-literal": "<span style=\"color: gray\"><em>use a string:</em></span><br />\"\\\\b\\\\d{5}\\\\b\"",
  "char-class-abbrev": ". \\d \\D \\s \\S \\w \\W",
  "regex-anchors": "^ $ \\b \\B",
  "regex-test": "(ql:quickload \"cl-ppcre\")<br /><br />(if (cl-ppcre:all-matches \"1999\" s)<br /><span style=\"white-space: pre-wrap;\">  </span>(format t \"party!\"))",
  "case-insensitive-regex": "",
  "subst": "(cl-ppcre:regex-replace \"[^l]l\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"hello\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"EL\")<br /><span style=\"white-space: pre-wrap;\"> </span><br />(cl-ppcre:regex-replace-all \"[^l]l\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"hello hello\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"EL\")",
  "group-capture": "",
  "scan": "",
  "backreference": ""
},
"dates-time": {
  "broken-down-datetime-type": "<span style=\"color: gray\"><em>No dedicated type; a list of 9 values is used:</em><br /><br /><span style=\"white-space: pre-wrap;\">  </span>second: 0-59<br /><span style=\"white-space: pre-wrap;\">  </span>minute: 0-59<br /><span style=\"white-space: pre-wrap;\">  </span>hour: 0-23<br /><span style=\"white-space: pre-wrap;\">  </span>day of month: 1-31<br /><span style=\"white-space: pre-wrap;\">  </span>month: 1-12<br /><span style=\"white-space: pre-wrap;\">  </span>year: 4 digits<br /><span style=\"white-space: pre-wrap;\">  </span>day of week: 0-6 for Mon-Sun<br /><span style=\"white-space: pre-wrap;\">  </span>is daylight savings time: t or nil<br /><span style=\"white-space: pre-wrap;\">  </span>timezone: negated UTC offset in hours</span>",
  "current-datetime": "(get-decoded-time)",
  "current-unix-epoch": "gray|; seconds since Jan 1, 1900:##<br />(get-universal-time)",
  "unix-epoch-to-broken-down-datetime": "(decode-universal-time<br /><span style=\"white-space: pre-wrap;\">  </span>(get-unversal-time))",
  "broken-down-datetime-to-unix-epoch": "(encode-universal-time 0 22 10 31 5 2015)",
  "fmt-datetime": "",
  "parse-datetime": "",
  "datet-parts": "(multiple-value-bind<br /><span style=\"white-space: pre-wrap;\">  </span>(ss mi hr dy mo yr)<br /><span style=\"white-space: pre-wrap;\">  </span>(get-decoded-time)<br /><span style=\"white-space: pre-wrap;\">  </span>(list ss mi hr) <span style=\"color: gray\">; quiesce warning</span><br /><span style=\"white-space: pre-wrap;\">  </span>(list dy mo yr))",
  "time-parts": "(multiple-value-bind<br /><span style=\"white-space: pre-wrap;\">  </span>(ss mi hr)<br /><span style=\"white-space: pre-wrap;\">  </span>(get-decoded-time)<br /><span style=\"white-space: pre-wrap;\">  </span>(list ss mi hr))",
  "build-datetime": "(encode-universal-time 0 22 10 31 5 2015)"
},
"lists": {
  "literal<br-/>": "'(1 2 3)<br />(quote (1 2 3))",
  "constructor<br-/>": "(list 1 2 3)",
  "predicate<br-/>": "(listp '(1 2 3))",
  "empty-test": "<span style=\"color: gray\">nil <em>and</em> '() <em>are synonyms and evaluate as false in a boolean context. All other values are true.</em></span>",
  "evaluating-the-empty-list": "nil",
  "cons<br-/>": "(cons 1 '(2 3))",
  "head<br-/>": "(car '(1 2 3))<br />(first '(1 2 3))",
  "tail<br-/>": "(cdr '(1 2 3))<br />(rest '(1 2 3))",
  "head-and-tail-of-empty-list": "<span style=\"color: gray\"><em>both evaluate to</em> nil</span>",
  "length<br-/>": "(length '(1 2 3))",
  "equality-test<br-/>": "(equal '(1 2 3) '(1 2 3))",
  "nth-element": "<span style=\"color: gray\">; indexed from zero:</span><br />(nth 2 '(1 2 3 4))",
  "out-of-bounds-behavior": "nil",
  "element-index": "(position 7 '(5 6 7 8))",
  "concatenate<br-/>": "(append '(1 2 3) '(4 5 6))",
  "take<br-/>": "<span style=\"color: gray\"><em>none</em></span>",
  "drop<br-/>": "(nthcdr 2 '(1 2 3 4))",
  "last-element<br-/>": "(car (last '(1 2 3)))",
  "all-but-last-element": "(butlast '(1 2 3))",
  "reverse<br-/>": "(reverse '(1 2 3))",
  "sort<br-/>": "(sort '(3 2 4 1) '&lt;)",
  "dedupe<br-/>": "(remove-duplicates '(1 1 2 3))",
  "membership<br-/>": "(member 7 '(1 2 3))",
  "map": "(mapcar<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (x) (* x x))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3))",
  "filter": "(remove-if-not<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (x) (&gt; x 2))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3))<br /><br /><span style=\"color: gray\">; remove-if returns complement</span>",
  "reduce": "(reduce '-<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3 4)<br /><span style=\"white-space: pre-wrap;\">  </span>:initial-value 0)",
  "right-fold": "(reduce '-<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3 4)<br /><span style=\"white-space: pre-wrap;\">  </span>:initial-value 0<br /><span style=\"white-space: pre-wrap;\">  </span>:from-end t)",
  "iterate": "(dolist (x '(1 2 3))<br /><span style=\"white-space: pre-wrap;\">  </span>(print x)<br /><span style=\"white-space: pre-wrap;\">  </span>(print (- x)))",
  "universal-predicate": "(every<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (i) (= 0 (rem i 2)))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3 4))",
  "existential-predicate": "(some<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (i) (= 0 (rem i 2)))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3 4))",
  "list-comprehension": "",
  "shuffle<br-/>": "",
  "set-head": "(defparameter *a* '(1 2 3))<br />(setf (car *a*) 3)",
  "set-tail": "(defparameter *a* '(1 2 3))<br />(setf (cdr *a*) '(4 5 6))",
  "manipulate-back": "(defparameter *a* '(1 2 3))<br />(push 4 *a*)<br />(pop *a*)",
  "flatten": "",
  "associative-array-lookup<br-/>": "(assoc 3 '((1 2) (3 4)))",
  "flat-associative-array-lookup<br-/>": "(getf '(1 2 3 4) 3)",
  "pair-literal<br-/>": "'(1 . 2)",
  "cons-cell-test": "(cons '(1 . 2))<br />(not (atom '(1 . 2)))",
  "translate-elements-recursively": "(sublis '((1 . 2) (3 . 4))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 (3 3 (1))))"
},
"fixed-length-arrays": {
  "fixed-len-array-literal": "#(1 2 3)",
  "constructor<br-/>": "(vector 1 2 3)",
  "size<br-/>": "(length #(1 2 3))",
  "lookup": "(elt #(1 2 3) 0) <span style=\"color: gray\"><em>or</em></span><br />(aref #(1 2 3) 0)",
  "update": "(setq v [1 2 3])<br />(setf (aref v 2) 4)",
  "out-of-bounds-behavior": "<span style=\"color: gray\"><em>raises</em> sb-kernel:index-too-large-error</span>",
  "array-to-list<br-/>": "(coerce #(1 2 3) 'list)",
  "list-to-array<br-/>": "(coerce '(1 2 3) 'vector)",
  "reverse": "(reverse #(1 2 3))",
  "sort": "(sort #(2 4 1 3) #'&lt;)",
  "map": "(map 'vector (lambda (x) (* x x)) #(1 2 3))",
  "filter": "(remove-if-not (lambda (x) (&gt; x 2)) #(1 2 3))<br /><br /><span style=\"color: gray\">; also remove-if</span>",
  "reduce": ""
},
"dictionaries": {
  "dict-literal": "<span style=\"color: gray\"><em>none</em></span>",
  "dict-ctor": "(defparameter *h* (make-hash-table :test 'equal))<br /><br /><span style=\"color: gray\">; default equality test is 'eql</span>",
  "dict-pred": "(hash-table-p *h*)",
  "dict-size": "(hash-table-count *h*)",
  "dict-lookup": "(gethash \"t\" *h*)",
  "dict-update": "(setf (gethash \"t\" *h*) 1)",
  "dict-missing-key": "<span style=\"color: gray\"><em>returns</em> nil</span>",
  "dict-is-key-present": "(nth-value 1 (gethash \"t\" *h*))",
  "dict-dele": "(remhash \"t\" *h*)",
  "dict-merge": "",
  "dict-invert": "",
  "dict-iter": "(maphash<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (k v)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(print k)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(print v))<br /><span style=\"white-space: pre-wrap;\">  </span>*h*)",
  "dict-key-val-lists": "<span style=\"color: gray\"><em>none</em></span>"
},
"user-defined-types": {
  "defstruct": "(defstruct account id balance)",
  "struct": "(setq a<br /><span style=\"white-space: pre-wrap;\">  </span>(make-account<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>:id 3<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>:balance 17.12))",
  "struct-getter<br-/>": "(account-id a)",
  "struct-setter<br-/>": "(setf (account-balance a) 0)",
  "struct-predicate<br-/>": "(account-p a)"
},
"functions": {
  "define-function<br-/>": "(defun add (x y) (+ x y))",
  "can-function-and-variable-share-name": "<span style=\"color: gray\"><em>yes</em></span>",
  "optional-argument": "(defun add (a &amp;optional b)<br /><span style=\"white-space: pre-wrap;\">  </span>(if (null b) a (+ a b)))",
  "variable-number-of-arguments": "(defun add (a &amp;rest b)<br /><span style=\"white-space: pre-wrap;\">  </span>(if (null b)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(+ a (eval (cons '+ b)))))",
  "default-value": "(defun add (a &amp;optional (b 0))<br /><span style=\"white-space: pre-wrap;\">  </span>(+ a b))",
  "named-parameter": "(defun logarithm (&amp;key number base)<br /><span style=\"white-space: pre-wrap;\">  </span>(/ (log number) (log base)))<br /><span style=\"white-space: pre-wrap;\"> </span><br />(logarithm :base 2 :number 8)",
  "return-multiple-values": "(defun sqrts (x)<br /><span style=\"white-space: pre-wrap;\">  </span>(values (sqrt x) (- (sqrt x))))",
  "assign-multiple-values-to-local-variables": "(multiple-value-bind (r1 r2)<br /><span style=\"white-space: pre-wrap;\">  </span>(sqrts 3)<br /><span style=\"white-space: pre-wrap;\">  </span>r2)",
  "assign-multiple-values-to-global-variables": "(multiple-value-setq (r1 r2)<br /><span style=\"white-space: pre-wrap;\">  </span>(sqrts 3))",
  "convert-list-to-multiple-values": "(values-list '(1 2 3))",
  "assign-multiple-values-to-list": "(multiple-value-list (sqrts 3))",
  "tail-call-optimization": "<span style=\"color: gray\"><em>yes for sbcl</em></span>",
  "lambda": "(lambda (x) (* x x))",
  "apply": "((lambda (x) (* x x)) 2)<br /><span style=\"white-space: pre-wrap;\"> </span><br />(apply #'(lambda (x) (* x x)) '(2))"
},
"execution-control": {
  "progn<br-/>": "progn prog1 prog2",
  "loop": "(setq i 1)<br />(loop (print \"hello\")<br /><span style=\"white-space: pre-wrap;\">  </span>(if (&gt; i 10)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(return)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(setq i (+ i 1))))",
  "do": "(do ((i 1) (sum 0))<br /><span style=\"white-space: pre-wrap;\">  </span>((&gt; i 100) sum)<br /><span style=\"white-space: pre-wrap;\">  </span>(setq sum (+ sum i))<br /><span style=\"white-space: pre-wrap;\">  </span>(setq i (+ i 1)))<br /><span style=\"color: gray\">do* <em>initializes serially</em></span>",
  "dotimes": "(dotimes (i 10 nil)<br /><span style=\"white-space: pre-wrap;\">  </span>(format t \"hello~%\"))",
  "if<br-/>": "(if (&lt; x 0) (- x) x)",
  "when": "(when (&lt; x y)<br /><span style=\"white-space: pre-wrap;\">  </span>(print \"x is less \")<br /><span style=\"white-space: pre-wrap;\">  </span>(print \"than y\"))",
  "cond": "(cond ((&gt; x 0) 1)<br /><span style=\"white-space: pre-wrap;\">  </span>((= x 0) 0)<br /><span style=\"white-space: pre-wrap;\">  </span>(t -1))",
  "lazy-evaluation": "",
  "continuations": ""
},
"exceptions": {
  "error<br-/>": "(error \"failed\")",
  "handle-error": "(handler-case<br /><span style=\"white-space: pre-wrap;\">  </span>(error \"failed\")<br /><span style=\"white-space: pre-wrap;\">  </span>(simple-error (e)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(format t \"error: ~a\" e)))",
  "define-exception": "(define-condition odd-err (error)<br /><span style=\"white-space: pre-wrap;\">  </span>((num :accessor odd-err-num<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>:initarg :num))<br /><span style=\"white-space: pre-wrap;\">  </span>(:report<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(lambda (e s)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(format s \"odd number: ~a\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(odd-err-num e)))))",
  "throw-exception": "(error 'odd-err :num 7)",
  "catch-exception": "(handler-case (/ 1 0)<br /><span style=\"white-space: pre-wrap;\">  </span>(division-by-zero ()<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(progn<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(format t \"division by zero\")<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>nil)))",
  "restart-case": "(defun halve (l)<br /><span style=\"white-space: pre-wrap;\">  </span>(mapcar (lambda (x)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(restart-case<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(if (= (rem x 2) 0) (/ x 2)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(error 'odd-error :num x))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(round-down () (/ (- x 1) 2))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(round-up () (/ (+ x 1) 2)))) l))",
  "invoke-restart": "(handler-bind<br /><span style=\"white-space: pre-wrap;\">  </span>((odd-err<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(lambda (c)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(invoke-restart<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>'round-down))))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(halve '(1 2 4 9)))",
  "finally-clause": "(unwind-protect<br /><span style=\"white-space: pre-wrap;\">  </span>(error \"failure\")<br /><span style=\"white-space: pre-wrap;\">  </span>(print \"clean up\"))"
},
"streams": {
  "std-file-handles": "*standard-input*<br />*standard-output*<br />*error-output*",
  "eof": "<span style=\"color: gray\">read-line <em>returns two values, the 2nd set to</em> T <em>at end-of-file.</em><br /><br />EOF-OF-FILE <em>is signaled when reading past end of file.</em></span>",
  "read-stdin": "(setq line (read-line))",
  "chomp": "",
  "println": "(defun println (s)<br /><span style=\"white-space: pre-wrap;\">  </span>(format t \"~a~%\" s))<br /><span style=\"white-space: pre-wrap;\"> </span><br />(println \"hello\")",
  "format-stdout": "(format t \"~s ~d: ~2$~%\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"foo\"<br /><span style=\"white-space: pre-wrap;\">  </span>7<br /><span style=\"white-space: pre-wrap;\">  </span>13.7)",
  "open-file": "(setq in (open \"/etc/hosts\"))",
  "open-file-write": "(setq out (open \"/tmp/test\" :direction :output :if-exists :supersede))",
  "open-file-append": "(setq out (open \"/tmp/test\" :direction :output :if-exists :append))",
  "close-file": "(close in)",
  "close-file-implicitly": "(with-open-file (out #P\"/tmp/test\" :direction :output) (write-line \"lorem ipsum\" out))",
  "read-line": "(setq line (read-line f))",
  "iterate-file": "",
  "read-file-array": "",
  "read-file-str": "",
  "write-str": "",
  "write-line": "",
  "flush-file": "",
  "seek": "",
  "in-memory-stream": "(setq f (make-string-input-stream<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"lorem ipsum\"))<br />(read-line f)<br /><br />(setq f2 (make-string-output-stream)<br />(write-string \"lorem ipsum)<br />(get-output-stream-string out)"
},
"emacs-buffers": {
  "list-buffers": "",
  "current-buffer": "",
  "clear-buffer": "",
  "point": "",
  "search-and-set-point": "",
  "insert-at-string-point": "",
  "current-buffer-as-string": "",
  "insert-file-contents-at-point": "",
  "mark": ""
},
"files": {
  "file-test": "(osicat:file-exists-p \"/tmp/foo\")<br />(osicat:regular-file-exists-p \"/tmp/foo\")",
  "file-size": "",
  "file-readable-writable-executable": "",
  "chmod": "",
  "last-modification-time": "",
  "cp-rm-mv": "(cl-fad:copy-file #P\"/tmp/foo\"<br /><span style=\"white-space: pre-wrap;\">  </span>#P\"/tmp/bar\")<br /><br />(delete-file #P\"/tmp/foo\")<br /><br />(rename-file #P\"/tmp/bar\"<br /><span style=\"white-space: pre-wrap;\">  </span>#P\"/tmp/foo\")",
  "symlink": "(osicat:make-link \"/tmp/hosts\" :target \"/etc/hosts\")",
  "tmp-file": ""
},
"directories": {
  "build-pathname": "(make-pathname<br /><span style=\"white-space: pre-wrap;\">  </span>:directory '(:absolute \"etc\")<br /><span style=\"white-space: pre-wrap;\">  </span>:name \"hosts\")",
  "dirname-basename": "(pathname-directory #P\"/etc/hosts\")<br /><br />(pathname-name #P\"/etc/hosts\")",
  "abs-pathname": "",
  "iterate-dir": "(dolist (file (osicat:list-directory \"/tmp\")) (format t \"~a~%\" file))",
  "mkdir": "",
  "recursive-cp": "",
  "rmdir": "(delete-directory \"/tmp/foo.d\")",
  "rm-rf": "(osicat:delete-directory-and-files \"/tmp/foo.d\")",
  "dir-test": "(osicat:directory-exists-p #P\"/etc\")"
},
"processes-environment": {
  "cmd-line-arg": "*posix-argv*",
  "program-name": "",
  "env-var": "(posix-getenv \"HOME\")",
  "user-id-name": "",
  "exit": "",
  "external-cmd": "(run-program \"ls\" '( \"/etc\"))",
  "cmd-subst": ""
},
"libraries-namespaces": {
  "complete-example": "",
  "compile-library": "(compile-file \"a.lisp\")",
  "load-library<br-/>": "(load \"a.lisp\")",
  "load-library-in-subdirectory": "(load \"b/a.lisp\")",
  "hot-patch": "(load \"a.lisp\")",
  "load-error": "<span style=\"color: gray\"><em>raises</em> sb-int:simple-file-error</span>",
  "library-path": "<span style=\"color: gray\"><em>contains working directory at startup</em></span>",
  "library-path-environment-variable": "<span style=\"color: gray\"><em>none</em></span>",
  "library-path-command-line-option": "<span style=\"color: gray\"><em>none</em></span>",
  "namespace-declaration": "(defpackage :foo)",
  "subnamespace-declaration": "<span style=\"color: gray\"><em>none</em></span>",
  "namespace-separator": ":",
  "import-definitions": "<span style=\"color: gray\">; set current *package* to foo and import symbol twiddle from bar:</span><br />(defpackage :foo<br /><span style=\"white-space: pre-wrap;\">  </span>(:import-from :bar :twiddle))",
  "import-all-definitions-in-namespace": "<span style=\"color: gray\">; set current *package* to foo and import symbols from bar:</span><br />(defpackage :foo<br /><span style=\"white-space: pre-wrap;\">  </span>(:use :bar))",
  "namespace-shadow-avoidance": "",
  "identifier-shadow-avoidance": "",
  "package-manager-help": "",
  "list-installed-packages": "",
  "search-packages": "(ql:system-apropos \"time\")",
  "install-package": "<span style=\"color: gray\">; install quicklisp</span><br />(load \"~/quicklisp/setup.lisp\")<br />(ql:quickload \"osicat\")",
  "remove-package": ""
},
"objects": {
  "define-class": "(defclass rectangle ()<br /><span style=\"white-space: pre-wrap;\">  </span>(<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(height<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>:accessor rectangle-height<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>:initarg :height)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(width<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>:accessor rectangle-width<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>:initarg :width)))",
  "make-instance": "(make-instance 'rectangle<br /><span style=\"white-space: pre-wrap;\">  </span>:height 3<br /><span style=\"white-space: pre-wrap;\">  </span>:width 7)",
  "read-attribute<br-/>": "(rectangle-height rect)",
  "write-attribute<br-/>": "(setf (rectangle-height rect) 4)",
  "define-method": "(defmethod area ((figure rectangle))<br /><span style=\"white-space: pre-wrap;\">  </span>(* (rectangle-height figure)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(rectangle-width figure)))",
  "invoke-method<br-/>": "(area rect)",
  "universal-superclass": "standard-object t",
  "multiple-inheritance": "yes"
},
"lisp-macros": {
  "backquote-and-comma": "(setq op '+)<br />(eval <span style=\"white-space: pre-wrap;\">`</span>(,op 1 1))",
  "defmacro": "(defmacro rpn (arg1 arg2 op)<br /><span style=\"white-space: pre-wrap;\">  </span>(list op arg1 arg2))",
  "defmacro-w/-backquote": "(defmacro rpn (arg1 arg2 op)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">`</span>(,op ,arg1 ,arg2))",
  "macro-predicate": "(macro-function rpn)",
  "macroexpand": "(macroexpand ’(rpn 1 2 +))",
  "splice-quote": "(defmacro add ( &amp;rest args )<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">`</span>(+ ,@args))",
  "recursive-macro": "(defmacro add (a &amp;rest b)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">`</span>(if (null ',b)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(+ ,a)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(+ ,a (add ,@b))))",
  "hygienic<br-/>": "<span style=\"color: gray\"><em>no</em></span>",
  "local-values": "(defmacro square-sum (x y)<br /><span style=\"white-space: pre-wrap;\">  </span>(let ((sum (gensym)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">`</span>(let ((,sum (+ ,x ,y)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(* ,sum ,sum))))"
},
"reflection": {
  "inspect-type<br-/>": "(type-of '(1 2 3))<br />(typep '(1 2 3) 'list)<br />(listp '(1 2 3))",
  "instance-of": "",
  "basic-types": "<span style=\"color: gray\"><em>logical and numeric:</em></span><br />bignum bit complex double-float fixnum float integer long-float nil null number ratio rational real short-float signed-btye single-float t unsigned-byte<br /><br /><span style=\"color: gray\"><em>symbols and strings:</em></span><br />base-character character extended-character keyword simple-string standard-char string symbol<br /><br /><span style=\"color: gray\"><em>data structures:</em></span><br />array atom bit-vector cons hash-table list sequence simple-array simple-bit-vector simple-vector vector<br /><br /><span style=\"color: gray\"><em>other:</em></span><br />compiled-function function package pathname random-state stream",
  "sequence-data-types": "list vector",
  "docstring": "(describe #'mapcar)",
  "define-docstring": "(defun add (x y)<br /><span style=\"white-space: pre-wrap;\">  </span>\"add x and y\"<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))",
  "search-doc": "<span style=\"color: gray\"><em>none</em></span>"
},
"java-interop": {
  "new": "",
  "method": "",
  "class-method<br-/>": "",
  "chain<br-/>": "",
  "import": "",
  "to-java-array": ""
}
}
