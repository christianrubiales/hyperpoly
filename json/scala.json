{
  "version-used": "<span style=\"color: gray\"><em>2.11</em></span>",
  "version": "$ scala -version",
  "implicit-prologue": "<span style=\"color: gray\"><em>none; but these libraries always available:</em><br /><br /><span style=\"white-space: pre-wrap;\">  </span>java.lang<br /><span style=\"white-space: pre-wrap;\">  </span>scala<br /><br /><em>as are methods in</em> Predef</span>",

"grammar-invocation": {
  "interpreter": "$ echo 'println(\"hello\")' &gt; Hello.scala<br /><br />$ scala hello.scala",
  "compiler": "$ cat hello.scala<br />object Hello {<br /><span style=\"white-space: pre-wrap;\">  </span>def main(args: Array[String]) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>println(\"Hello, World!\")<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br /><br />$ scalac Hello.scala<br />$ scala Hello",
  "statement-terminator": "; <span style=\"color: gray\"><em>or sometimes newline</em></span><br /><br /><span style=\"color: gray\"><em>A newline does not terminate a statement:<br /><span style=\"white-space: pre-wrap;\">  </span>(1) inside ( ) or [ ],<br /><span style=\"white-space: pre-wrap;\">  </span>(2) if the preceding line is not a complete statement,<br /><span style=\"white-space: pre-wrap;\">  </span>(3) if following token not legal at start of a statement.</em></span>",
  "blocks": "{ }",
  "end-of-line-comment": "<span style=\"white-space: pre-wrap;\">//</span> <span style=\"color: gray\"><em>comment</em></span>",
  "multiple-line-comment": "/* <span style=\"color: gray\"><em>comment line</em></span><br />/* <span style=\"color: gray\"><em>nested comment</em></span> */<br />*/"
},
"var-expr": {
  "value": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> evaluates 1 + p immediately:</span><br />val n = 1 + p<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> evaluated first time n is accessed:</span><br />lazy val n = 1 + p",
  "variable": "var n = 3<br />n += 1<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> evaluates 1 + 2 each time n is used:</span><br />def n = 1 + 2",
  "assignment": "",
  "parallel-assignment": "val (m, n) = (3, 7)",
  "swap": "",
  "compound-assignment": "<span style=\"color: gray\"><em>arithmetic:</em></span><br />+= -= *= /= %=<br /><br /><span style=\"color: gray\"><em>string:</em></span><br /><span style=\"color: gray\"><em>none</em></span><br /><br /><span style=\"color: gray\"><em>bit:</em></span><br /><span style=\"white-space: pre-wrap;\">&lt;&lt;= &gt;&gt;= &amp;= |= ^=</span>",
  "unit": "Unit<br />()",
  "conditional-expression": "val n = -3<br />if (n &lt; 0) -n else n",
  "branch-type-mismatch": "<span style=\"color: gray\">// expression has type Any:</span><br />if (true) { \"hello\" } else { 3 }",
  "null": "null",
  "nullable-type": "val a = List(Some(3), null, Some(-4))",
  "null-test": "",
  "coalesce": "",
  "nullif": "",
  "expr-type-declaration": "1: Double"
},
"arithmetic-logic": {
  "boolean-type": "Boolean",
  "true-false": "true false",
  "falsehoods": "false",
  "logical-op": "&amp;&amp; <span style=\"white-space: pre-wrap;\">||</span> !",
  "relational-op": "== != &lt; &gt; &lt;= &gt;=",
  "min-max": "math.min 1 2<br />math.max 1 2",
  "int-type": "<span style=\"color: gray\"><em>type of integer literals:</em></span><br />Int<br /><span style=\"color: gray\"><em>other modular types:</em></span><br />Byte Short Long<br /><span style=\"color: gray\"><em>arbitrary precision type:</em></span><br />BigInt",
  "unsigned-int-type": "",
  "int-literal": "-4",
  "float-type": "<span style=\"color: gray\"><em>type of float literals:</em></span><br />Double<br /><span style=\"color: gray\"><em>other types:</em></span><br />Float",
  "arith-op": "+ - * / %",
  "add-int-float": "3 + 7.0",
  "int-div": "7 / 3<br />7 % 3",
  "int-div-zero": "java.lang.ArithmeticException",
  "float-div": "(7: Double) / 3",
  "float-div-zero": "<span style=\"color: gray\"><em>evaluates to</em> Infinity, NaN, <em>or</em> -Infinity, <em>values which do not have literals</em></span>",
  "power": "math.pow(2, 32)",
  "sqrt": "math.sqrt(2)",
  "sqrt-negative-one": "<span style=\"color: gray\">math.sqrt(-1) <em>evaluates to</em> NaN, <em>a value which has no literal</em></span>",
  "transcendental-func": "math.exp math.log<br />math.sin math.cos math.tan<br />math.asin math.acos math.atan math.atan2",
  "transcendental-const": "math.Pi<br />math.E",
  "float-truncation": "<span style=\"color: gray\"><em>??</em></span><br />3.14.round<br />3.14.floor <span style=\"color: gray\"><em>returns Double</em></span><br />3.14.ceil <span style=\"color: gray\"><em>returns Double</em></span>",
  "abs-val": "math.abs(-7)<br />math.signum(-7)",
  "int-overflow": "<span style=\"color: gray\"><em>modular arithmetic for all types except</em></span> BigInt",
  "float-overflow": "<span style=\"color: gray\"><em>evaluates to</em> Infinity, <em>a value which has no literal</em></span>",
  "arbitrary-len-int": "val n = BigInt(7)<br />val m = BigInt(12)",
  "arbitrary-len-int-op": "n + m<br />n - m<br />n * m<br />n / m<br />n % m<br /><br />n == m<br />n &lt; m<br />n &lt; m<br />n &lt;= m<br />n &gt;= m",
  "random-num": "import scala.util.Random<br /><br />val rnd = Random<br /><br />rnd.nextInt(100)<br />rnd.nextDouble<br />rnd.nextGaussian",
  "random-seed": "import scala.util.Random<br /><br />val rnd = Random<br /><br />rnd.setSeed(17)<br /><span style=\"color: gray\"><em>none</em></span><br /><span style=\"color: gray\"><em>none</em></span>",
  "bit-op": "1<span style=\"white-space: pre-wrap;\"> &lt;&lt; </span> 4<br />1 <span style=\"white-space: pre-wrap;\"> &gt;&gt; </span> 4<br />1 &amp; 3<br />1 | 3<br />1 ^ 3<br />~ 1",
  "binary-octal-hex-literals": "<span style=\"color: gray\"><em>none</em></span><br />052<br />0x2a",
  "radix": "Integer.toString(42, 7)<br />Integer.parseInt(\"60\", 7)"
},
"strings": {
  "str-type": "java.lang.String",
  "str-literal": "\"Hello, World!\"<br /><br />\"\"\"Hello, World!\"\"\"",
  "newline-in-str-literal": "<span style=\"color: gray\"><em>in triple quote literal only</em></span>",
  "str-esc": "\\b \\f \\n \\r \\t \\\" \\'<br />\\u<span style=\"color: gray\"><em>hhhh</em></span> \\<span style=\"color: gray\"><em>o</em></span> \\<span style=\"color: gray\"><em>oo</em></span> \\<span style=\"color: gray\"><em>ooo</em></span>",
  "format-str": "\"foo %s %d %.2f\".format(\"bar\", 7, 3.1415)<br /><br />val n = 3<br />val m = 5<br />val msg = s\"$n + $m is ${n + m}\"",
  "str-concat": "\"Hello\" + \", \" + \"World!\"",
  "str-replicate": "val hbar = \"-\" * 80",
  "translate-case": "\"hello\".toUpperCase<br />\"HELLO\".toLowerCase",
  "capitalize": "\"hello\".capitalize",
  "trim": "\" hello \".trim",
  "pad": "<span style=\"color: gray\"><em>??</em></span><br />\"hello\".padTo(10, \" \").mkString",
  "num-to-str": "\"two: \" + 2.toString<br />\"pi: \" + 3.14.toString",
  "str-to-num": "7 + \"12\".toInt<br />73.9 + \".037\".toFloat<br /><span style=\"color: gray\"><em>raises</em> NumberFormatException <em>if string doesn't completely parse</em></span>",
  "join": "List(\"do\", \"re\", \"mi\").mkString(\" \")",
  "split": "\"do re mi\".split(\" \")",
  "char-type": "Char",
  "char-literal": "'h'",
  "str-len": "\"hello\".length",
  "index-substr": "\"hello\".indexOf(\"hell\")",
  "substr": "\"hello\".substring(0, 4)",
  "extract-char": "\"hello\"(0)",
  "chr-ord": "'a'.toInt<br />97.toChar"
},
"dates-time": {
  "dates-time-types": "java.util.Date",
  "current-date-time": "import java.util.Date<br /><br />val dt = new Date()",
  "current-unix-epoch": "dt.getTime / 1000",
  "to-unix-epoch,-from-unix-epoch": "dt.getTime / 1000<br /><br />val dt2 = new Date(1451600610 * 1000)",
  "format-date": "import java.text.SimpleDateFormat<br /><br />val fmt = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")<br />val s = fmt.format(dt)",
  "parse-date": "import java.text.SimpleDateFormat<br /><br />val fmt = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")<br />val dt = fmt.parse(\"2011-05-03 17:00:00\")",
  "date-subtraction": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> difference in milliseconds as Long:</span><br />dt2.getTime - dt.getTime",
  "add-duration": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> add one day:</span><br />val dt2 = new Date(dt.getTime + 86400 * 1000)",
  "date-parts": "import java.util.Date<br />import java.util.Calendar<br />import java.util.GregorianCalendar<br /><br />al cal = new GregorianCalendar<br />cal.setTime(new Date)<br /><br />cal.get(Calendar.YEAR)<br />cal.get(Calendar.MONTH) + 1<br />cal.get(Calendar.DAY_OF_MONTH)",
  "time-parts": "import java.util.Date<br />import java.util.Calendar<br />import java.util.GregorianCalendar<br /><br />al cal = new GregorianCalendar<br />cal.setTime(new Date)<br /><br />cal.get(Calendar.HOUR_OF_DAY)<br />cal.get(Calendar.MINUTE)<br />cal.get(Calendar.SECOND)",
  "build-broken-down-datetime": "import java.util.GregorianCalendar<br /><br />val cal = new GregorianCalendar(2015, 12, 31, 23, 59, 59)<br />val dt = cal.getTime"
},
"fixed-length-arrays": {
  "array-literal": "val a = Array(1, 2, 3)",
  "array-size": "a.size",
  "array-lookup": "val n = a(0)",
  "array-update": "a(2) = 4",
  "array-out-of-bounds": "<span style=\"color: gray\"><em>raises</em></span> java.lang.ArrayIndexOutOfBounds"
},
"resizable-arrays": {
  "declare-array": "",
  "array-literal": "import scala.collection.mutable.ArrayBuffer<br /><br />val a = ArrayBuffer(1, 2, 3)",
  "array-size": "a.length",
  "array-lookup": "a(0)",
  "array-update": "a(0) = 4",
  "array-out-of-bounds": "<span style=\"color: gray\"><em>raises</em> java.lang.ArrayIndexOutOfBoundsException</span>",
  "array-element-index": "a.indexOf(3)",
  "slice-array": "val a = ArrayBuffer(\"a\", \"b\", \"c\", \"d\", \"e\")<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> ArrayBuffer(\"c\", \"d\"):</span><br />a.slice(2, 4)",
  "slice-array-to-end": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> ArrayBuffer(\"c\", \"d\", \"e\"):</span><br />a.drop(2)",
  "array-back": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> two ways to append:</span><br />a.append(4)<br />a += 4<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> inspect last item:</span><br />val x = a.last<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> pop last item:</span><br />val y = a.remove(a.length - 1)",
  "array-front": "val a = ArrayBuffer(7, 8, 9)<br /><br />a.insert(0, 6)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> inspect first element:</span><br />val x = a.first<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> pop first element:</span><br />val y = a.remove(0)",
  "concatenate-array": "val a1 = ArrayBuffer(1, 2, 3)<br />val a2 = ArrayBuffer(4, 5, 6)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> new ArrayBuffer:</span><br />val a2 = a1 ++ a2<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> add elements to a1:</span><br />a1 ++= a2",
  "copy-array": "val a = ArrayBuffer(1, 2, 3)<br />val a2 = ArrayBuffer[Int]()<br />a2 ++= a",
  "iterate-over-array": "for (n &lt;- a)<br /><span style=\"white-space: pre-wrap;\">  </span>println(n)",
  "iterate-indices-elem": "for ((n, i) &lt;- a.zipWithIndex) {<br /><span style=\"white-space: pre-wrap;\">  </span>println(s\"item: $n is at: $i\")<br />}",
  "reverse-array": "val a2 = a.reverse",
  "sort-array": "val a = ArrayBuffer(3, 1, 4, 2)<br />val a2 = a.sortWith(_ &lt; _)",
  "array-dedupe": "ArrayBuffer(1, 2, 3, 3).distinct<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> scala.collection.immutable.Set[Int]:</span><br />val set = a.toSet",
  "array-membership": "ArrayBuffer(1, 2, 3).contains(7)",
  "array-intersection": "val a1 = ArrayBuffer(1, 2)<br />val a2 = ArrayBuffer(2, 3, 4)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> multiset intersection:</span><br />a1.intersect(a2)",
  "array-union": "val a1 = ArrayBuffer(1, 2)<br />val a2 = ArrayBuffer(2, 3, 4)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> multiset union:</span><br />a1.union(a2)",
  "array-relative-complement": "val a1 = ArrayBuffer(1, 2)<br />val a2 = ArrayBuffer(2, 3, 4)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> multiset difference:</span><br />a1.diff(a2)",
  "map": "a.map(x =&gt; x * x)",
  "filter": "a.filter(_ &gt; 2)",
  "array-fold-left": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> -6:</span><br />ArrayBuffer(1, 2, 3).foldLeft(0)(_ - _)",
  "array-fold-right": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> -2:</span><br />ArrayBuffer(1, 2, 3).foldRight(0)(_ - _)",
  "array-shuffle": "val rand = scala.util.Random<br />val a = rand.shuffle(ArrayBuffer(1, 2, 3, 4))",
  "array-flatten": "val a = ArrayBuffer(ArrayBuffer(1, 2), ArrayBuffer(3, 4))<br />val a2 = a.flatten",
  "array-zip": "ArrayBuffer(1, 2, 3).zip(ArrayBuffer(\"a\", \"b\", \"c\"))"
},
"lists": {
  "list-literal": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> none; use constructor:</span><br />List(1, 2, 3)",
  "empty-list": "Nil<br />List()",
  "empty-list-test": "val list = List(1, 2, 3)<br /><br />list == Nil<br />list.isEmpty",
  "cons": "1 :: List(2, 3)",
  "head": "List(1, 2, 3).head",
  "tail": "List(1, 2, 3).tail",
  "head-tail-empty-list": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> NoSuchElementException:</span><br />Nil.head<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> UnsupportedOperationException:</span><br />Nil.tail",
  "list-length": "List(1, 2, 3).length",
  "nth-elem-of-list": "List(1, 2, 3)(0)",
  "list-elem-index": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> evaluates to 1:</span><br />List(7, 8, 9).indexOf(8)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> evaluates to -1:</span><br />List(7, 8, 9).indexOf(10)",
  "update-list": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> evaluates to List(1, 4, 3):</span><br />List(1, 2, 3).updated(1, 4)",
  "concat-list": "List(1, 2) ::: List(3, 4)<br />List(1, 2) ++ List(3, 4)<br /><br />List(List(1, 2), List(3, 4)).flatten",
  "list-last": "List(1, 2, 3).last<br />List(1, 2, 3).init",
  "list-take": "List(1, 2, 3).take(2)",
  "list-drop": "List(1, 2, 3).drop(2)",
  "iterate-over-list": "List(1, 2, 3).foreach(i =&gt; println(i))<br /><br />for (i &lt;- List.range(1, 11).reverse)<br /><span style=\"white-space: pre-wrap;\">  </span>println(i)",
  "reverse-list": "List(1, 2, 3).reverse",
  "sort-list": "List(1, 3, 2, 4).sortWith((x, y) =&gt; x &lt; y)<br />List(1, 3, 2, 4).sortWith(_ &lt; _)<br />List(1, 3, 2, 4).sortWith((x, y) =&gt; x &gt; y)<br />List(1, 3, 2, 4).sortWith(_ &gt; _)",
  "map-list": "List(1, 2, 3).map(x =&gt; 2 * x)<br />List(1, 2, 3).map(2 * _)",
  "filter-list": "List(1, 2, 3).filter(x =&gt; x &gt; 2)",
  "fold-list-left": "List(1, 2, 3).foldLeft(0)(_ + _)<br />List(1, 2, 3).foldLeft(0)((x, y) =&gt; x + y)",
  "fold-list-right": "List(1, 2, 3).foldRight(0)(_ - _)",
  "list-member": "List(1, 2, 3).contains(3)",
  "universal-test-list": "List(1, 2, 3).forall(_ &gt; 2)",
  "existential-test-list": "List(1, 2, 3).exists(_ &gt; 2)",
  "zip-list": "List(1, 2, 3).zip(List(\"a\", \"b\", \"c\"))"
},
"tuples": {
  "tuple-literal": "(1, \"hello\", true)",
  "tuple-type": "val tup: (Int, String, Boolean) = (7, \"foo\", true)",
  "tuple-lookup": "val tup = (1, \"hello\", true)<br />val n: Int = tup._1",
  "deconstruct-tuple": "val tup = (1, \"hello\", true)<br />tup match {<br /><span style=\"white-space: pre-wrap;\">  </span>case (_, s, _) =&gt; println(s)<br /><span style=\"white-space: pre-wrap;\">  </span>case _ =&gt; throw new Exception(\"bad tuple\")<br />}"
},
"dictionaries": {
  "declare-dict": "import scala.collection.mutable<br /><br />val dict = mutable.Map.empty[String, Int]",
  "dict-literal": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> scala.collection.immutable.Map[String,Int]:</span><br />val dict = Map(\"t\" -&gt; 1, \"f\" -&gt; 0)",
  "dict-size": "dict.size",
  "dict-lookup": "dict(\"f\")<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> returns Option[Int]:</span><br />dict.get(\"f\")",
  "dict-update": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> mutable.Map only:</span><br />dict(\"t\") = 2",
  "dict-out-of-bounds": "<span style=\"color: gray\"><em>raises</em> java.util.NoSuchElementException</span>",
  "dict-is-key-present": "dict.exists(kv =&gt; kv._1 == \"t\")",
  "dict-delete": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> mutable.Map only:</span><br />dict.delete(\"t\")",
  "dict-iterate": "for (kv &lt;- dict) {<br /><span style=\"white-space: pre-wrap;\">  </span>println(kv._1)<br /><span style=\"white-space: pre-wrap;\">  </span>println(kv._2)<br />}",
  "dict-key-val": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Iterable[String]:</span><br />dict.keys<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Array[String]:</span><br />dict.keys.toArray<br />dict.values<br />dict.values.toArray"
},
"functions": {
  "def-func": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> argument types must be declared:</span><br />def average(a: Double, b: Double)<br /><span style=\"white-space: pre-wrap;\">  </span>= (a + b) / 2.0<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> return value type must be declared if<br /><span style=\"white-space: pre-wrap;\">//</span> function is recursive:</span><br />def factorial(n: Int): Int =<br /><span style=\"white-space: pre-wrap;\">  </span>if (n &lt; 1)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>1<br /><span style=\"white-space: pre-wrap;\">  </span>else<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>n * factorial(n - 1)",
  "invoke-func": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 3.0:</span><br />average(1, 2 + 3)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 4.5:</span><br />average(1, 2) + 3<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> parens can be omitted when a function<br /><span style=\"white-space: pre-wrap;\">//</span> takes no arguments; by convention parens<br /><span style=\"white-space: pre-wrap;\">//</span> are omitted when the function has no<br /><span style=\"white-space: pre-wrap;\">//</span> side effects</span>",
  "define-function-with-block-body": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> braces must be used if body<br /><span style=\"white-space: pre-wrap;\">//</span> not an expression:</span><br />def print_numbers() = {<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"one\")<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"two\")<br />}",
  "nest-func": "",
  "named-parameter": "def subtract(m: Int, s: Int) = m - s<br /><br />subtract(s = 3, m = 7)",
  "named-parameter-default-value": "def logarithm(x: Double,<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>base: Double = math.exp(1)) =<br /><span style=\"white-space: pre-wrap;\">  </span>math.log(x) / math.log(base)<br /><br />logarithm(2.718)<br />logarithm(10, base = 2)",
  "variable-num-arg": "",
  "overload-function": "",
  "retval": "<span style=\"color: gray\"><em>if function body is preceded by</em> = // the return value is the// return <em>arg or last expression evaluated.</em></span><br /><br /><span style=\"color: gray\"><em>If function body not preceded by</em> = <em>the return value is</em> Unit.</span>",
  "multiple-retval": "",
  "recursive-function": "def range(a:Int, b:Int): List[Int] =<br /><span style=\"white-space: pre-wrap;\">  </span>if (a &gt; b)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>List()<br /><span style=\"white-space: pre-wrap;\">  </span>else<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a :: range(a + 1, b)",
  "anonymous-function": "(x: Double, y: Double) =&gt; (x + y) / 2.0",
  "invoke-anonymous-func": "",
  "func-as-val": "",
  "infix-operator-in-prefix-position": "<span style=\"color: gray\"><em>none</em></span>",
  "function-in-infix-position": "<span style=\"color: gray\"><em>unary methods can be used as binary operators</em></span>",
  "currying": "def plus(x: Int)(y: Int) = x + y<br />plus(3)(7)<br />def plus2 = plus(2)<br />plus2(7)",
  "lazy-evaluation": "def arg1(x: =&gt; Int, y: =&gt; Int): Int = x<br /><br />arg1(7, 1 / 0)"
},
"execution-control": {
  "if": "if (x &gt; 0)<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"pos\")<br />else if (x &lt; 0)<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"neg\")<br />else<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"zero\")",
  "while": "var i = 0<br />while (i&lt;10) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"%d\\n\", i)<br /><span style=\"white-space: pre-wrap;\">  </span>i = i+1<br />}",
  "for": "for (i &lt;- 1 to 10)<br /><span style=\"white-space: pre-wrap;\">  </span>println(i)",
  "infinite-loop": "while (true) {<br /><br />}",
  "break-continue": "import scala.util.control.Breaks.break<br /><br />for (i &lt;- 1 to 10)<br /><span style=\"white-space: pre-wrap;\">  </span>if (i &gt; 5)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break<br /><span style=\"white-space: pre-wrap;\">  </span>else<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>println(i)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> there is no continue statement</span>"
},
"exceptions": {
  "raise-error": "throw new Exception(\"bam!\")",
  "handle-error": "import java.lang._<br /><span style=\"white-space: pre-wrap;\"> </span><br />val x = try {<br /><span style=\"white-space: pre-wrap;\">  </span>1 / 0<br />}<br />catch {<br /><span style=\"white-space: pre-wrap;\">  </span>case e: ArithmeticException =&gt; 0<br />}",
  "standard-exceptions": "<span style=\"color: gray\"><em>defined in</em> java.lang:</span><br /><br />Throwable<br /><span style=\"white-space: pre-wrap;\">  </span>Error<br /><span style=\"white-space: pre-wrap;\">  </span>Exception<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>IOException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>EOFException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>FileNotFoundException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>MalformedURLException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>UnknownHostException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>ClassNotFoundException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>CloneNotSupportedException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>RuntimeException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>ArithmeticException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>ClassCastException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>IllegalArgumentException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>IllegalStateException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>IndexOutOfBoundsException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>NoSuchElementException<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>NullPointerException<br /><br /><span style=\"color: gray\">Error, RuntimeException, <em>and subclasses theoreof are normally unrecoverable</em></span>",
  "assert": "assert(1 == 0)"
},
"concurrency": {
},
"file-handles": {
  "standard-file-handles": "System.in<br />System.out<br />System.err",
  "read-line-from-stdin": "import scala.io.StdIn.readLine<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> newline is removed:</span><br />val s = readLine()",
  "write-line-to-stdout": "println(\"lorem ipsum\")",
  "write-formatted-string-to-stdout": "printf(\"%s %d %.2f\", \"Spain\", 17, 3.1415)",
  "open-file-for-reading": "import scala.io.Source<br /><br />val path = \"/etc/hosts\"<br />val f = Source.fromFile(path)",
  "open-file-for-writing": "",
  "open-file-for-appending": "",
  "close-file": "import scala.io.Source<br /><br />f.close",
  "close-file-implicitly": "",
  "read-line": "import scala.io.Source<br />val src = Source.fromFile(\"/etc/passwd\")<br />for (line &lt;- src.getLines)<br /><span style=\"white-space: pre-wrap;\">  </span>print(line)",
  "iterate-over-file-by-line": "",
  "read-file-into-array-of-strings": "",
  "read-file-into-string": "",
  "write-string": "",
  "write-line": "val out = new java.io.FileWriter(\"/tmp/test-scala\")<br />out.write(\"hello out\\n\")<br />out.close",
  "flush-file-handle": "",
  "get-and-set-filehandle-position": ""
},
"files": {
  "file-test,-regular-file-test": "import java.io.File<br /><br />val f = new File(\"/etc/hosts\")<br />f.exists<br />f.isFile",
  "file-size": "import java.io.File<br /><br />val f = new File(\"/etc/hosts\")<br />f.length",
  "is-file-readable,-writable,-executable": "import java.io.File<br /><br />val f = new File(\"/etc/hosts\")<br />f.canRead<br />f.canWrite<br />f.canExecute",
  "set-file-permissions": "mport java.io.File<br /><br />val f = new File(\"/tmp/foo\")<br /><br /><span style=\"color: gray\">// sets owner perms; to turn perms off<br />// set arg to false:</span><br />f.setReadable(true)<br />f.setWritable(true)<br />f.setExecutable(true)<br /><br /><span style=\"color: gray\">// if 2nd arg is false, perms are<br />// for owner, group, and other:</span><br />f.setReadable(true, false)<br />f.setWritable(true, false)<br />f.setExecutable(true, false)",
  "copy-file,-remove-file,-rename-file": "import java.nio.file.Files<br />import java.nio.file.Paths<br /><br />val path = Paths.get(\"/tmp/foo\")<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> possible java.nio.file.FileAlreadyExistsException:</span><br />Files.copy(path, Paths.get(\"/tmp/bar\"))<br /><br />Files.deleteIfExists(path)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> possible java.nio.file.NoSuchFileException:</span><br />Files.delete(path)<br /><br />Files.move(Paths.get(\"/tmp/bar\", path)",
  "create-symlink,-symlink-test,-readlink": "import java.nio.file.Files<br />import java.nio.file.Paths<br /><br />val target = Paths.get(\"/etc/hosts\")<br />val path = Paths.get(\"/tmp/hosts\")<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Possible java.nio.file.FileAlreadyExistsException:</span><br />Files.createSymbolicLink(path, target)<br />Files.isSymbolicLink(path)<br />Files.readSymbolicLink(path)",
  "generate-unused-file-name": "import java.nio.file.Files<br /><br />val path = Files.createTempFile(\"foo\", \".txt\")"
},
"directories": {
  "build-pathname": "import java.io.File<br /><br />val root = File.listRoots()(0)<br />val hosts = new File(new File(root, \"etc\"), \"hosts\")<br />val path = hosts.getPath",
  "dirname-and-basename": "import java.io.File<br /><br />val f = new File(\"/etc/hosts\")<br />val dirn = f.getParent<br />val basen = f.getName",
  "iterate-over-directory-by-file": "import java.io.File<br /><br />val dir = new File(\"/etc\")<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Array[String]:</span><br />dir.list<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Array[java.io.File]:</span><br />dir.listFiles",
  "make-directory": "import java.io.File<br /><br />val dir = new File(\"/tmp/foo/dir\")<br />dir.mkdirs",
  "remove-empty-directory": "import java.io.File<br /><br />val dir = new File(\"/tmp/foodir\")<br />dir.delete",
  "remove-directory-and-contents": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> libraryDependencies += \"commons-io\" % \"commons-io\" % \"2.4\"</span><br />import org.apache.commons.io.FileUtils<br />import java.io.File<br /><br />FileUtils.deleteDirectory(new File(\"/tmp/foo\"))",
  "directory-test": "import java.io.File<br /><br />val f = new File(\"/etc\")<br />f.isDirectory",
  "temporary-directory": "import java.nio.file.Files<br /><br />val dir = Files.createTempDirectory(null)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> path as string:</span><br />dir.toString<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> arrange for directory to be deleted:</span><br />dir.toFile.deleteOnExit"
},
"processes-environment": {
  "command-line-arguments": "object Test {<br /><span style=\"white-space: pre-wrap;\">  </span>def main(args: Array[String]) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>for (arg &lt;- args)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>println(arg)<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "program-name": "<span style=\"color: gray\"><em>A scala program is run as</em><br /><br /><span style=\"white-space: pre-wrap;\">  </span>scala CLASS [ARG …]<br /><br /><em>The VM then searches</em> CLASSPATH <em>for</em> CLASS. CLASS <em>is the nearest analog to the program name and can be determined statically.</em></span>",
  "getopt": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> built.sbt:<br /><span style=\"white-space: pre-wrap;\">//</span><br /><span style=\"white-space: pre-wrap;\">//</span><span style=\"white-space: pre-wrap;\">   </span>libraryDependencies += \"com.github.scopt\" %% \"scopt\" % \"3.3.0\"</span><br /><br />case class Config(<br /><span style=\"white-space: pre-wrap;\">  </span>foo: Int = 0,<br /><span style=\"white-space: pre-wrap;\">  </span>bar: String = \"\"<br />)<br /><br />val parser = new scopt.OptionParser[Config](\"scopt\") {<br /><span style=\"white-space: pre-wrap;\">  </span>opt[Int]('f', \"foo\") action { (x, c) =&gt;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>c.copy(foo = x) } text(\"foo is integer\")<br /><span style=\"white-space: pre-wrap;\">  </span>opt[String]('b', \"bar\") action{ (x, c) =&gt;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>c.copy(bar = x) } text(\"bar is string\")<br />}<br /><br />parser.parse(args, Config()) match {<br /><span style=\"white-space: pre-wrap;\">  </span>case Some(config) =&gt;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>println(config.foo)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>println(config.bar)<br /><span style=\"white-space: pre-wrap;\">  </span>case None =&gt;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> bad args; usage was displayed</span><br />}",
  "env-var": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> java.util.NoSuchElementException if not defined:</span><br />sys.env(\"HOME\")<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> returns Option[String]:</span><br />sys.env.get(\"HOME\")<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Environment variables are read only, but new values can be<br /><span style=\"white-space: pre-wrap;\">//</span> set when creating child processes.</span>",
  "pid": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> no portable technique</span>",
  "user-id-name": "System.getProperty(\"user.name\")<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> no property for uid</span>",
  "exit": "System.exit(1)",
  "signal-handler": "import sun.misc._<br /><br />Signal.handle(new Signal(\"INT\"), new SignalHandler() {<br /><span style=\"white-space: pre-wrap;\">  </span>val start = System.nanoTime()<br /><span style=\"white-space: pre-wrap;\">  </span>def handle(sig: Signal) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>val end = System.nanoTime()<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>println(s\"\\n${(end - start) / 1e9f} seconds\")<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>System.exit(0)<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />})",
  "external-cmd": "import scala.sys.process._<br /><br />val exitCode = \"ls /tmp\".!",
  "escaped-external-cmd": "import scala.sys.process._<br />import java.io.File<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> if args contain spaces, use List():</span><br />val exitCode = List(\"touch\", \"/tmp/some file\").!<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> there are operators for shell <span style=\"white-space: pre-wrap;\">&amp;&amp;, ||, and |</span>:</span><br />(( \"ls /tmp\" #<span style=\"white-space: pre-wrap;\">&amp;&amp;</span> \"ls /etc\") #| \"grep ssh\").!<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> redirection example:</span><br />(\"ls\" #&gt; new File(\"/tmp/ls.out\")).!",
  "backticks": "import scala.sys.process._<br /><br />val s = \"ls\".<span style=\"white-space: pre-wrap;\">!!</span>"
},
"libraries-namespaces": {
  "define-namespace": "package foo {<br /><span style=\"white-space: pre-wrap;\">  </span>class A<br /><span style=\"white-space: pre-wrap;\">  </span>class B<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Alternate syntax; must be first statement in file;<br /><span style=\"white-space: pre-wrap;\">//</span> declares entire file to be in namespace</span><br />package foo",
  "define-child-namespace": "package foo.bar {<br /><span style=\"white-space: pre-wrap;\">  </span>class A<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Alternate nested syntax:</span><br />package foo {<br /><span style=\"white-space: pre-wrap;\">  </span>package bar {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>class A<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Alternate syntax; must be first statement in file:</span><br />package foo.bar",
  "reference-identifier-in-another-file": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> no import needed if identifier is fully qualified:</span><br />val a = new foo.bar.A",
  "import-definitions": "import foo.A<br /><br />val a = new A<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> imports A and B:</span><br />import foo.{A, B}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Import statements can appear after or inside class definitions,<br /><span style=\"white-space: pre-wrap;\">//</span> or inside methods.</span>",
  "import-all-definitions-in-namespace": "import foo._<br /><br />val a = new A<br />val b = new B",
  "import-namespace": "import foo.bar<br /><br />val a = new bar.A<br />val b = new bar.B",
  "shadow-avoidance": "import foo.bar.{A =&gt; LetterA}<br /><br />val a = new LetterA",
  "library-path-environment-variable": "$ cat src/foo/bar/A.scala<br />package foo.bar<br /><br />object A {<br /><span style=\"white-space: pre-wrap;\">  </span>def main(args: Array[String]) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>println(\"Hello, World!\")<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br /><br />$ scalac src/foo/bar/A.scala<br /><br />$ dir=$(pwd)<br /><br />$ cd /<br /><br />$ CLASSPATH=$dir scala foo.bar.A<br /><br /><span style=\"color: gray\"><em>The default CLASSPATH is the current directory. Directories are separated by colons : on Unix and semicolons ; on Windows. Jar files can also be put in the CLASSPATH.</em></span>",
  "create-package": "$ cat src/foo/bar/A.scala<br />package foo.bar<br /><br />object A {<br /><span style=\"white-space: pre-wrap;\">  </span>def main(args: Array[String]) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>println(\"Hello, World!\")<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br /><br />$ mkdir target<br /><br />$ scalac -d target src/foo/bar/A.scala<br /><br />$ find target -name '*.class' | xargs jar cf App.jar<br /><br />$ CLASSPATH=App.jar scala foo.bar.A",
  "inspect-package": "$ jar tf App.jar",
  "install-package": "$ cat build.sbt<br />libraryDependencies += \"commons-io\" % \"commons-io\" % \"2.4\"<br /><br />$ sbt package",
  "list-installed-packages": "$ find ~/.ivy2/cache -name '*.jar'"
},
"user-defined-types": {
  "type-synonym": "type Name = String",
  "sum-type": "abstract class Color<br /><br />case object Red extends Color<br />case object Blue extends Color<br />case object Green extends Color<br /><br />val col = Red<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> this won't compile:</span><br />col &lt; Green",
  "tuple-product-type-with-one-field": "class SpecialInt(x: Int)<br /><br />val n = new SpecialInt(7)",
  "tuple-product-type-with-two-fields": "class IntPair(a: Int, b: Int)<br /><br />val p = new IntPair(7, 11)",
  "record-product-type": "case class Customer(<br /><span style=\"white-space: pre-wrap;\">  </span>id: Int,<br /><span style=\"white-space: pre-wrap;\">  </span>name: String,<br /><span style=\"white-space: pre-wrap;\">  </span>address: String<br />)",
  "record-product-type-literal": "Customer(7,\"John\",\"Topeka, KS\")<br /><br />Customer(id=7, name=\"John\", address=\"Topeka, KS\")",
  "product-type-member-access": "",
  "product-type-member-assignment": "",
  "generic-type": "class Twosome[A, B](a: A, b: B)<br /><br />val p = new Twosome(\"pi\", 3.14)",
  "recursive-type": "abstract class BinaryTree<br />case class Tree(left: BinaryTree, right: BinaryTree) extends BinaryTree<br />case class Leaf(x: Int) extends BinaryTree",
  "pattern-match-sum-type": "val c:Color = Red;<br />c match { case Red =&gt; \"red\"; case Green =&gt; \"green\"; case Blue =&gt; \"blue\" }",
  "pattern-match-product-type": "",
  "pattern-match-guard": "match { case i: Int if i &lt; 0 =&gt; - i; case i: Int =&gt; i }",
  "pattern-match-catchall": "val c : Color = Green<br />c match { case Red =&gt; \"red\"; case _ =&gt; \"not red\" }"
},
"objects": {
  "define-class": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Constructor takes optional param of type Int.<br /><span style=\"white-space: pre-wrap;\">//</span><br /><span style=\"white-space: pre-wrap;\">//</span> Precede param name by val or var<br /><span style=\"white-space: pre-wrap;\">//</span> to implicitly define an instance variable</span><br />class Counter(n: Int = 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Executes when object is created.<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">//</span><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">//</span> java.lang.IllegalArgumentException if false.</span><br /><span style=\"white-space: pre-wrap;\">  </span>require(n &gt;= 0)<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Instance variables public by default</span><br /><span style=\"white-space: pre-wrap;\">  </span>private var _n = n<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Getter:</span><br /><span style=\"white-space: pre-wrap;\">  </span>def value = _n<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Setter:</span><br /><span style=\"white-space: pre-wrap;\">  </span>def value_=(n: Int) { _n = n }<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Object-mutating method:</span><br /><span style=\"white-space: pre-wrap;\">  </span>def incr { _n += 1 }<br />}",
  "create-object": "val c = new Counter<br />val c2 = new Counter(1)",
  "invoke-method": "c.incr()<br />c.value = c.value + 1",
  "define-class-variable-and-method": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Define singleton object outside of class body:</span><br />object Counter {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Class variables can be declared private; Counter constructor<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">//</span> and instance methods stil have access:</span><br /><span style=\"white-space: pre-wrap;\">  </span>var instances = 0<br /><br /><span style=\"white-space: pre-wrap;\">  </span>def incrInstances { instances += 1 }<br />}",
  "invoke-class-method": "Counter.incrInstances"
},
"inheritance-polymorphism": {
  "subclass": "class Base {<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"instantiating Base\")<br /><span style=\"white-space: pre-wrap;\">  </span><br /><span style=\"white-space: pre-wrap;\">  </span>def name = { \"Base\" }<br />}<br /><br />class Derived extends Base {<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"instantiating Derived after Base\")<br /><span style=\"white-space: pre-wrap;\">  </span><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Compilation error if override omitted or<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">//</span> if method with same name not defined in base class.</span><br /><span style=\"white-space: pre-wrap;\">  </span>override def name = { \"Derived\" }<br />}",
  "abstract-base-class": "abstract class Base {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> compilation error if derived class does not define name:</span><br /><span style=\"white-space: pre-wrap;\">  </span>def name: String<br />}",
  "mixin": ""
},
"unit-tests": {
  "test-class": "import org.scalatest.FunSuite<br /><br />class FooSuite extends FunSuite {<br /><span style=\"white-space: pre-wrap;\">  </span>test(\"a simple test\") {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>assert(0 == 0, \"zero not equal to itself\")<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "run-all-tests,-run-test-suite": "$ cat build.sbt<br />libraryDependencies +=<br /><span style=\"white-space: pre-wrap;\">  </span>\"org.scalatest\" %% \"scalatest\" % \"3.0.0-SNAP13\"<br /><br />$ sbt test<br /><br />$ sbt<br /><span style=\"white-space: pre-wrap;\">&gt;</span> testOnly FooSuite",
  "exception-assertion": "intercept[IndexOutOfBoundsException] {<br /><span style=\"white-space: pre-wrap;\">  </span>\"val a = List(1, 2, 3)<br /><span style=\"white-space: pre-wrap;\">  </span>\"val n = a(4)<br />}",
  "setup": "import org.scalatest.FunSuite<br />import org.scalatest.BeforeAndAfter<br /><br />class FooSuite extends FunSuite with BeforeAndAfter {<br /><span style=\"white-space: pre-wrap;\">  </span>before {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>print(\"before called\\n\")<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br /><span style=\"white-space: pre-wrap;\">  </span>test(\"zero equals self\") {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>assert(0 == 0)<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "teardown": "import org.scalatest.FunSuite<br />import org.scalatest.BeforeAndAfter<br /><br />class FooSuite extends FunSuite with BeforeAndAfter {<br /><span style=\"white-space: pre-wrap;\">  </span>test(\"zero equals self\") {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>assert(0 == 0)<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br /><span style=\"white-space: pre-wrap;\">  </span>after {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>print(\"after called\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}"
},
"debugging-profiling": {
  "lint": "$ brew install scalastyle<br />$ scalastyle Hello.scala",
  "run-debugger": "<span style=\"color: gray\"><em>Scala IDE for Eclipse has a debugger</em></span>",
  "profile-code": "<span style=\"color: gray\"><em>Runs app under a sampling profiler. Profiling info is written to stdout. HotSpot VM only.</em></span><br />$ JAVA_OPTS=-Xprof scala SomeApp",
  "memory-tool": "$ JAVA_OPTS=-XX:+PrintGCDetails scala SomeApp"
},
"repl": {
  "invoke-repl": "$ scala",
  "previous-values": "res0, res1, …",
  "help": ":help",
  "quit": ":quit",
  "inspect-type": "<span style=\"color: gray\"><em>repl displays the type of any expression entered</em></span>"
}
}
