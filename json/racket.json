{
"version": {
  "version-used": "<span style=\"color: gray\"><em>Racket 6.1</em></span>",
  "show-version": "$ racket <span style=\"white-space: pre-wrap;\">--</span>version"
},
"grammar-execution": {
  "compiler": "$ raco make <span style=\"color: gray\"><em>module</em></span>.rkt",
  "standalone-executable": "$ mzc —exe <span style=\"color: gray\"><em>executable</em></span> <span style=\"color: gray\"><em>file</em></span>",
  "interpreter": "$ racket -r foo.racket",
  "shebang": "#!/usr/bin/env racket <span style=\"white-space: pre-wrap;\">--</span>script",
  "repl": "$ racket",
  "cmd-line-program": "$ racket -e '(+ 1 1)'",
  "word-separator": "<span style=\"color: gray\"><em>whitespace</em></span>",
  "eol-comment": "(+ 1 1) <span style=\"color: gray\">; adding</span>",
  "multiple-line-comment": "(+ 1 #| adding |# 1)"
},
"var-expr": {
  "id": "<span style=\"color: gray\"><em>case sensitive, cannot start with digit</em></span><br /><br /><span style=\"color: gray\"><em>excluded characters:</em></span><br />SP ( ) [ ] { } \" , ' <span style=\"white-space: pre-wrap;\">`</span> ; # | \\",
  "quoted-id": "(define |white space symbol| 3)<br /><br />(define white\\ space\\ symbol 3)",
  "local-var": "<span style=\"color: gray\">; parallel assignment:</span><br />(let ((x 3) (y 4))<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))<br /><br /><span style=\"color: gray\">; sequential assignment:</span><br />(let* ((x 3) (y (* x x)))<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))",
  "global-var": "(define x 3)<br /><br /><span style=\"color: gray\">; y is not global:</span><br />(define (double z)<br /><span style=\"white-space: pre-wrap;\">  </span>(define y 2)<br /><span style=\"white-space: pre-wrap;\">  </span>(* y z))",
  "rm-var": "(namespace-undefine-variable! 'x)",
  "null": "null '()",
  "null-test": "(null? x)",
  "id-as-val": "'x<br />(quote x)",
  "id-test": "(symbol? 'x)",
  "identifier-equality-test": "(eq? 'x 'x)",
  "non-referential-id": "#:foo",
  "id-attr": "<span style=\"color: gray\"><em>none</em></span>"
},
"arithmetic-logic": {
  "true-false": "#t #f<br />true false",
  "falsehoods": "#f false",
  "logical-op": "(or (not #t) (and #t #f))",
  "relational-op": "<span style=\"white-space: pre-wrap;\">=</span> <span style=\"color: gray\"><em>none</em></span> &lt; &gt; &lt;= &gt;=",
  "min-max": "(min 1 2 3)<br />(max 1 2 3)",
  "num-predicates": "number? integer?<br />rational? inexact?<br />real? complex?",
  "arith-op": "+ - * / modulo",
  "int-div": "(quotient 7 3)<br />(remainder 7 3)",
  "int-div-zero": "<span style=\"color: gray\">division by zero <em>error</em></span>",
  "float-div": "<span style=\"color: gray\"><em>rational:</em></span><br />(/ 7 3)<br /><br /><span style=\"color: gray\"><em>float:</em></span><br />(/ 7 (float 3))",
  "float-div-zero": "",
  "power": "(expt 2 32)",
  "sqrt": "(sqrt 2)",
  "sqrt-negative-one": "0+1i",
  "transcendental-func": "exp log sin cos tan asin acos atan atan",
  "float-truncation": "<span style=\"color: gray\"><em>return floats:</em></span><br />truncate round ceiling floor",
  "abs-val": "abs<br /><span style=\"color: gray\"><em>racket:</em></span> sgn",
  "int-overflow": "<span style=\"color: gray\"><em>none; arbitrary-precision integers</em></span>",
  "float-overflow": "",
  "rational-construction": "(/ 3 7)<br /><br /><span style=\"color: gray\">; literal:</span><br />3/7<br /><br /><span style=\"color: gray\">; also rational:</span><br />2.718<br />(exp 1)",
  "rational-decomposition": "(numerator 3/7)<br />(denominator 3/7)",
  "complex-construction": "1+2i<br />(+ 1 +2i)",
  "complex-decomposition": "(real-part 1+2i)<br />(imag-part 1+2i)<br />(angle 1+2i)<br />(magnitude 1+2i)<br />(conjugate 1+2i)",
  "random-num": "(random 100)<br />(random)<br /><span style=\"color: gray\"><em>none</em></span>",
  "random-seed": "(random-seed 17)",
  "bit-op": "arithmetic-shift <span style=\"color: gray\"><em>left shift when 2nd argument positive</em></span> bitwise-and bitwise-ior bitwise-xor bitwise-not",
  "binary-octal-hex-literals": "#b101010<br />#o52<br />#x2a",
  "radix": ""
},
"str": {
  "str-test": "(string? \"foo\")",
  "str-literal": "\"foo bar\"",
  "newline-in-str-literal": "<span style=\"color: gray\"><em>yes</em></span>",
  "str-literal-esc": "\\t \\n \\r \\\" \\\\ \\<span style=\"color: gray\"><em>ooo</em></span> \\u<span style=\"color: gray\"><em>hhhh</em></span>",
  "str-ctor": "(string #\\f #\\o #\\o)",
  "fmt-str": "(format \"~a ~a ~a\" \"Foo\" 7 13.457)",
  "fmt-specifiers": "<span style=\"color: gray\">~a<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>any type, human readable<br />~s<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>any time, read parseable<br />~%<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>newline<br />~~<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>tilde<br />~c<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>character<br /><br />~d<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>decimal<br />~x<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>hex<br />~o<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>octal<br />~b<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>binary</span>",
  "compare-str": "(string=? \"foo\" \"bar\")<br />(string&lt;? \"foo\" \"bar\")",
  "str-concat": "(string-append \"foo \" \"bar \" \"baz\")",
  "str-replicate": "(make-string 3 #\\f)",
  "translate-case": "(string-downcase \"FOO\")<br />(string-upcase \"foo\")",
  "capitalize": "",
  "trim": "(require srfi/13/string)<br />(string-trim-both \" foo \")",
  "pad": "",
  "num-to-str": "(string-append<br /><span style=\"white-space: pre-wrap;\">  </span>\"value: \"<br /><span style=\"white-space: pre-wrap;\">  </span>(number-&gt;string 8))",
  "str-to-num": "(+ 7 (string-&gt;number \"12\"))<br /><span style=\"white-space: pre-wrap;\"> </span><br />(+ 73.9 (string-&gt;number \".037\"))",
  "split": "(regexp-split #rx\"[ \\n\\t]+\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"foo bar baz\")",
  "str-join": "(string-join<br /><span style=\"white-space: pre-wrap;\">  </span>'(\"foo\" \"bar\" \"baz\")<br /><span style=\"white-space: pre-wrap;\">  </span>\" \")",
  "str-len": "(string-length \"foo\")",
  "index-substr": "<span style=\"color: gray\"><em>racket:</em></span><br />(require srfi/13/string)<br />(string-contains \"foo bar\" \"bar\")",
  "extract-substr": "(substring \"foo bar\" 4 7)",
  "char-literal": "#\\a #\\space #\\newline #\\backspace #\\tab #\\linefeed #\\page #\\return #\\nul #\\vtab #\\alarm #\\esc #\\delete<br /><span style=\"color: gray\"><em>not in racket:</em> #\\alarm #\\esc #\\delete</span>",
  "char-test": "(char? #\\x)",
  "chr-ord": "(integer-&gt;char 97)<br />(char-&gt;integer #\\a)",
  "str-to-char-array": "<span style=\"color: gray\">; list:</span><br />(string-&gt;list \"foo\")",
  "lookup-char": "(string-ref \"foo\" 0)"
},
"regex": {
  "regex-literal": "<span style=\"color: gray\"><em>posix extended:</em></span><br />#rx\"^[0-9][0-9][0-9][0-9][0-9]$\"<br />(regexp \"^[0-9][0-9][0-9][0-9][0-9]$\")<br /><br /><span style=\"color: gray\"><em>perl style:</em></span><br />#px\"\\\\b\\\\d{5}\\\\b\"<br />(pregexp \"\\\\b\\\\d{5}\\\\b\")",
  "char-class-abbrev": "<span style=\"color: gray\"><em>regexp:</em></span><br />.<br /><br /><span style=\"color: gray\"><em>pregexp:</em></span><br />. \\d \\D \\s \\S \\w \\W",
  "regex-anchors": "<span style=\"color: gray\"><em>regexp:</em></span><br />^ $<br /><br /><span style=\"color: gray\"><em>pregexp:</em></span><br />^ $ \\b \\B",
  "regex-test": "(regexp-match #rx\"bar\" \"foo bar\")",
  "case-insensitive-regex": "(regexp-match #px\"(?i:lorem)\" \"Lorem\")",
  "subst": "(regexp-replace #rx\"el\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"hello\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"EL\")<br /><span style=\"white-space: pre-wrap;\"> </span><br />(regexp-replace* #rx\"el\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"hello hello\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"EL\")",
  "group-capture": "(match (regexp-match<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>#px\"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"2010-06-03\")<br /><span style=\"white-space: pre-wrap;\">  </span>[(list s yr mn dy) (list yr mn dy)])",
  "scan": "",
  "backreference": "(regexp-match #px\"(\\\\w+) \\\\1\" \"do do\")<br /><br />(regexp-replace #px\"(\\\\w+) (\\\\w+)\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"do re\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"\\\\2 \\\\1\")"
},
"dates-time": {
  "broken-down-datetime-type": "",
  "current-datetime": "(require racket/date)<br /><br />(current-date)",
  "current-unix-epoch": "(current-seconds)",
  "unix-epoch-to-broken-down-datetime": "(seconds-&gt;date (current-seconds))",
  "broken-down-datetime-to-unix-epoch": "(require racket/date)<br /><br />(date-&gt;seconds (current-date))",
  "fmt-datetime": "",
  "parse-datetime": "(require (prefix-in s19. srfi/19))<br /><br />(define (date-str-&gt;unix-time s fmt)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(s19.time-second<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(s19.date-&gt;time-utc<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(s19.string-&gt;date s fmt))))<br /><br />(date-str-&gt;unix-time<br /><span style=\"white-space: pre-wrap;\">  </span>\"2015-05-31 07:06:00\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"~Y-~m-~d ~H:~M:~S\")",
  "datet-parts": "(date-year (current-date))<br />(date-month (current-date))<br />(date-day (current-date))",
  "time-parts": "(date-hour (current-date))<br />(date-minute (current-date))<br />(date-second (current-date))",
  "build-datetime": ""
},
"lists": {
  "literal<br-/>": "'(1 2 3)<br />'[1 2 3]<br />'{1 2 3}<br />(quote (1 2 3))",
  "constructor<br-/>": "(list 1 2 3)",
  "predicate<br-/>": "(list? '(1 2 3))",
  "empty-test": "(empty? '())",
  "evaluating-the-empty-list": "<span style=\"color: gray\"><em>error</em></span>",
  "cons<br-/>": "(cons 1 '(2 3))",
  "head<br-/>": "(car '(1 2 3))<br />(first '(1 2 3))",
  "tail<br-/>": "(cdr '(1 2 3))<br />(rest '(1 2 3))",
  "head-and-tail-of-empty-list": "<span style=\"color: gray\"><em>error</em></span>",
  "length<br-/>": "(length '(1 2 3))",
  "equality-test<br-/>": "(equal? '(1 2 3) '(1 2 3))",
  "nth-element": "(list-ref '(1 2 3 4) 2)",
  "out-of-bounds-behavior": "<span style=\"color: gray\"><em>error</em></span>",
  "element-index": "(require srfi/1)<br /><br />(list-index (lambda (x) (= x 7)) '(5 6 7 8))",
  "concatenate<br-/>": "(append '(1 2 3) '(4 5 6))",
  "take<br-/>": "(take '(1 2 3 4) 2)",
  "drop<br-/>": "(drop '(1 2 3 4) 2)",
  "last-element<br-/>": "(last '(1 2 3))",
  "all-but-last-element": "(define a '(1 2 3))<br />(take a (- (length a) 1))",
  "reverse<br-/>": "(reverse '(1 2 3))",
  "sort<br-/>": "(sort '(3 2 4 1) &lt;)",
  "dedupe<br-/>": "(remove-duplicates '(1 1 2 3))",
  "membership<br-/>": "(member 7 '(1 2 3))",
  "map": "(map (lambda (x) (* x x)) '(1 2 3))",
  "filter": "(filter<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (x) (&gt; x 2))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3))<br /><br /><span style=\"color: gray\">; filter-not returns complement</span>",
  "reduce": "(foldl (lambda (x y) (- y x)) 0 '(1 2 3 4))",
  "right-fold": "(foldr - 0 '(1 2 3 4))",
  "iterate": "(for ((x '(1 2 3)))<br /><span style=\"white-space: pre-wrap;\">  </span>(printf \"~a~n\" x)<br /><span style=\"white-space: pre-wrap;\">  </span>(printf \"~a~n\" (- x)))",
  "universal-predicate": "(for/and ((i '(1 2 3 4)))<br /><span style=\"white-space: pre-wrap;\">  </span>(= 0 (remainder i 2)))",
  "existential-predicate": "(for/or ((i '(1 2 3 4)))<br /><span style=\"white-space: pre-wrap;\">  </span>(= 0 (remainder i 2)))",
  "list-comprehension": "(for*/list<br /><span style=\"white-space: pre-wrap;\">  </span>((file \"ABCDEFGH\") (rank (in-range 1 9)))<br /><span style=\"white-space: pre-wrap;\">  </span>(format \"~a~a\" file rank))",
  "shuffle<br-/>": "(shuffle '(1 2 3 4))",
  "set-head": "(require schema/mpair)<br /><br />(define a (mlist 1 2 3))<br />(set-mcar! a 3)",
  "set-tail": "(require schema/mpair)<br /><br />(define a (mlist 1 2 3))<br />(set-mcdr! a (mlist 4 5 6))",
  "manipulate-back": "<span style=\"color: gray\"><em>none</em></span>",
  "flatten": "(flatten '(1 2 (3 (4))))",
  "associative-array-lookup<br-/>": "(assoc 3 '((1 2) (3 4)))",
  "flat-associative-array-lookup<br-/>": "<span style=\"color: gray\"><em>none</em></span>",
  "pair-literal<br-/>": "'(1 . 2)",
  "cons-cell-test": "(cons? '(1 . 2))<br />(pair? '(1 . 2))",
  "translate-elements-recursively": ""
},
"fixed-length-arrays": {
  "fixed-len-array-literal": "#(1 2 3)",
  "constructor<br-/>": "(vector 1 2 3)",
  "size<br-/>": "(vector-length #(1 2 3))",
  "lookup": "(vector-ref #(1 2 3) 0)",
  "update": "(define v (vector 1 2 3))<br />(vector-set! v 2 4)",
  "out-of-bounds-behavior": "<span style=\"color: gray\"><em>error</em></span>",
  "array-to-list<br-/>": "(vector-&gt;list #(1 2 3))",
  "list-to-array<br-/>": "(list-&gt;vector '(1 2 3))",
  "reverse": "",
  "sort": "",
  "map": "",
  "filter": "",
  "reduce": ""
},
"dict": {
  "dict-literal": "<span style=\"color: gray\">; immutable:</span><br />#hash((\"t\" . 1) (\"f\" . 0))",
  "dict-ctor": "(define ih<br /><span style=\"white-space: pre-wrap;\">  </span>(make-immutable-hash<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>'((\"t\" . 1) (\"f\" . 0))))<br /><br /><span style=\"color: gray\">; mutable:</span><br />(define h (make-hash '((\"t\" . 1) (\"f\" . 0))))",
  "dict-pred": "(hash? h)<br /><br /><span style=\"color: gray\">; also true of assoc. lists and vectors:</span><br />(dict? h)",
  "dict-size": "(hash-count h)<br /><br /><span style=\"color: gray\">; also works with assoc lists and vectors:</span><br />(dict-count ih)",
  "dict-lookup": "(hash-ref h \"t\")<br /><br /><span style=\"color: gray\">; return -1 if not found:</span><br />(hash-ref h \"m\" -1)<br /><br /><span style=\"color: gray\">; also works with assoc. lists and vectors:</span><br />(dict-ref ih \"t\")<br />(dict-ref ih \"m\" -1)",
  "dict-update": "(hash-set! h \"t\" 2)<br /><br />(define ih2 (hash-set ih \"t\" 2))<br /><br /><span style=\"color: gray\">; also dict-set! and dict-set</span>",
  "dict-missing-key": "<span style=\"color: gray\"><em>error</em></span>",
  "dict-is-key-present": "(hash-has-key? h \"t\")<br /><br /><span style=\"color: gray\">; also dict-has-key?</span>",
  "dict-dele": "(hash-remove! h \"t\")<br /><span style=\"white-space: pre-wrap;\"> </span><br />(define ih2<br /><span style=\"white-space: pre-wrap;\">  </span>(hash-remove ih \"t\"))<br /><br /><span style=\"color: gray\">; also dict-remove! and dict-remove</span>",
  "dict-merge": "",
  "dict-invert": "",
  "dict-iter": "(hash-for-each h<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (k v)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(printf \"~a~n\" k)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(printf \"~a~n\" v)))<br /><br /><span style=\"color: gray\">; also dict-for-each</span>",
  "dict-key-val-lists": "(hash-keys h)<br />(hash-values h)<br /><br /><span style=\"color: gray\">; also dict-keys and dict-values</span>"
},
"user-defined-types": {
  "defstruct": "(define-struct account (id (balance #:mutable)))",
  "struct": "(define a (make-account 3 17.12))",
  "struct-getter<br-/>": "(account-id a)",
  "struct-setter<br-/>": "(set-account-balance! a 0)",
  "struct-predicate<br-/>": "(account? a)"
},
"func": {
  "define-function<br-/>": "(define (add x y) (+ x y))",
  "can-function-and-variable-share-name": "<span style=\"color: gray\"><em>no</em></span>",
  "optional-argument": "(define (add a (b null))<br /><span style=\"white-space: pre-wrap;\">  </span>(if (null? b) a (+ a b)))",
  "variable-number-of-arguments": "(define (add a . b)<br /><span style=\"white-space: pre-wrap;\">  </span>(if (null? b)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(+ a (apply + b))))",
  "default-value": "<span style=\"color: gray\"><em>racket:</em></span><br />(define (add a (b 0)) (+ a b))",
  "named-parameter": "<span style=\"color: gray\"><em>none</em></span>",
  "return-multiple-values": "(define (sqrts x)<br /><span style=\"white-space: pre-wrap;\">  </span>(values (sqrt x) (- (sqrt x))))",
  "assign-multiple-values-to-local-variables": "(let-values<br /><span style=\"white-space: pre-wrap;\">  </span>(((r1 r2) (sqrts 3)))<br /><span style=\"white-space: pre-wrap;\">  </span>r2)",
  "assign-multiple-values-to-global-variables": "(define-values (r1 r2) (sqrts 3))",
  "convert-list-to-multiple-values": "(apply values '(1 2 3))",
  "assign-multiple-values-to-list": "(call-with-values<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda () (sqrts 3))<br /><span style=\"white-space: pre-wrap;\">  </span>list)",
  "tail-call-optimization": "<span style=\"color: gray\"><em>yes</em></span>",
  "lambda": "(lambda (x) (* x x))",
  "apply": "((lambda (x) (* x x)) 2)<br /><span style=\"white-space: pre-wrap;\"> </span><br />(apply (lambda (x) (* x x)) '(2))"
},
"exec-control": {
  "progn<br-/>": "begin <span style=\"color: gray\"><em>none</em></span> <span style=\"color: gray\"><em>none</em></span><br /><span style=\"color: gray\"><em>r6rs:</em></span><br />begin begin0 <span style=\"color: gray\"><em>none</em></span>",
  "loop": "<span style=\"color: gray\"><em>none, use recursion</em></span>",
  "do": "<span style=\"color: gray\"><em>none</em></span>",
  "dotimes": "<span style=\"color: gray\"><em>none</em></span>",
  "if<br-/>": "(if (&lt; x 0) (- x) x)",
  "when": "<span style=\"color: gray\"><em>racket:</em></span><br />(when (&lt; x y)<br /><span style=\"white-space: pre-wrap;\">  </span>(display \"x is less \")<br /><span style=\"white-space: pre-wrap;\">  </span>(display \"than y\"))",
  "cond": "(cond ((&gt; x 0) 1)<br /><span style=\"white-space: pre-wrap;\">  </span>((= x 0) 0)<br /><span style=\"white-space: pre-wrap;\">  </span>(else -1))",
  "lazy-evaluation": "(define x (delay (/ 1 0)))<br />(promise? x)<br />(+ 1 (force x))",
  "continuations": "(define cc null)<br />(+ 1 (call/cc (lambda (x) (set! cc x) 0)))<br />(cc 5)"
},
"exceptions": {
  "error<br-/>": "(error \"failed\")",
  "handle-error": "(with-handlers<br /><span style=\"white-space: pre-wrap;\">  </span>((exn:fail?<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">   </span>(lambda (e)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">   </span>(printf \"error: ~a\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">   </span>(exn-message e)))))<br /><span style=\"white-space: pre-wrap;\">  </span>(error \"failed\"))",
  "define-exception": "(define exn:odd-err? \"odd number\")",
  "throw-exception": "(raise exn:odd-err?)",
  "catch-exception": "(with-handlers ((exn:fail? (lambda (e) (begin (printf \"division by zero~n\") null)))) (/ 1 0))",
  "restart-case": "",
  "invoke-restart": "",
  "finally-clause": "<span style=\"color: gray\"><em>none</em></span>"
},
"streams": {
  "std-file-handles": "(current-input-port)<br />(current-output-port)<br />(current-error-port)",
  "eof": "<span style=\"color: gray\"><em>Returns the value</em> eof.<br /><br /><em>Use</em> eof-object? <em>to test for it.</em></span>",
  "read-stdin": "(let ((s (read-line)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">#|use s<span style=\"white-space: pre-wrap;\">|#</span></span>)",
  "chomp": "<span style=\"color: gray\">read-line <em>discards newline</em></span>",
  "println": "(write-string s)<br />(newline)",
  "format-stdout": "(printf \"~a ~a: ~a~n\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"foo\"<br /><span style=\"white-space: pre-wrap;\">  </span>7<br /><span style=\"white-space: pre-wrap;\">  </span>(/ (round (* 13.7 100)) 100))",
  "open-file": "(let<br /><span style=\"white-space: pre-wrap;\">  </span>((f (open-input-file \"/etc/hosts\")))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">#| use f <span style=\"white-space: pre-wrap;\">|#</span></span>)",
  "open-file-write": "(let<br /><span style=\"white-space: pre-wrap;\">  </span>((f (open-output-file<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/foo\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>#:exists 'truncate)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">#| use f <span style=\"white-space: pre-wrap;\">|#</span></span>)",
  "open-file-append": "(let<br /><span style=\"white-space: pre-wrap;\">  </span>((f (open-output-file<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/foo\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>#:exists 'append)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">#| use f <span style=\"white-space: pre-wrap;\">|#</span></span>)",
  "close-file": "(close-input-port f)<br />(close-output-port f)",
  "close-file-implicitly": "(call-with-input-file<br /><span style=\"white-space: pre-wrap;\">  </span>\"/etc/hosts\"<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (f) (<span style=\"color: gray\">#| use f <span style=\"white-space: pre-wrap;\">|#</span></span>))<br /><br /><span style=\"color: gray\">; also call-with-output-file</span>",
  "read-line": "(define line (read-line in))",
  "iterate-file": "(for ([line (in-lines<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(open-input-file<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"/etc/hosts\"))])<br /><span style=\"white-space: pre-wrap;\">  </span>(write-string line)<br /><span style=\"white-space: pre-wrap;\">  </span>(newline))",
  "read-file-array": "<span style=\"color: gray\">; to list of strings:</span><br />(sequence-&gt;list (in-lines<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(open-input-file \"/etc/hosts\")))",
  "read-file-str": "(define s (file-&gt;string \"/etc/hosts\"))",
  "write-str": "(write-string s f)",
  "write-line": "(write-string s f)<br />(newline f)",
  "flush-file": "(flush-output f)",
  "seek": "<span style=\"color: gray\">; Evaluates to non-negative integer:</span><br />(file-position f)<br /><br /><span style=\"color: gray\">; Sets next read or write<br />; to beginning of file:</span><br />(file-position f 0)",
  "in-memory-stream": "(define f (open-input-string \"lorem ipsum\"))<br />(read-line f)<br /><br />(define f2 (open-output-string))<br />(write-string \"lorem ipsum\" f2)<br />(get-output-string f2)"
},
"emacs-buffers": {
  "list-buffers": "",
  "current-buffer": "",
  "clear-buffer": "",
  "point": "",
  "search-and-set-point": "",
  "insert-at-string-point": "",
  "current-buffer-as-string": "",
  "insert-file-contents-at-point": "",
  "mark": ""
},
"file": {
  "file-test": "<span style=\"color: gray\"><em>??</em></span><br />(file-exists? \"/etc/hosts\")",
  "file-size": "(file-size \"/etc/hosts\")",
  "file-readable-writable-executable": "(pair? (filter<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(lambda (x) (eq? x 'read))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(file-or-directory-permissions<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"/etc/hosts\")))<br />(pair? (filter<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(lambda (x) (eq? x 'write))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(file-or-directory-permissions<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"/etc/hosts\")))<br />(pair? (filter<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(lambda (x) (eq? x 'execute))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(file-or-directory-permissions<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"/etc/hosts\")))",
  "chmod": "(file-or-directory-permissions<br /><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/foo\"<br /><span style=\"white-space: pre-wrap;\">  </span>#o755)",
  "last-modification-time": "(file-or-directory-modify-seconds \"/tmp/foo\")",
  "cp-rm-mv": "(copy-file \"/tmp/foo\" \"/tmp/bar\")<br />(delete-file \"/tmp/foo\")<br />(rename-file-or-directory<br /><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/bar\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/foo\")",
  "symlink": "(make-file-or-directory-link<br /><span style=\"white-space: pre-wrap;\">  </span>\"/etc/hosts\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/hosts\")<br />(link-exists? \"/tmp/hosts\")<br /><span style=\"color: gray\"><em>??</em></span>",
  "tmp-file": "(define tmp (make-temporary-file))<br />(path-&gt;string tmp)"
},
"dir": {
  "build-pathname": "<span style=\"color: gray\">; returns path; convert to string<br />; with path-&gt;string:</span><br />(build-path \"/etc\" \"hosts\")",
  "dirname-basename": "(let-values (((dir file _)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(split-path \"/etc/hosts\")))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">#| use dir or file <span style=\"white-space: pre-wrap;\">|#</span></span>)",
  "abs-pathname": "(simplify-path<br /><span style=\"white-space: pre-wrap;\">  </span>(path-&gt;complete-path \"..\"))",
  "iterate-dir": "(for ([path (directory-list \"/etc\")])<br /><span style=\"white-space: pre-wrap;\">  </span>(write-string<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(path-&gt;string path)))",
  "mkdir": "(make-directory* \"/tmp/foo/bar\")",
  "recursive-cp": "(copy-directory/files \"/tmp/foo.d\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/bar.d\")",
  "rmdir": "(delete-directory \"/tmp/foo.d\")",
  "rm-rf": "(delete-directory/files \"/tmp/foo.d\")",
  "dir-test": "(directory-exists? \"/etc\")"
},
"processes-environment": {
  "cmd-line-arg": "current-command-line-arguments",
  "program-name": "",
  "env-var": "(getenv \"HOME\")",
  "user-id-name": "",
  "exit": "",
  "external-cmd": "(require scheme/system)<br />(system \"ls /etc\")",
  "cmd-subst": ""
},
"lib-namespaces": {
  "complete-example": "",
  "compile-library": "$ raco make a.rkt",
  "load-library<br-/>": "(require a)",
  "load-library-in-subdirectory": "(require \"b/a.rkt\")",
  "hot-patch": "<span style=\"color: gray\"><em>none</em></span>",
  "load-error": "<span style=\"color: gray\"><em>raises</em> exn:fail:syntax:missing-module. <em>Because</em> require <em>must be top-level, the exception cannot be handled.</em></span>",
  "library-path": "(require setup/dirs)<br /><br />(get-collects-search-dirs)",
  "library-path-environment-variable": "",
  "library-path-command-line-option": "",
  "namespace-declaration": "(module mconst racket<br /><span style=\"white-space: pre-wrap;\">  </span>(provide pi)<br /><span style=\"white-space: pre-wrap;\">  </span>(define pi 3.14))",
  "subnamespace-declaration": "",
  "namespace-separator": ":",
  "import-definitions": "",
  "import-all-definitions-in-namespace": "",
  "namespace-shadow-avoidance": "",
  "identifier-shadow-avoidance": "",
  "package-manager-help": "$ raco help<br />$ raco pkg <span style=\"white-space: pre-wrap;\">--</span>help<br />$ raco pkg install <span style=\"white-space: pre-wrap;\">--</span>help",
  "list-installed-packages": "$ raco pkg show <span style=\"white-space: pre-wrap;\">--</span>all",
  "search-packages": "<a href=\"http://pkgs.racket-lang.org\">http://pkgs.racket-lang.org</a>",
  "install-package": "$ raco pkg install <span style=\"white-space: pre-wrap;\">--</span>deps search-auto srfi",
  "remove-package": "$ raco pkg remove srfi"
},
"objects": {
  "define-class": "(define rectangle%<br /><span style=\"white-space: pre-wrap;\">  </span>(class object%<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(init width)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(init height)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(super-new)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(define curr-height height)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(define curr-width width)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(define/public (get-height)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>curr-height)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(define/public (get-width)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>curr-width)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(define/public (set-height ht)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(set! curr-height ht))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(define/public (set-width wd)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(set! curr-width wd))))",
  "make-instance": "(define rect<br /><span style=\"white-space: pre-wrap;\">  </span>(new rectangle<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(height 7)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(width 3)))",
  "read-attribute<br-/>": "(send rect get-height)",
  "write-attribute<br-/>": "(send rect set-height 4)",
  "define-method": "(define/public (area)<br /><span style=\"white-space: pre-wrap;\">  </span>(* curr-height curr-width))",
  "invoke-method<br-/>": "(send rect area)",
  "universal-superclass": "object%",
  "multiple-inheritance": "no"
},
"lisp-macros": {
  "backquote-and-comma": "(define op '+)<br />(eval <span style=\"white-space: pre-wrap;\">`</span>(,op 1 1))<br />(eval (quasiquote ((unquote op) 1 1)))",
  "defmacro": "(define-syntax-rule (rpn arg1 arg2 op) (op arg1 arg2))",
  "defmacro-w/-backquote": "(define-syntax-rule (rpn3 arg1 arg2 op)<br /><span style=\"white-space: pre-wrap;\">  </span>(eval ‘(,op ,arg1 ,arg2)))",
  "macro-predicate": "<span style=\"color: gray\"><em>none</em></span>",
  "macroexpand": "(syntax-object-&gt;datum (expand-to-top-form '(rpn 1 2 +)))",
  "splice-quote": "(define-syntax-rule ( add first …) (+ first …))",
  "recursive-macro": "(define-syntax add (syntax-rules ()<br /><span style=\"white-space: pre-wrap;\">  </span>[(add x) x]<br /><span style=\"white-space: pre-wrap;\">  </span>[(add x y) (+ x y)]<br /><span style=\"white-space: pre-wrap;\">  </span>[(add x y …) (+ x (add y …))]))",
  "hygienic<br-/>": "<span style=\"color: gray\"><em>yes</em></span>",
  "local-values": "(define-syntax-rule (square-sum x y)<br /><span style=\"white-space: pre-wrap;\">  </span>(let ((sum (+ x y)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(* sum sum)))"
},
"reflection": {
  "inspect-type<br-/>": "(list? '(1 2 3))",
  "instance-of": "",
  "basic-types": "",
  "sequence-data-types": "list vector hash-table string input-port range",
  "docstring": "<span style=\"color: gray\"><em>none</em></span>",
  "define-docstring": "<span style=\"color: gray\"><em>none</em></span>",
  "search-doc": "<span style=\"color: gray\"><em>none</em></span>"
},
"java-interop": {
  "new": "",
  "method": "",
  "class-method<br-/>": "",
  "chain<br-/>": "",
  "import": "",
  "to-java-array": ""
}
}
