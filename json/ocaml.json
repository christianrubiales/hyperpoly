{
"version": {
  "version-used": "<span style=\"color: gray\"><em>4.0</em></span>",
  "version": "$ ocaml -version"
},
"grammar-execution": {
  "interpreter": "$ echo 'print_endline \"hello\"' &gt; hello.ml<br /><br />$ ocaml hello.ml",
  "shebang": "$ cat <span style=\"white-space: pre-wrap;\">&lt;&lt;</span>EOF &gt; hello.ml<br />#!/usr/bin/env ocaml<br /><br />print_endline \"hello\";;<br />EOF<br /><br />$ chmod +x hello.ml<br />$ ./hello.ml",
  "bytecode-compiler-interpreter": "$ echo 'print_endline \"hello\";;' &gt; hello.ml<br />$ ocamlc -o hello hello.ml<br />$ ocamlrun hello",
  "native-compiler": "$ echo 'print_endline \"hello\";;' &gt; hello.ml<br />$ ocamlopt hello.ml -o hello<br />$ ./hello",
  "library-always-imported": "Pervasives",
  "statement-terminator": ";;",
  "blocks": "( <span style=\"color: gray\"><em>expr</em></span> ; <span style=\"color: gray\"><em>…</em></span> )<br />begin <span style=\"color: gray\"><em>expr</em></span> ; <span style=\"color: gray\"><em>…</em></span> end",
  "end-of-line-comment": "<span style=\"color: gray\"><em>none</em></span>",
  "multiple-line-comment": "(* <span style=\"color: gray\"><em>comment<br />another comment</em></span> *)"
},
"var-expr": {
  "value": "let n = 1 + 2;;",
  "variable": "let n = ref 3;;<br />n := 4;;<br />!n + 7;;",
  "unit": "unit<br />()",
  "conditional-expression": "let n = -3;;<br />let absn = if n &lt; 0 then -n else n;;",
  "branch-type-mismatch": "<span style=\"color: gray\">(* compilation error: *)</span><br />if true then \"hello\" else 3;;",
  "null": "None",
  "nullable-type": "type list_option_int = int option list;;<br /><br />let list = [Some 3; None; Some (-4)];;",
  "null-test": "match foo with<br /><span style=\"white-space: pre-wrap;\">  </span>| None -&gt; true<br /><span style=\"white-space: pre-wrap;\">  </span>| _ -&gt; false;;",
  "coalesce": "match foo with<br /><span style=\"white-space: pre-wrap;\">  </span>| None -&gt; 0<br /><span style=\"white-space: pre-wrap;\">  </span>| Some n -&gt; n;;",
  "nullif": "match foo with<br /><span style=\"white-space: pre-wrap;\">  </span>| -999 -&gt; None<br /><span style=\"white-space: pre-wrap;\">  </span>| n -&gt; Some n;;",
  "expr-type-declaration": "float 1",
  "let-in": "let z =<br /><span style=\"white-space: pre-wrap;\">  </span>let x = 3.0 in<br /><span style=\"white-space: pre-wrap;\">  </span>let y = 2.0 *. x in<br /><span style=\"white-space: pre-wrap;\">  </span>x *. y;;",
  "where": "<span style=\"color: gray\"><em>none</em></span>"
},
"arithmetic-logic": {
  "boolean-type": "bool",
  "true-false": "true false",
  "logical-op": "&amp;&amp; <span style=\"white-space: pre-wrap;\">||</span> not",
  "relational-op": "<span style=\"white-space: pre-wrap;\">=</span> &lt;&gt; &lt; &gt; &lt;= &gt;=",
  "min-max": "min 1 2<br />max 1 2",
  "int-type": "int<br /><br /><span style=\"color: gray\"><em>other integer types:</em></span><br />int32 int64 nativeint",
  "int-literal": "<span style=\"color: gray\">int, int64, and nativeint literals:</span><br />12 12L 12n<br /><br />literals can contain underscores:<br />1_000_000<br /><br />this parses as an expression:<br />-4",
  "float-type": "float",
  "int-op": "+ - * / mod<br /><span style=\"color: gray\">mod //is an infix operator</span>",
  "float-op": "+. -. *. /.",
  "add-int-float": "float 3 +. 7.0",
  "int-div": "7 / 3<br />7 mod 3",
  "int-div-zero": "<span style=\"color: gray\"><em>raises</em></span> Division_by_zero",
  "float-div": "float 7 /. float 3",
  "float-div-zero": "infinity nan <span style=\"color: gray\"><em>or</em></span> neg_infinity",
  "power": "2.0 ** 32.0",
  "sqrt": "sqrt 2.0",
  "sqrt-negative-one": "<span style=\"color: gray\">sqrt (-1.0):</span><br />nan",
  "transcendental-func": "exp log<br />sin cos tan<br />asin acos atan<br />atan2",
  "transcendental-const": "4.0 *. atan 1.0<br />exp 1.0",
  "float-truncation": "truncate 3.14<br /><span style=\"color: gray\"><em>none</em></span><br />floor 3.14 <span style=\"color: gray\"><em>returns float</em></span><br />ceil 3.14 <span style=\"color: gray\"><em>returns float</em></span>",
  "abs-val": "abs (-7)<br />abs_float (-7.0)<br /><span style=\"color: gray\"><em>no signum</em></span>",
  "int-overflow": "<span style=\"color: gray\"><em>modular arithmetic</em></span>",
  "float-overflow": "infinity",
  "arbitrary-len-int": "open Big_int;;<br /><br />let n = big_int_of_int 7;;<br />let m = big_int_of_int 12;;",
  "arbitrary-len-int-op": "add_big_int n m<br />sub_big_int n m<br />mult_big_int n m<br />div_big_int n m <span style=\"color: gray\">(* quotient *)</span><br />mod_big_int n m<br /><br />eq_big_int n m<br />lt_big_int n m<br />gt_big_int n m<br />le_big_int n m<br />ge_big_int n m",
  "rational-type": "",
  "rational-construction": "",
  "rational-decomposition": "",
  "complex-type": "Complex.t",
  "complex-const": "Complex.zero<br />Complex.one<br />Complex.i",
  "complex-op": "Complex.add z w;;<br />Complex.sub z w;;<br />Complex.mul z w;;<br />Complex.div z w;;",
  "complex-construction": "{Complex.re=1.0; Complex.im=2.0}",
  "complex-decomposition": "let z = {Complex.re=1.0; Complex.im=2.0};;<br /><br />z.Complex.re;;<br />z.Complex.im;;<br />Complex.arg z;;<br />Complex.norm z;;<br />Complex.conj z;;",
  "random-num": "Random.int 100<br />Random.float 1.0<br /><span style=\"color: gray\"><em>none</em></span>",
  "random-seed": "Random.init 17;;<br />let seed = Random.get_state();;<br />Random.set_state seed;;",
  "bit-op": "1 lsl 4<br />1 lsr 4<br />1 land 3<br />1 lor 3<br />1 lxor 3<br />lnot 1",
  "binary-octal-hex-literals": "0b101010<br />0o52<br />0x2a",
  "radix": ""
},
"str": {
  "str-type": "string",
  "str-literal": "\"Hello, World!\"",
  "newline-in-str-literal": "<span style=\"color: gray\"><em>no</em></span>",
  "str-esc": "\\b \\n \\r \\t \\\" \\' \\\\<br />\\<span style=\"color: gray\"><em>ooo</em></span> \\x<span style=\"color: gray\"><em>hh</em></span>",
  "format-str": "",
  "str-concat": "\"Hello\" ^ \", \" ^ \"World!\"",
  "str-replicate": "String.make 80 '-'",
  "translate-case": "String.uppercase \"hello\"<br />String.lowercase \"HELLO\"",
  "capitalize": "String.capitalize \"hello\"",
  "trim": "String.trim \" hello \"",
  "pad": "",
  "num-to-str": "\"two: \" ^ string_of_int 2<br />\"pi: \" ^ float_of_string 3.14",
  "str-to-num": "7 + int_of_string \"12\"<br />73.9 +. float_of_string \".037\"",
  "join": "",
  "split": "",
  "char-type": "char",
  "char-literal": "'h'",
  "str-len": "String.length \"hello\"",
  "index-substr": "",
  "substr": "String.sub \"hello\" 0 4",
  "extract-char": "\"hello\".[0]",
  "chr-ord": "Char.code 'a'<br />Char.chr 97"
},
"dates-time": {
  "dates-time-types": "",
  "current-date-time": "",
  "current-unix-epoch": "open Unix;;<br /><br /><span style=\"color: gray\">(* float: *)</span><br />time();;"
},
"arrays": {
  "literal": "",
  "size": "",
  "lookup": "",
  "update": "",
  "out-of-bounds": ""
},
"lists": {
  "list-literal": "[1; 2; 3]",
  "empty-list": "[]",
  "empty-list-test": "let list = [1; 2; 3];;<br /><br />list == []",
  "cons": "1 :: [2; 3]",
  "head": "List.hd [1; 2; 3]",
  "tail": "List.tl [1; 2; 3]",
  "head-tail-empty-list": "<span style=\"color: gray\"><em>exceptions</em></span>",
  "list-length": "List.length [1; 2; 3]",
  "nth-elem-of-list": "List.nth [1; 2; 3] 0",
  "list-elem-index": "",
  "update-list": "",
  "concat-list": "[1; 2] @ [3; 4]<br />List.append [1; 2] [3; 4]<br /><br />List.concat [[1; 2]; [3; 4]]",
  "list-last": "",
  "list-take": "",
  "list-drop": "",
  "iterate-over-list": "let f i =<br /><span style=\"white-space: pre-wrap;\">  </span>print_endline (string_of_int i);;<br /><br />List.iter f [1; 2; 3];;",
  "reverse-list": "List.rev [1; 2; 3]",
  "sort-list": "List.sort min [1; 3; 2; 4]<br />List.sort max [1; 3; 2; 4]",
  "map-list": "List.map (( * ) 2) [1; 2; 3]",
  "filter-list": "List.filter ((&lt;) 2) [1; 2; 3]",
  "fold-list-left": "List.fold_left (+) 0 [1; 2; 3]",
  "fold-list-right": "List.fold_right (-) [1; 2; 3] 0",
  "list-member": "List.mem 3 [1; 2; 3]",
  "universal-test-list": "List.for_all (fun x -&gt; x &gt; 2) [1; 2; 3];;",
  "existential-test-list": "List.exists (fun x -&gt; x &gt; 2) [1; 2; 3];;",
  "zip-list": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">(*</span> list of tuples *)</span><br />List.combine [1; 2; 3] ['a'; 'b'; 'c']<br />"
},
"tuples": {
  "tuple-literal": "(1, \"hello\", true)",
  "tuple-lookup": "match (1, \"hello\", true) with _, x, _ -&gt; x",
  "pair-lookup": "fst (12, \"December\")<br />snd (12, \"December\")"
},
"dict": {
},
"func": {
  "def-func": "let average a b = ( a +. b ) /. 2.0;;",
  "invoke-func": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">(*</span> 4.5: *)</span><br />average 1.0 2.0 +. 3.0;;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">(*</span> 3.0: *)</span><br />average 1.0 (2.0 +. 3.0);;",
  "named-parameter": "let subtract ~m ~s = m - s;;<br /><br />subtract ~s: 3 ~m: 7;;",
  "named-parameter-default-value": "let logarithm ?(base = (exp 1.0)) x = log x /. (log base);;<br /><br />logarithm 2.718;;<br />logarithm ~base: 2.0 10.0;;",
  "piecewise-defined-function": "let to_s = function Red -&gt; \"red\"<br /><span style=\"white-space: pre-wrap;\">  </span>| Green -&gt; \"green\"<br /><span style=\"white-space: pre-wrap;\">  </span>| Blue -&gt; \"blue\";;",
  "recursive-function": "let rec range a b =<br />if a &gt; b then []<br />else a :: range (a+1) b;;",
  "mutually-recursive-functions": "let rec even n = if n = 0 then true else odd (n-1)<br />and odd n = if n = 0 then false else even (n-1);;",
  "anonymous-function": "fun x -&gt; fun y -&gt; (x +. y) /. 2.0",
  "infix-operator-in-prefix-position": "( * ) 3 4;;",
  "function-in-infix-position": "<span style=\"color: gray\"><em>none</em></span>",
  "currying": "let plus2 = (+) 2;;",
  "composition": "",
  "function-composition-operator": "<span style=\"color: gray\"><em>none</em></span>",
  "lazy-evaluation": "let arg1 x y = x;;<br /><br />arg1 7 (lazy (1/0) );;",
  "strict-evaluation": "<span style=\"color: gray\"><em>default behavior</em></span>"
},
"exec-control": {
  "if": "if x &gt; 0 then<br /><span style=\"white-space: pre-wrap;\">  </span>print_endline \"pos\";;",
  "if-else-if-else": "if x &gt; 0 then<br /><span style=\"white-space: pre-wrap;\">  </span>print_endline \"pos\"<br />else<br /><span style=\"white-space: pre-wrap;\">  </span>if x &lt; 0 then<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>print_endline \"neg\"<br /><span style=\"white-space: pre-wrap;\">  </span>else<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>print_endline \"zero\";;",
  "sequencing": "print_endline \"one\";<br />print_endline \"two\";<br />print_endline \"three\";;",
  "while": "let i = ref 0;;<br /><br />while !i &lt; 10 do<br /><span style=\"white-space: pre-wrap;\">  </span>print_endline (string_of_int !i);<br /><span style=\"white-space: pre-wrap;\">  </span>i := !i + 1<br />done;;",
  "for": "for i = 1 to 10 do<br /><span style=\"white-space: pre-wrap;\">  </span>let s = string_of_int i in<br /><span style=\"white-space: pre-wrap;\">  </span>print_endline s<br />done;;",
  "for-in-reverse": "for i = 10 downto 1 do<br /><span style=\"white-space: pre-wrap;\">  </span>let s = string_of_int i in<br /><span style=\"white-space: pre-wrap;\">  </span>print_endline s<br />done;;",
  "list-iteration": "<span style=\"color: gray\"><em>none</em></span>",
  "loop": "let rec loop i =<br /><span style=\"white-space: pre-wrap;\">  </span>if i &lt;= 10 then begin<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>print_endline (string_of_int i);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>loop (i+1)<br /><span style=\"white-space: pre-wrap;\">  </span>end in<br />loop 0;;"
},
"exceptions": {
  "raise-error": "raise (Failure \"bam!\");;<br /><span style=\"color: gray\"><em>or</em></span><br />failwith \"bam!\";;",
  "handle-error": "let x = try 1 / 0 with Division_by_zero -&gt; 0;;",
  "type-of-exceptions": "exn",
  "user-defined-exception": "exception Foo of string;;<br />raise (Foo \"invalid input\");;",
  "standard-exceptions": "Division_by_zero<br />Failure <span style=\"color: gray\"><em>string</em></span><br />Not_found<br />Invalid_argument <span style=\"color: gray\"><em>string</em></span><br />Match_failure (<span style=\"color: gray\"><em>string</em></span>, <span style=\"color: gray\"><em>int</em></span>, <span style=\"color: gray\"><em>int</em></span>)<br />Assert_failure (<span style=\"color: gray\"><em>string</em></span>, <span style=\"color: gray\"><em>int</em></span>, <span style=\"color: gray\"><em>int</em></span>)<br />Out_of_memory<br />Stack_overflow",
  "assert": "assert(1 = 0);;"
},
"concurrency": {
},
"file-handles": {
  "standard-file-handles": "stdin stdout stderr",
  "read-line-from-stdin": "let line = read_line();;",
  "end-of-file-behavior": "<span style=\"color: gray\"><em>raises</em> End_of_file</span>",
  "chomp": "",
  "write-line-to-stdout": "print_endline \"lorem ipsum\";;",
  "write-formatted-string-to-stdout": "",
  "open-file-for-reading": "let f = open_in \"/etc/passwd\";;",
  "open-file-for-writing": "let f = open_out \"/tmp/ocaml.out\";;",
  "open-file-for-appending": "",
  "close-file": "",
  "i/o-errors": "",
  "read-line": "let ic = open_in \"/etc/passwd\" in<br />let line = input_line ic in<br />print_endline line;;",
  "iterate-over-file-by-line": "",
  "read-file-into-array-of-strings": "",
  "read-file-into-string": "",
  "write-string": "",
  "write-line": "open Printf<br />let oc = open_out \"/tmp/test-ocaml\" in<br />fprintf oc \"hello out\\n\";<br />close_out oc;;",
  "flush-file-handle": "",
  "end-of-file-test": "",
  "get-and-set-filehandle-position": ""
},
"file": {
  "file-test,-regular-file-test": "open Unix<br /><br />try Some (stat \"/etc/hosts\") with<br /><span style=\"white-space: pre-wrap;\">  </span>Unix_error (ENOENT, _, _) -&gt; None<br /><br />(stat \"/etc/hosts\").st_kind = S_REG",
  "file-size": "(stat \"/etc/hosts\").st_size",
  "is-file-readable,-writable,-executable": "open Unix<br /><br />try access \"/tmp/bar\" [R_OK]; true with<br /><span style=\"white-space: pre-wrap;\">  </span>Unix.Unix_error (EACCES, _, _) -&gt; false;;<br />try access \"/tmp/bar\" [W_OK]; true with<br /><span style=\"white-space: pre-wrap;\">  </span>Unix.Unix_error (EACCES, _, _) -&gt; false;;<br />try access \"/tmp/bar\" [X_OK]; true with<br /><span style=\"white-space: pre-wrap;\">  </span>Unix.Unix_error (EACCES, _, _) -&gt; false;;",
  "set-file-permissions": "open Unix<br /><br />chmod \"/tmp/foo\" 0o755",
  "copy-file,-remove-file,-rename-file": "open Unix<br /><br /><span style=\"color: gray\"><em>??</em></span><br />unlink \"/tmp/foo\"<br />rename \"/tmp/bar\" \"/tmp/foo\"",
  "create-symlink,-symlink-test,-readlink": "open Unix<br /><br />symlink \"/etc/hosts\" \"/tmp/hosts\"<br />(lstat \"/tmp/hosts\").st_kind = S_LNK<br />readlink \"/tmp/hosts\"",
  "generate-unused-file-name": "open Filename<br /><br /><span style=\"color: gray\">(* prefix and suffix: *)</span><br />temp_file \"foo\" \".txt\""
},
"dir": {
  "build-pathname": "open Filename<br /><br />concat \"/etc\" \"hosts\"",
  "dirname-and-basename": "open Filename<br /><br />dirname \"/etc/hosts\"<br />basename \"/etc/hosts\"",
  "iterate-over-directory-by-file": "",
  "make-directory": "<span style=\"color: gray\">(* opam install fileutils *)</span><br />open FileUtil<br /><br />mkdir ~parent:true \"/tmp/foo/bar\"",
  "remove-empty-directory": "open Unix<br /><br />rmdir \"/tmp/foodir\"",
  "remove-directory-and-contents": "",
  "directory-test": "",
  "temporary-directory": ""
},
"processes-environment": {
  "command-line-arguments": "for i = 0 to Array.length Sys.argv - 1 do<br /><span style=\"white-space: pre-wrap;\">  </span>print_endline i Sys.argv.(i)<br />done",
  "program-name": "",
  "getopt": "",
  "env-var": "open Unix<br /><br />s = getenv \"HOME\"<br />putenv \"PATH\" \"/bin\"",
  "pid": "open Unix<br /><br />let pid = getpid()<br />let ppid = getppid()",
  "user-id-name": "let uid = getuid()<br />let username =<br /><span style=\"white-space: pre-wrap;\">  </span>(getpwuid (getuid())).pw_name",
  "exit": "exit 0<br /><br />exit 1",
  "signal-handler": "",
  "external-cmd": "",
  "escaped-external-cmd": "",
  "backticks": ""
},
"lib-namespaces": {
  "namespace-example": "",
  "namespaces": "",
  "file-name-restrictions": "<span style=\"color: gray\"><em>module</em> Foo.Bar <em>must be in</em> Foo.ml</span>",
  "namespace": "open Graphics;;",
  "namespace-creation": "<span style=\"color: gray\"><em>put code in file</em> MODULE_NAME<em>.ml</em></span>",
  "namespace-alias": "module Gr = Graphics;;",
  "namespace-separator": ".",
  "subnamespace": "<span style=\"color: gray\"><em>in A.ml:</em></span><br />module B =<br />sig<br /><span style=\"white-space: pre-wrap;\">  </span>val display_instruction : unit -&gt; unit<br />end =<br />struct<br /><span style=\"white-space: pre-wrap;\">  </span>let msg = \"attack\"<br /><span style=\"white-space: pre-wrap;\">  </span>let display_instruction () = print_endline msg<br />end<br /><span style=\"color: gray\"><em>in client source:</em></span><br />A.B.display_instruction;;",
  "pkg-manager-setup": "<span style=\"color: gray\"><em>do this once:</em></span><br />$ opam init<br /><br /><span style=\"color: gray\"><em>for each shell session:</em></span><br />$ eval $(opam config env)",
  "pkg-manager": "$ opam search utop<br />$ opam install utop<br />$ opam list <span style=\"white-space: pre-wrap;\">--</span>installed",
  "pkg-compile": ""
},
"user-defined-types": {
  "type-synonym": "type name = string;;",
  "sum-type": "type color = Red | Green | Blue;;<br /><br />let col = Red;;<br /><br /><span style=\"color: gray\">(* evaluates to true: *)</span><br />col &lt; Green;;",
  "tuple-product-type-with-one-field": "type special_int = SpecialInt of int;;<br /><br />let n = SpecialInt 7;;",
  "tuple-product-type-with-two-fields": "type int_pair = IntPair of int * int;;<br /><br />let p = IntPair (7, 11);;",
  "record-product-type": "type customer = {<br /><span style=\"white-space: pre-wrap;\">  </span>id: int;<br /><span style=\"white-space: pre-wrap;\">  </span>name: string;<br /><span style=\"white-space: pre-wrap;\">  </span>address: string<br />};;",
  "record-product-type-literal": "let cust = {<br /><span style=\"white-space: pre-wrap;\">  </span>id=7;<br /><span style=\"white-space: pre-wrap;\">  </span>name=\"John\";<br /><span style=\"white-space: pre-wrap;\">  </span>address=\"Topeka, KS\"<br />};;",
  "generic-type": "type ('a, 'b) twosome =<br /><span style=\"white-space: pre-wrap;\">  </span>Twosome of 'a * 'b;;<br /><br />let p = Twosome (\"pi\", 3.14);;",
  "recursive-type": "type binary_tree =<br /><span style=\"white-space: pre-wrap;\">  </span>| Leaf of int<br /><span style=\"white-space: pre-wrap;\">  </span>| Tree of binary_tree * binary_tree;;",
  "pattern-match-sum-type": "let col = Red;;<br /><br />let s = match col with<br /><span style=\"white-space: pre-wrap;\">  </span>| Red -&gt; \"red\"<br /><span style=\"white-space: pre-wrap;\">  </span>| Blue -&gt; \"blue\"<br /><span style=\"white-space: pre-wrap;\">  </span>| Green -&gt; \"green\";;",
  "pattern-match-product-type": "",
  "pattern-match-guard": "match i with j when i &lt; 0 -&gt; -j | j -&gt; j;;",
  "pattern-match-catchall": "let to_s c = match c with Red -&gt; \"red\" | _ -&gt; \"not red\";;<br />to_s Green;;"
},
"objects": {
  "class-definition": "class counter = object<br /><span style=\"white-space: pre-wrap;\">  </span>val mutable n = 0<br /><span style=\"white-space: pre-wrap;\">  </span>method incr = n &lt;- n+1<br /><span style=\"white-space: pre-wrap;\">  </span>method get = n<br />end;;",
  "object-creation": "let c = new counter;;",
  "method-invocation": "c#incr;;<br />c#get;;",
  "field-access": "<span style=\"color: gray\"><em>none</em></span>"
},
"inheritance-polymorphism": {
  "overload-function": "",
  "inheritance": ""
},
"net-web": {
},
"unit-tests": {
},
"debug-profile": {
},
"repl": {
  "invoke-repl": "$ ocaml<br /><br /><span style=\"color: gray\"><em>Use this if you want history:</em></span><br />$ rlwrap ocaml<br /><br /><span style=\"color: gray\"><em>The utop toplevel, which can be installed via opam, also provides history.</em></span>",
  "repl-limitations": "",
  "repl-last-value": "<span style=\"color: gray\"><em>none</em></span>",
  "help": "<span style=\"color: gray\"><em>none</em></span>",
  "quit": "^D",
  "inspect-type": "<span style=\"color: gray\"><em>repl displays the type of any expression entered</em></span>",
  "inspect-namespace": "module Unix = Unix;;",
  "load-source-file": "#use \"hello\";;",
  "load-package": "<span style=\"color: gray\"><em>consider adding to</em> .ocamlinit:</span><br />#use \"topfind\";;<br /># thread;;<br />#require \"core\";;<br />open Core.Std;;",
  "search-path": "#directory \"libdir\";;",
  "set-search-path-on-command-line": "ocaml -Ilibdir"
}
}
