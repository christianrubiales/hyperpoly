{

"version": {
  "version-used": "<span style=\"color: gray\"><em>C11</em>, <em>gcc 4.8</em>, <em>clang 3.5</em></span>",
  "show-version": "$ gcc <span style=\"white-space: pre-wrap;\">--</span>version",
  "implicit-prologue": "#include &lt;errno.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;time.h&gt;<br />#include &lt;wchar.h&gt;"
},
"grammar-execution": {
  "hello-world": "$ cat hello.c<br />#include &lt;stdio.h&gt;<br /><br />int main(int argc, char <span style=\"white-space: pre-wrap;\">**</span>argv) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"Hello, World!\\n\");<br />}<br /><br />$ gcc hello.c<br /><br />$ ./a.out<br />Hello, World!",
  "file-suffixes": ".c .h .o",
  "stmt-separator": ";",
  "block-delimiters": "{ <span style=\"color: gray\"><em>…</em></span> }",
  "eol-comment": "<span style=\"white-space: pre-wrap;\">//</span> <span style=\"color: gray\"><em>comment</em></span>",
  "multiple-line-comment": "/* <span style=\"color: gray\"><em>comment line</em></span><br /><span style=\"color: gray\"><em>another line</em></span> */"
},
"var-expr": {
  "local-var": "<span style=\"color: gray\">/* if inside function, memory allocated on stack: */</span><br />int i;<br />int j = 3;<br /><br /><span style=\"color: gray\">/* memory allocated on heap: */</span><br />int *ptr = malloc(sizeof *ptr);<br /><span style=\"color: gray\">/* if malloc fails, it returns NULL and sets errno to ENOMEM */</span><br />*ptr = 7;",
  "free-heap": "free(ptr);",
  "global-var": "<span style=\"color: gray\">/* in foo.c, outside of any function: */</span><br />int x = 7;<br /><br /><span style=\"color: gray\">/* to declare in bar.c: */</span><br />extern int x;",
  "uninitialized-var": "<span style=\"color: gray\"><em>The behavior of reading from uninitialized stack variables or unitialized memory allocated by</em> malloc <em>is undefined.<br /><br />Global and static variables are zero-initialized.<br /><br />Heap variables allocated by</em> calloc <em>have their bytes zeroed.</em></span>",
  "compile-time-const": "<span style=\"color: gray\">/* usually preprocessor is used: */</span><br />#define PI 3.14",
  "immutable-var": "const int i = rand();",
  "assignment": "i = 3;",
  "parallel-assignment": "<span style=\"color: gray\"><em>none</em></span>",
  "swap": "int x = 1, y = 2, tmp;<br /><br />tmp = x;<br />x = y;<br />y = tmp;",
  "compound-assignment": "<span style=\"color: gray\"><em>arithmetic:</em></span><br />+= -= *= /= %=<br /><br /><span style=\"color: gray\"><em>bit:</em></span><br /><span style=\"white-space: pre-wrap;\">&lt;&lt;= &gt;&gt;= &amp;= |= ^=</span>",
  "incr-decr": "<span style=\"color: gray\"><em>premodifiers:</em></span><br />++i <span style=\"white-space: pre-wrap;\">--</span>i<br /><br /><span style=\"color: gray\"><em>postmodifiers:</em></span><br />i++ i<span style=\"white-space: pre-wrap;\">--</span>",
  "addr": "int i = 3;<br />int* ptr = &amp;i;",
  "dereference": "int i2 = *ptr;",
  "type-size": "<span style=\"color: gray\">/* put type inside parens: */</span><br />sizeof (int)<br /><br /><span style=\"color: gray\">/* expressions and values don't require parens: */</span><br />sizeof 1 + 1",
  "addr-arith": "int a[] = {3, 2, 1, 0};<br /><br />for (int *p = a; *p; ++p) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"%d\\n\", *p);<br />}",
  "null": "<span style=\"color: gray\">/* pointer types only: */</span><br />NULL",
  "null-test": "ptr == NULL",
  "conditional-expr": "x &gt; 0 ? x : -x"
},
"arithmetic-logic": {
  "boolean-type": "int<br /><br /><span style=\"color: gray\">/* includes type for consistency with C++: */</span><br />#include &lt;stdbool.h&gt;<br /><br />bool",
  "true-false": "1 0<br /><br /><span style=\"color: gray\">/* includes identifiers for consistency with C++: */</span><br />#include &lt;stdbool.h&gt;<br /><br />true false",
  "falsehoods": "0 0.0 NULL false",
  "logical-op": "&amp;&amp; <span style=\"white-space: pre-wrap;\">||</span> !",
  "relational-op": "== != &lt; &gt; &lt;= &gt;=",
  "int-type": "signed char <span style=\"color: gray\"><em>1+ bytes</em></span><br />short int <span style=\"color: gray\"><em>2+ bytes</em></span><br />int <span style=\"color: gray\"><em>2+ bytes</em></span><br />long int <span style=\"color: gray\"><em>4+ bytes</em></span><br />long long int <span style=\"color: gray\"><em>4+ bytes</em></span><br /><br /><span style=\"color: gray\"><em>types with portable sizes are defined in</em> stdint.h:</span><br />int8_t int16_t int32_t int64_t",
  "unsigned-type": "unsigned char: <span style=\"color: gray\"><em>1+ bytes</em></span><br />unsigned short int <span style=\"color: gray\"><em>2 bytes+</em></span><br />unsigned int <span style=\"color: gray\"><em>2 bytes+</em></span><br />unsigned long int <span style=\"color: gray\"><em>4+ bytes</em></span><br />unsigned long long int <span style=\"color: gray\"><em>4+ bytes</em></span><br /><br /><span style=\"color: gray\"><em>types with portable sizes are defined in</em> stdint.h:</span><br />uint8_t uint16_t uint32_t uint64_t",
  "float-type": "float <span style=\"color: gray\"><em>4 bytes</em></span><br />double <span style=\"color: gray\"><em>8 bytes</em></span><br />long double <span style=\"color: gray\"><em>16 bytes</em></span><br /><br /><span style=\"color: gray\"><em>registers may be larger on some systems</em></span>",
  "arith-op": "<span style=\"white-space: pre-wrap;\">+</span> - * / %",
  "int-div": "3 / 7",
  "int-div-zero": "<span style=\"color: gray\"><em>system dependent; process often sent a</em> SIGFPE <em>signal</em></span>",
  "float-div": "3 / (float)7",
  "float-div-zero": "<span style=\"color: gray\">/* these are float values but not literals: */</span><br />inf, nan, or -inf",
  "power": "#include &lt;math.h&gt;<br /><br />pow(2.0, 3.0)",
  "sqrt": "#include &lt;math.h&gt;<br /><br />sqrt(2);",
  "sqrt-negative-one": "#include &lt;math.h&gt;<br /><br /><span style=\"color: gray\">/* nan */</span><br />double x = sqrt(-1.0);",
  "transcendental-func": "#include &lt;math.h&gt;<br /><br />exp log log2 log10<br />sin cos tan<br />asin acos atan<br />atan2",
  "transcendental-const": "#include &lt;math.h&gt;<br /><br />M_PI<br />M_E",
  "float-truncation": "#include &lt;math.h&gt;<br /><span style=\"white-space: pre-wrap;\"> </span><br />double d = 3.77;<br /><span style=\"white-space: pre-wrap;\"> </span><br />long trunc = (long)d;<br />long rnd = round(d);<br />long flr = floorl(d);<br />long cl = ceill(d);",
  "absolute-val": "#include &lt;math.h&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* fabs() */</span><br /><br />int i = abs(-7);<br />float x = fabs(-7.77);",
  "complex-type": "float complex <span style=\"color: gray\"><em>8 bytes</em></span><br />double complex <span style=\"color: gray\"><em>16 bytes</em></span><br />long double complex <span style=\"color: gray\"><em>32 bytes</em></span>",
  "complex-construction": "#include &lt;complex.h&gt;<br /><br />double complex z;<br />z = 1.0 + 2.0 * I;<br /><br /><span style=\"color: gray\">/* C11: */</span><br />double complex z = CMPLX(1.0, 2.0);",
  "complex-decomposition": "#include &lt;complex.h&gt;<br /><br />double x;<br />double complex w;<br /><br />x = creal(z);<br />x = cimag(z);<br />x = carg(z);<br />x = cabs(z);<br />w = conj(z);",
  "random-num": "<span style=\"color: gray\">/* lrand48 returns value in [0, 2**31 - 1]: */</span><br />long n = lrand48(() % 100;<br /><br /><span style=\"color: gray\">/* Value in interval [0.0, 1.0): */</span><br />double x = drand48();",
  "random-seed": "srand48(17);",
  "bit-op": "<span style=\"white-space: pre-wrap;\"> &lt;&lt; &gt;&gt; &amp; | ^ ~ </span>"
},
"str": {
  "str-type": "char *<br />wchar_t *<br /><br /><span style=\"color: gray\">wchar_t <em>is typically 32 bits on Linux and 16 bits on Windows.</em></span>",
  "str-literal": "<span style=\"color: gray\">/* string in initialized data segment: */</span><br />char *s = \"hello\";<br />wchar_t *ws = L\"hello\";<br /><br /><span style=\"color: gray\">/* string in heap: */</span><br />char *s2 = strdup(s);<br />wchar_t *ws2 = wcsdup(ws);<br /><br /><span style=\"color: gray\">/* if strdup cannot allocate memory, it returns NULL and sets<br /><span style=\"white-space: pre-wrap;\">   </span>errno to ENOMEM. */</span>",
  "newline-in-str-literal": "<span style=\"color: gray\">/* compiler concatenates literals<br /><span style=\"white-space: pre-wrap;\">   </span>separated by whitespace: */</span><br />char *s = \"first line\\n\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"second line\";",
  "str-literal-esc": "\\a \\b \\f \\n \\r \\t \\v \\\" \\' \\? \\\\<br />\\<span style=\"color: gray\"><em>o</em></span> \\<span style=\"color: gray\"><em>oo</em></span> \\<span style=\"color: gray\"><em>ooo</em></span> \\x<span style=\"color: gray\"><em>hh</em></span> \\u<span style=\"color: gray\"><em>hhhh</em></span> \\U<span style=\"color: gray\"><em>hhhhhhhh</em></span>",
  "expr-interpolation": "<span style=\"color: gray\"><em>none</em></span>",
  "compare-str": "<span style=\"color: gray\">/* == and &lt; compare memory addresses: */</span><br /><br />strcmp(\"hello\", \"world\") == 0<br />strcmp(\"hello\", \"world\") &lt; 0<br /><br />wcscmp(L\"hello\", L\"world\") == 0<br />wcscmp(L\"hello\", L\"world\") &lt; 0",
  "str-to-num": "<span style=\"color: gray\">/* conversion functions:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>strtol strtoll<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>strtoul strtoull<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>strtof strtod strtold */</span><br />#include &lt;limits.h&gt;<br /><br />char *s = \"101 dalmations\";<br />char *rest;<br />long n = strtol(s, &amp;rest, 10);<br /><br />if (n == 0 &amp;&amp; errno == EINVAL)<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"invalid input\\n\");<br />else if ((n == LONG_MAX <span style=\"white-space: pre-wrap;\">||</span> n == LONG_MIN) &amp;&amp; errno == ERANGE)<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"overflow\\n\");<br />else<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"%ld %s\\n\", n, rest);<br /><br /><span style=\"color: gray\">/* wide string conversion functions:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>wcstol wcstoll<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>wcstoul wcstoull<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>wcstof wcstod wcstold */</span>",
  "num-to-str": "long n = 1234;<br /><br />char buf[100];<br />snprintf(buf, 100, \"%ld\", n);<br /><br />wchar_t buf2[100];<br />swprintf(buf2, 100, L\"%ld\", n);<br /><br /><span style=\"color: gray\">/* some format specifiers:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>%d %ld %lld<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>%u %lu %llu<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>%.3f %.3e */</span>",
  "split": "<span style=\"color: gray\">/* strtok_r modifies 1st arg */</span><br />char *s = strdup(\"foo,bar baz\");<br />char *sep = \" ,\";<br />char *tok, *last;<br /><br /><span style=\"color: gray\">/* tok is never an empty string: */</span><br />for (tok = strtok_r(s, sep, &amp;last);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span>tok;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span>tok = strtok_r(NULL, sep, &amp;last))<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"token: %s\\n\", tok);<br /><br /><span style=\"color: gray\">/* also wcstok */</span>",
  "str-join": "<span style=\"color: gray\"><em>none</em></span>",
  "str-concat": "char *s1 = \"hello\";<br />char *s2 = \" world\";<br />size_t len = strlen(s1) + strlen(s2) + 1;<br />char *s3 = (char *)calloc(len, sizeof *s3);<br /><br />strcpy(s3, s1);<br />strcat(s3, s2);<br /><br /><span style=\"color: gray\">/* also wcscpy and wcscat */</span>",
  "str-replicate": "<span style=\"color: gray\"><em>none</em></span>",
  "extract-substr": "char target[3];<br />char *source = \"hello\";<br /><br />strncpy(target, source + 2, 2);<br />target[2] = '\\0';<br /><br /><span style=\"color: gray\">/* also wcsncpy */</span>",
  "index-substr": "const char *s = \"hello\";<br />const char *p = strstr(\"hello\", \"ll\");<br />size_t idx = p ? p - s : -1;<br /><br /><span style=\"color: gray\">/* also wcsstr */</span>",
  "fmt-str": "char buf[100];<br />snprintf(buf, 100, \"%s: %d\", \"Spain\", 7);<br /><br />wchar_t buf2[100];<br />swprintf(buf2, 100, L\"%S: %d\", L\"Spain\", 7);",
  "translate-case": "char *s = strdup(\"hello\");<br />int i;<br /><br />for (i=0; i &lt; strlen(s); ++i)<br /><span style=\"white-space: pre-wrap;\">  </span>s[i] = toupper(s[i]);<br /><br />for (i=0; i &lt; strlen(s); i++)<br /><span style=\"white-space: pre-wrap;\">  </span>s[i] = tolower(s[i]);<br /><br /><span style=\"color: gray\">/* also towupper and towlower */</span>",
  "trim": "char *s = strdup(\" lorem \");<br />size_t i, j;<br /><br /><span style=\"color: gray\">/* trim left */</span><br />for (i = 0; s[i] &amp;&amp; isspace(s[i]); ++i);<br />if (i)<br /><span style=\"white-space: pre-wrap;\">  </span>for (size_t j = 0; j &lt; strlen(s) - i + 1; ++j)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>s[j] = s[j + i];<br /><br /><span style=\"color: gray\">/* trim right */</span><br />for (i = strlen(s) - 1; s[i] &amp;&amp; isspace(s[i]); —i);<br />s[i + 1] = '\\0';<br /><br /><span style=\"color: gray\">/* also iswspace */</span>",
  "pad": "char buf[100];<br /><br /><span style=\"color: gray\">/* pad right: */</span><br />snprintf(buf, 100, \"%-10s\", \"hello\");<br /><span style=\"color: gray\">/* pad left: */</span><br />snprintf(buf, 100, \"%10s\", \"hello\");<br /><br /><span style=\"color: gray\">/* also swprintf */</span>",
  "str-len": "strlen(\"hello\")<br />wcslen(L\"hello\")",
  "char-type": "char<br />wchar_t",
  "char-literal": "'A'<br />L'A'",
  "char-lookup": "\"lorem ipsum\"[6]<br />L\"lorem ipsum\"[6]",
  "char-index": "char *s = \"aaa bbb ccc\";<br />char *p;<br />size_t n;<br /><br />p = strchr(s, ' ');<br />if (p)<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"first space at %ld\\n\", p - s);<br />p = strrchr(s, ' ');<br />if (p)<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"last space at %ld\\n\", p - s);<br /><br />n = strspn(s, \"abc\");<br />printf(\"first %ld chars in set\\n\", n);<br />p = strpbrk(s, \" ,:.\");<br />printf(\"first %ld chars not in set\\n\", n);<br /><br /><span style=\"color: gray\">/* also: wcschr wcsrchr wcsspn wcspbrk */</span>",
  "char-tests": "#include &lt;ctype.h&gt;<br />#include &lt;wctype.h&gt;<br /><br />isascii<br />isrune<br />iscntrl<br />isgraph<br />isalpha<br />isspace<br />isupper<br />islower<br />isalnum<br />isdigit<br />isxdigit<br />ispunct<br /><br /><span style=\"color: gray\">/* also: iswascii, iswrune, <span style=\"white-space: pre-wrap;\">...</span> */</span>",
  "chr-ord": "<span style=\"color: gray\">/* Character types are integer types so no conversion is necessary. Use %c and %C to print a character like a string of length one. */</span><br />char ch = 'A';<br />wchar_t ch2 = L'A';<br /><br />int i = ch + 7;<br />int i2 = ch2 + 7;<br /><br />wprintf(L\"%c %d %C %d\\n\", ch, ch, ch2, ch2);"
},
"regex": {
  "regex-metachar": "<span style=\"color: gray\">/* REG_BASIC: */</span><br />. [ ] \\ * ^ $<br /><br /><span style=\"color: gray\">/* REG_EXTENDED: */</span><br />. [ ] \\ ( ) * + ? { } | ^ $",
  "char-class-abbrev": "<span style=\"color: gray\">/* matches any character; does not match newline if<br /><span style=\"white-space: pre-wrap;\">   </span>REG_NEWLINE is used: */</span><br />.<br /><br /><span style=\"color: gray\">/* more character classes available in pcre library */</span>",
  "regex-anchors": "<span style=\"color: gray\">/* match beginning and end of string; match beginning and<br /><span style=\"white-space: pre-wrap;\">   </span>end of line if REG_NEWLINE is used: */</span><br />^ $",
  "regex-test": "#include &lt;regex.h&gt;<br /><br />regex_t rx;<br />int retval;<br />char *pat = \"1999\";<br />char *s = \"It's 1999\";<br /><br /><span style=\"color: gray\">/* Use REG_NOSUB if 4th arg to regexec() is NULL */</span><br />if (retval = regcomp(&amp;rx, pat, REG_EXTENDED | REG_NOSUB)) {<br /><span style=\"white-space: pre-wrap;\">  </span>char buf[200];<br /><span style=\"white-space: pre-wrap;\">  </span>regerror(retval, &amp;rx, buf, 200);<br /><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"regex error: %s\\n\", buf);<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>if (regexec(&amp;rx, s, 0, NULL, 0) == 0)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>printf(\"Party!\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>regfree(&amp;rx);<br />}",
  "case-insensitive-regex": "#include &lt;regex.h&gt;<br /><br />regex_t rx;<br />int retval;<br />char *pat = \"lorem\";<br />char *s = \"Lorem\";<br /><br />if (retval = regcomp(&amp;rx, pat, REG_EXTENDED | REG_ICASE)) {<br /><span style=\"white-space: pre-wrap;\">  </span>char buf[200];<br /><span style=\"white-space: pre-wrap;\">  </span>regerror(retval, &amp;rx, buf, 200);<br /><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"Regex error: %s\\n\", buf);<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>if (regexec(&amp;rx, s, 0, NULL, 0) == 0)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>printf(\"case insensitive match\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>regfree(&amp;rx);<br />}",
  "regex-modifiers": "<span style=\"color: gray\">/* bit flags used in 3rd arg of regcomp(): */</span><br />REG_BASIC<br />REG_EXTENDED<br />REG_ICASE<br />REG_NOSUB<br />REG_NEWLINE",
  "subst": "",
  "group-capture": "#include &lt;regex.h&gt;<br /><br />regex_t rx;<br />int retval;<br />char *pat = \"([0-9]{4})-([0-9]{2})-([0-9]{2})\";<br />char *s = \"2010-06-03\";<br /><br />if (retval = regcomp(&amp;rx, pat, REG_EXTENDED)) {<br /><span style=\"white-space: pre-wrap;\">  </span>char buf[200];<br /><span style=\"white-space: pre-wrap;\">  </span>regerror(retval, &amp;rx, buf, 200);<br /><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"Regex error: %s\\n\", buf);<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* first match is entire pattern */</span><br /><span style=\"white-space: pre-wrap;\">  </span>regmatch_t matches[4];<br /><span style=\"white-space: pre-wrap;\">  </span>if (regexec(&amp;rx, s, 4, matches, 0) == 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>char yr[5];<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>regmatch_t rm = matches[1];<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* rm_so and rm_eo contain index of start and end of<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">   </span>match; they are set to -1 if unused */</span><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>strncpy(yr, s + rm.rm_so, rm.rm_eo - rm.rm_so);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>yr[5] = '\\0';<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>printf(\"year is %s\\n\", yr);<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>regfree(&amp;rx);<br />}"
},
"dates-time": {
  "unix-epoch-type": "time_t",
  "broken-down-datetime-type": "struct tm",
  "current-unix-epoch": "time_t now;<br /><br />if (time(&amp;now) == -1)<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"time failed\");",
  "current-datetime": "",
  "broken-down-datetime-to-unix-epoch": "<span style=\"color: gray\">/* use host local time as tz: */</span><br />time_t t = mktime(&amp;dt);<br /><br /><span style=\"color: gray\">/* use UTC as tz: */</span><br />time_t t2 = timegm(&amp;dt2);",
  "unix-epoch-to-broken-down-datetime": "struct tm dt, dt2;<br /><br />if (!localtime_r(&amp;now, &amp;dt))<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"localtime_r failed\");<br /><br /><span style=\"color: gray\">/* UTC: */</span><br />if (!gmtime_r(&amp;now, &amp;dt2))<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"gmtime_r failed\");",
  "fmt-datetime": "char buf[100];<br />char *fmt = \"%Y-%m-%d %H:%M:%S\";<br /><br />if (!strftime(buf, 100, fmt, &amp;dt))<br /><span style=\"white-space: pre-wrap;\">  </span>fputs(\"strftime failed\\n\", stderr);",
  "parse-datetime": "char *s = \"1999-09-10 23:30:00\";<br />char *fmt = \"%Y-%m-%d %H:%M:%S\";<br />char *p = strptime(s, fmt, &amp;dt3);<br />if (!p)<br /><span style=\"white-space: pre-wrap;\">  </span>fputs(\"strptime failed\\n\", stderr);",
  "date-subtraction": "<span style=\"color: gray\">/* use mktime for local; timegm for utc: */</span><br />double delta_sec = difftime(mktime(&amp;dt), mktime(&amp;dt2));",
  "add-duration": "dt.tm_sec += 1000;<br />mktime(&amp;dt);<br /><br />dt.tm_hour += 1000;<br />mktime(&amp;dt);<br /><br />dt.tm_mday += 1000;<br />mktime(&amp;dt);",
  "date-parts": "int yr = dt.tm_year + 1900;<br />int mo = dt.tm_mon + 1;<br />int dy = dt.tm_mday;",
  "time-parts": "int hr = dt.tm_hour;<br />int mi = dt.tm_min;<br />int ss = dt.tm_sec;",
  "build-datetime": "dt.tm_year = 1999 - 1900;<br />dt.tm_mon = 9 - 1;<br />dt.tm_mday = 10;<br />dt.tm_hour = 23;<br />dt.tm_min = 30;<br />dt.tm_sec = 0;<br />dt.tm_isdst = 1;<br />dt.tm_gmtoff = -7 * 60 * 60;<br /><br />if (mktime(&amp;dt) == -1)<br /><span style=\"white-space: pre-wrap;\">  </span>fputs(\"mktime failed\\n\", stderr);",
  "local-tmz-determination": "<span style=\"color: gray\"><em>On a Unix system, the local time zone is stored in /etc/localtime. A process can have a different local time zone by setting the TZ environment variable.</em></span>",
  "tmz-info": "<span style=\"color: gray\"><em>offset abbreviation:</em></span><br />dt.tm_zone<br /><br /><span style=\"color: gray\"><em>UTC offset in hours:</em></span><br />dt.tm_gmtoff / 3600.0",
  "daylight-savings-test": "dt.tm_isdst",
  "microseconds": "#include &lt;sys/time.h&gt;<br /><br />struct timeval t;<br /><br />if (gettimeofday(&amp;t, NULL) == -1)<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"gettimeofday failed\");<br />else<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"epoch: %lu usec: %u\\n\", t.tv_sec, t.tv_usec);"
},
"fixed-length-arrays": {
  "declare-array": "int a[10];",
  "allocate-array-on-stack": "<span style=\"color: gray\">/* contents of memory undefined: */</span><br />int a[10];",
  "allocate-array-on-heap": "#include &lt;stdlib.h&gt;<br /><br /><span style=\"color: gray\">/* memory zero-initialized: */</span><br />int *a = calloc(10, sizeof *a);",
  "free-array-on-heap": "free(a);",
  "array-literal": "int a[] = {1, 2, 3};",
  "array-size": "",
  "array-lookup": "a[0]",
  "array-update": "a[0] = 4;",
  "array-out-of-bounds": "<span style=\"color: gray\"><em>undefined, possible SIGSEGV</em></span>",
  "array-element-index": "char *a[3] = {\"foo\", \"bar\", \"baz\"};<br />int loc = -1, i;<br /><br />for (i = 0; i &lt; 3; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (strcmp(\"bar\", a[i]) == 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>loc = i;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "slice-array": "int *a2;<br /><br />a2 = a[2];",
  "slice-array-to-end": "",
  "concatenate-array": "",
  "copy-array": "",
  "iterate-over-array": "int a[10];<br /><br />for (i = 0; i &lt; 10; ++i ) {<br /><span style=\"white-space: pre-wrap;\">  </span>a[i] = i * i;<br />}",
  "iterate-indices-elem": "",
  "reverse-array": "",
  "sort-array": "int<br />compare(const void *a, const void *b) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (*(int *)a &lt; *(int *)b) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>return -1;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>else if (*(int *)a == *(int *)b) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>return 0;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>return 1;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br /><br />int a[5] = {6, 8, 10, 9, 7};<br /><br /><span style=\"color: gray\">/* 2nd arg is array length; 3rd arg is element size */</span><br />qsort(a, 5, sizeof (int), &amp;compare);"
},
"resizable-arrays": {
  "declare-array": "",
  "array-literal": "",
  "array-size": "",
  "array-lookup": "",
  "array-update": "",
  "array-out-of-bounds": "",
  "array-element-index": "",
  "slice-array": "",
  "slice-array-to-end": "",
  "array-back": "",
  "array-front": "",
  "concatenate-array": "",
  "copy-array": "",
  "iterate-over-array": "",
  "iterate-indices-elem": "",
  "reverse-array": "",
  "sort-array": "",
  "map": "",
  "filter": "",
  "reduce": ""
},
"dictionaries": {
  "declare-dict": "",
  "dict-literal": "",
  "dict-size": "",
  "dict-lookup": "",
  "dict-update": "",
  "dict-missing-key": "",
  "dict-is-key-present": "",
  "dict-delete": "",
  "dict-iter": "",
  "dict-key-val-arrays": ""
},
"functions": {
  "def-func": "int add(int n, int m) {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + m;<br />}",
  "invoke-func": "add(3, 7)",
  "forward-decl-func": "float add(float x, float y);<br /><br /><span style=\"color: gray\">/* if a function invocation is encountered before a<br /><span style=\"white-space: pre-wrap;\">  </span>declaration or a definition, the arguments and the<br /><span style=\"white-space: pre-wrap;\">  </span>return value are assumed to have type 'int' */</span><br />printf(\"%f\\n\", add(2.2, 3.5));<br /><br />float add(float x, float y) {<br /><span style=\"white-space: pre-wrap;\">  </span>return x + y;<br />}",
  "overload-func": "<span style=\"color: gray\"><em>not permitted</em></span>",
  "nest-func": "<span style=\"color: gray\"><em>not permitted</em></span>",
  "default-val-param": "<span style=\"color: gray\"><em>none</em></span>",
  "variable-num-arg": "#include &lt;stdarg.h&gt;<br /><br />char* concat(int cnt, <span style=\"white-space: pre-wrap;\">...</span>) {<br /><br /><span style=\"white-space: pre-wrap;\">  </span>int i, len;<br /><span style=\"white-space: pre-wrap;\">  </span>va_list ap;<br /><span style=\"white-space: pre-wrap;\">  </span>char *retval, *arg;<br /><br /><span style=\"white-space: pre-wrap;\">  </span>va_start(ap, cnt);<br /><span style=\"white-space: pre-wrap;\">  </span>for (i = 0, len = 0; i &lt; cnt; i++) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>len += strlen(va_arg(ap, char*));<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>va_end(ap);<br /><br /><span style=\"white-space: pre-wrap;\">  </span>retval = calloc(len + 1, sizeof *retval);<br /><br /><span style=\"white-space: pre-wrap;\">  </span>va_start(ap, cnt);<br /><span style=\"white-space: pre-wrap;\">  </span>for (i = 0, len = 0; i &lt; cnt; i++) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>arg = va_arg(ap, char*);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>strcpy(retval + len, arg);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>len += strlen(arg);<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>va_end(ap);<br /><br /><span style=\"white-space: pre-wrap;\">  </span>return retval;<br />}<br /><br />char *s = concat(4, \"Hello\", \", \", \"World\", \"!\");",
  "named-param": "<span style=\"color: gray\"><em>none</em></span>",
  "pass-by-val": "void use_integer(int i) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><em>function body</em></span><br />}<br /><br />int i = 7;<br /><br />use_integer(i);",
  "pass-by-addr": "void use_iptr(int *i) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><em>function body</em></span><br />}<br /><br />int i = 7;<br /><br />use_iptr(&amp;i);",
  "pass-by-ref": "<span style=\"color: gray\"><em>not possible</em></span>",
  "retval": "<span style=\"color: gray\">return <em>arg</em></span>",
  "no-retval": "<span style=\"color: gray\">/* declare function void: */</span><br />void print_err(char *msg) {<br /><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, msg);<br />}",
  "multiple-retval": "<span style=\"color: gray\"><em>not permitted</em></span>",
  "named-retval": "<span style=\"color: gray\"><em>none</em></span>",
  "exec-on-return": "",
  "anonymous-func-literal": "<span style=\"color: gray\"><em>none</em></span>",
  "invoke-anonymous-func": "",
  "func-private-state": "int<br />counter() {<br /><span style=\"white-space: pre-wrap;\">  </span>static int n = 0;<br /><br /><span style=\"white-space: pre-wrap;\">  </span>return ++n;<br />}",
  "func-as-val": "int<br />add(int m, int n) {<br /><span style=\"white-space: pre-wrap;\">  </span>return m + n;<br />}<br /><br /><span style=\"color: gray\">/* a function cannot be stored in a variable, but<br /><span style=\"white-space: pre-wrap;\">  </span>its address can */</span><br />int (* fp)(int, int) = &amp;add;<br /><br />printf(\"1 + 2: %d\\n\", (*fp)(1, 2));"
},
"execution-control": {
  "if": "int signum;<br /><br />if (i &gt; 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 1;<br />} else if (i == 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 0;<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = -1;<br />}",
  "switch": "<span style=\"color: gray\">/* switch expression must be an integer */</span><br /><br />switch (i) {<br />case 0:<br />case 1:<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"i is boolean\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>break;<br />default:<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"i is not a boolean\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>break;<br />}<br /><br /><span style=\"color: gray\">/* use \"break\" to prevent falling through */</span>",
  "while": "int i = 0;<br /><br />while (i &lt; 10) {<br /><span style=\"white-space: pre-wrap;\">  </span>++i;<br />}",
  "for": "int i, n;<br /><br />for (i = 1, n = 1; i &lt;= 10; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>n *= i;<br />}",
  "for-local-scope": "<span style=\"color: gray\"><em>none</em></span>",
  "infinite-loop": "for (;;) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">/*</span> code */</span><br />}<br /><br />while (1) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">/*</span> code */</span><br />}",
  "break": "break",
  "break-from-nested-loops": "<span style=\"color: gray\"><em>use goto or flag variable</em></span>",
  "continue": "continue",
  "single-stmt-branch-loop": "while (n % 17 != 0)<br /><span style=\"white-space: pre-wrap;\">  </span>++n;<br /><br />if (n &lt; 0)<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"negative\\n\");",
  "dangling-else": "int a = 1, b = -3, c;<br /><br /><span style=\"color: gray\">/* indentation shows how ambiguity is resolved */</span><br />if (a &gt; 0)<br /><span style=\"white-space: pre-wrap;\">  </span>if (b &gt; 0)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>c = 1;<br /><span style=\"white-space: pre-wrap;\">  </span>else<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>c = 2;<br /><br /><span style=\"color: gray\">/* gcc warns about dangling else; -Werror turns warnings into errors */</span>",
  "goto": "<span style=\"white-space: pre-wrap;\">  </span>if (err) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>goto cleanup;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* code */</span><br /><br />cleanup:<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"cleaning up<span style=\"white-space: pre-wrap;\">...</span>\\n\");",
  "longjmp": "#include &lt;setjmp.h&gt;<br /><br />void<br />callee(jmp_buf env) {<br /><span style=\"white-space: pre-wrap;\">  </span>longjmp(env, 1);<br /><span style=\"white-space: pre-wrap;\">  </span>/* unreachable */<br />}<br /><br />void<br />caller() {<br /><span style=\"white-space: pre-wrap;\">  </span>jmp_buf env;<br /><br /><span style=\"white-space: pre-wrap;\">  </span>switch (setjmp(env)) {<br /><span style=\"white-space: pre-wrap;\">  </span>case 0:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>callee(env);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>/* unreachable */<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>case 1:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>printf(\"returned from callee\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>default:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>printf(\"unexpected setjump value\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "finally-block": ""
},
"concurrency": {
  "sleep": "#include &lt;unistd.h&gt;<br /><br /><span style=\"color: gray\">/* seconds */</span><br />int retval = sleep(10);<br />if (retval != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"interupted with %d s to go\", retval);<br />}<br /><br /><span style=\"color: gray\">/* microseconds */</span><br />if (usleep(10000)) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"usleep failed\");<br />}",
  "timeout": "",
  "start-thread": "#include &lt;pthread.h&gt;<br /><br />typedef struct {<br /><span style=\"white-space: pre-wrap;\">  </span>int id;<br />} payload;<br /><br />void*<br />thread(void* arg) {<br /><span style=\"white-space: pre-wrap;\">  </span>payload* pl = (payload*)arg;<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"the value is %d\\n\", pl-&gt;id);<br />}<br /><br />pthread_t thr;<br />payload pl = {3};<br /><br />if (pthread_create(&amp;thr, NULL, &amp;thread, (void*)&amp;pl)) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"failed to create thead\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>exit(1);<br />}",
  "terminate-current-thread": "#include &lt;pthread.h&gt;<br /><br />payload pl = {7};<br /><br />pthread_exit((void*)&amp;pl);",
  "terminate-other-thread": "#include &lt;pthread&gt;<br /><br />pthread_t thr;<br />payload pl = {3};<br /><br />if (pthread_create(&amp;thr, NULL, &amp;thread, (void*)&amp;pl)) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"failed to create thead\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>exit(1);<br />}<br /><br />sleep(5);<br /><br />if (pthread_cancel(thr)) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"failed to cancel thread\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>exit (1);<br />}",
  "list-threads": "<span style=\"color: gray\"><em>no portable way</em></span>",
  "wait-on-thread": "",
  "lock": "",
  "create-msg-queue": "",
  "send-msg": "",
  "receive-msg": ""
},
"file-handles": {
  "std-file-handles": "stdin stdout stderr",
  "read-line-stdin": "char *line = NULL;<br />size_t cap = 0;<br />ssize_t len;<br /><br /><span style=\"color: gray\">/* if line is not NULL, it should be memory allocated by<br /><span style=\"white-space: pre-wrap;\">   </span>malloc and the size should be in cap. If size is not<br /><span style=\"white-space: pre-wrap;\">   </span>sufficient getline will call realloc on line */</span><br />len = getline(&amp;line, &amp;cap, stdin);<br /><br />if (len == -1) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (ferror(stdin)) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>perror(\"getline err\");<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>else if (feof(stdin)) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"end of file\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />} else {<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* use line here */</span><br /><br /><span style=\"white-space: pre-wrap;\">  </span>free(line);<br />}",
  "write-line-stdout": "<span style=\"color: gray\">/* returns EOF on error */</span><br />int retval = puts(\"Hello, World!\");",
  "printf": "printf(\"count: %d\\n\", 7);<br />wprintf(L\"count: %d\\n\", 7);",
  "open-file": "<span style=\"color: gray\">/* returns NULL on error */</span><br />FILE *f = fopen(\"/etc/hosts\", \"r\");",
  "open-file-write": "<span style=\"color: gray\">/* returns NULL on error */</span><br />FILE *f = fopen(\"/tmp/test\", \"w\");",
  "open-file-append": "<span style=\"color: gray\">/* returns NULL on error */</span><br />FILE *f = fopen(\"/tmp/err.log\", \"a\");",
  "close-file": "<span style=\"color: gray\">/* returns EOF on error */</span><br />int retval = fclose(f);",
  "close-file-implicitly": "<span style=\"color: gray\"><em>none</em></span>",
  "io-err": "<span style=\"color: gray\"><em>Functions return values such as</em> EOF, NULL, <em>or</em> -1 <em>to indicate error. Some functions return the value of</em> errno. <em>In some cases errors are not distinguished from end-of-file. The functions</em> ferror() <em>and</em> feof() <em>can be used to test a file handle.<br /><br />The type of error is stored in</em> errno. strerror(errno) <em>or the thread safe</em> strerror_r(errno, buf, buflen) <em>convert the errors code to a string and</em> perror() <em>writes its argument to</em> stderr <em>with</em> sterror(errno).</span>",
  "read-line": "char line[BUFSIZ];<br /><br />if (fgets(line, BUFSIZ, f) == NULL) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (ferror(stdin)) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>perror(\"getline err\");<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>else if (feof(stdin)) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"end of file\\n\");<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>if ('\\n' == line[strlen(line) - 1]) {<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* use line here */</span><br /><br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"long line truncated\\n\");<br />}",
  "file-line-iterate": "",
  "read-file-array": "",
  "read-file-str": "",
  "write-str": "<span style=\"color: gray\">/* returns EOF on error */</span><br />int retval = fputs(\"Hello, World!\", f);",
  "write-line": "<span style=\"color: gray\">/* returns EOF on error */</span><br />int retval = fputs(\"Hello, World!\\n\", f);",
  "flush": "if (fflush(f) == EOF) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"fflush failed\");<br />}",
  "eof-test": "feof(f)",
  "seek": "long pos;<br />if ((pos = ftell(f)) == -1) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"ftell failed\");<br />}<br /><br /><span style=\"color: gray\">/* 3rd arg can also be SEEK_CUR or SEEK_END */</span><br />if (fseek(f, 0, SEEK_SET) == -1) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"fseek failed\");<br />}",
  "tmp-file": "#include &lt;limits.h&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* PATH_MAX */</span><br />#include &lt;unistd.h&gt;<br /><br />char buf[PATH_MAX];<br /><br />strcpy(buf, \"/tmp/foo.XXXXXX\");<br /><br /><span style=\"color: gray\">/* terminal Xs will be replaced: */</span><br />int fd = mkstemp(buf);<br /><br />if (fd != -1) {<br /><span style=\"white-space: pre-wrap;\">  </span>FILE *f = fdopen(fd, \"w\");<br /><br /><span style=\"white-space: pre-wrap;\">  </span>if (NULL == f) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>perror(\"fdopen failed\");<br /><span style=\"white-space: pre-wrap;\">  </span>} else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* use f */</span><br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"mkstemp failed\");<br />}"
},
"files": {
  "file-test": "#include &lt;sys/stat.h&gt;<br />#include &lt;unistd.h&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* access() */</span><br /><br />struct stat buf;<br /><br />if (access(\"/tmp/foo\", F_OK) &gt;= 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* file exists */</span><br />}<br /><br />if (stat(\"/tmp/foo\", &amp;buf) != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"stat failed\");<br />} else if (S_ISREG(buf.st_mode)) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* file is regular */</span><br />}",
  "file-size": "#include &lt;sys/stat.h&gt;<br /><br />struct stat buf;<br /><br />if (stat(\"/tmp/foo\", &amp;buf) != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"stat failed\");<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"size: %llu\\n\", buf.st_size);<br />}",
  "readable-writable-executable": "#include &lt;unistd.h&gt;<br /><br />if (access(\"/etc/hosts\", R_OK) != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"not readable\\n\");<br />}<br />if (access(\"/etc/hosts\", W_OK) != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"not writable\\n\");<br />}<br />if (access(\"/etc/hosts\", X_OK) != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"not executable\\n\");<br />}",
  "chmod": "#include &lt;sys/stat.h&gt;<br /><br />if (chmod(\"/tmp/foo\", 0755) == -1) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"chmod failed\");<br />}",
  "last-modification-time": "",
  "file-cp-rm-mv": "<span style=\"color: gray\">/* no copy function in standard library */</span><br /><br />if (remove(\"/tmp/foo\")) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"remove failed\");<br />}<br /><br />if (rename(\"/tmp/bar\", \"/tmp/foo\")) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"rename failed\");<br />}",
  "symlink": "#include &lt;limits.h&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* PATH_MAX */</span><br />#include &lt;sys/stat.h&gt;<br />#include &lt;unistd.h&gt;<br /><br />if (symlink(\"/etc/hosts\", \"/tmp/hosts\") == -1) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"symlink failed\");<br />}<br /><br />struct stat sbuf;<br /><br />if (stat(\"/tmp/hosts\", &amp;buf) != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"stat failed\");<br />} else if (S_ISLNK(buf.st_mode)) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* file is symlink */</span><br />}<br /><br />char pbuf[PATH_MAX + 1];<br /><br />ssize_t size = readlink(\"/tmp/hosts\", pbuf, PATH_MAX);<br /><br />if (size &gt;= 0 ) {<br /><span style=\"white-space: pre-wrap;\">  </span>pbuf[size] = 0;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* pbuf now contains null-terminated string<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">   </span>with target path */</span><br />}",
  "unused-file-name": "<span style=\"color: gray\">/* if first argument is NULL, path is in system temp<br /><span style=\"white-space: pre-wrap;\">   </span>directory. Caller should free() return value. */</span><br />char *path = tempnam(\"/tmp\", \"foo\");"
},
"directories": {
  "working-dir": "",
  "build-pathname": "",
  "dirname-basename": "#include &lt;libgen.h&gt;<br /><br />char *s1 = strdup(\"/etc/hosts\");<br />char *s2 = strdup(\"/etc/hosts\");<br /><span style=\"color: gray\">/* Check whether s1 or s2 are NULL. */</span><br /><br /><span style=\"color: gray\">/* Some implementations return pointers to statically allocated<br /><span style=\"white-space: pre-wrap;\">   </span>memory which is overwritten by subsequent calls;<br /><span style=\"white-space: pre-wrap;\">   </span>others modify the input string. */</span><br />char *s3 = dirname(s1);<br />char *s4 = basename(s2);",
  "absolute-pathname": "char *s;<br /><br />if ((s = realpath(\"..\", NULL)) == NULL) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"realpath failed\");<br />}<br />else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* use s */</span><br />}",
  "dir-iterate": "#include &lt;dirent.h&gt;<br /><br />DIR *dir = opendir(\"/etc\");<br />struct dirent *de;<br /><br />while (de = readdir(dir)) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"%s\\n\", de-&gt;d_name);<br />}<br /><br />closedir(dir);",
  "glob": "#include &lt;glob.h&gt;<br /><br />glob_t pglob;<br />int i;<br /><br />glob(\"/etc/*\", 0, NULL, &amp;pglob);<br /><br />for (i = 0; i &lt; pglob.gl_pathc; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"%s\\n\", pglob.gl_pathv[i]);<br />}<br /><br />globfree(&amp;pglob);",
  "mkdir": "#include &lt;sys/stat.h&gt;<br /><br />if (mkdir(\"/tmp/foo\")) {<br /><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"mkdir err: %s\\n\", strerror(errno));<br />}",
  "recursive-cp": "",
  "rmdir": "#include &lt;unistd.h&gt;<br /><br />if (rmdir(\"/tmp/foo\") == -1) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"rmdir failed\");<br />}",
  "rm-rf": "",
  "dir-test": "#include &lt;sys/stat.h&gt;<br /><br />struct stat buf;<br /><br />if (stat(\"/tmp/foo\", &amp;buf) != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"stat failed\");<br />} else if (S_ISDIR(buf.st_mode)) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* file is directory */</span><br />}",
  "unused-dir": "#include &lt;limits.h&gt;<br /><br />char buf[PATH_MAX];<br /><br />strcpy(buf, \"/tmp/fooXXXXXX\");<br /><br /><span style=\"color: gray\">/* terminal Xs will be replaced: */</span><br />if (mkdtemp(buf) == NULL) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"mkdtemp failed\");<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* use buf */</span><br />}",
  "system-tmp-dir": "<span style=\"color: gray\">/* defined in &lt;stdio.h&gt; */</span><br />P_tmpdir"
},
"processes-environment": {
  "cmd-line-arg": "int main(int argc, char <span style=\"white-space: pre-wrap;\">**</span>argv) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (argc &gt; 1)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>printf(\"first arg: %s\\n\", argv[1]);<br /><span style=\"white-space: pre-wrap;\">  </span>return 0;<br />}",
  "program-name": "int main(int argc, char <span style=\"white-space: pre-wrap;\">**</span>argv) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"program name: %s\\n\", argv[0]);<br /><span style=\"white-space: pre-wrap;\">  </span>return 0;<br />}",
  "env-var": "#include &lt;stdlib.h&gt;<br /><br />char *home = getenv(\"HOME\");<br />setenv(\"EDITOR\", \"emacs\", 1);<br />unsetenv(\"EDITOR\");",
  "env-var-iter": "extern char <span style=\"white-space: pre-wrap;\">**</span>environ;<br />char <span style=\"white-space: pre-wrap;\">**</span>env, *p, *key;<br /><br />for (env = environ; *env; ++env) {<br /><span style=\"white-space: pre-wrap;\">  </span>p = strchr(*env, '=');<br /><span style=\"white-space: pre-wrap;\">  </span>if (p) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>size_t keylen = p - *env;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>key = strndup(*env, keylen);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>printf(\"key: %s value: %s\\n\", key, *env + keylen + 1);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>free(key);<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "user-id-name": "#include &lt;unistd.h&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* getlogin */</span><br /><br />printf(\"uid: %d\\n\", getuid());<br />printf(\"username: %s\\n\", getlogin());",
  "exit": "<span style=\"color: gray\">/* use 0 for success; 1 through 127 for failure */</span><br />exit(1);",
  "executable-test": "#include &lt;unistd.h&gt;<br /><br />if (access(\"/bin/ls\", X_OK) != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"not executable\\n\");<br />}",
  "external-cmd": "<span style=\"color: gray\">/* retval of -1 indicates fork or wait failed.<br /><span style=\"white-space: pre-wrap;\">   </span>127 indicates shell failed */</span><br />int retval = system(\"ls -l *\");",
  "fork": "",
  "exec": "",
  "pipe": "",
  "wait": "",
  "pid": "#include &lt;unistd.h&gt;<br /><br /><span style=\"color: gray\">/* getpid() and getppid() have return type pid_t */</span><br />printf(\"%d\\n\", getpid());<br />printf(\"%d\\n\", getppid())",
  "signal-handler": "#include &lt;signal.h&gt;<br /><br /><span style=\"color: gray\">/* assumes a POSIX environment */</span><br />void<br />handle_signal(int signo) {<br /><span style=\"white-space: pre-wrap;\">  </span>int restore = errno;<br /><span style=\"white-space: pre-wrap;\">  </span>switch(signo) {<br /><span style=\"white-space: pre-wrap;\">  </span>case SIGUSR1:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>write(1, \"caught SIGUSR1\\n\", 15);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>default:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>errno = restore;<br />}<br /><br /><span style=\"color: gray\">/* 2nd arg can also be SIG_IGN or SIG_DFL */</span><br />sig_t prev_handler = signal(SIGUSR1, &amp;handle_signal);<br /><br />if (prev_handler == SIG_ERR) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"signal failed\");<br /><span style=\"white-space: pre-wrap;\">  </span>exit(1);<br />}",
  "send-signal": "#include &lt;signal.h&gt;<br />#include &lt;unistd.h&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* getppid */</span><br /><br />if (kill(getppid(), SIGUSR1) == -1) {<br /><span style=\"white-space: pre-wrap;\">  </span>perror(\"kill failed\");<br />}"
},
"option-parsing": {
  "getopt": "#include &lt;getopt.h&gt;<br /><br /><span style=\"color: gray\">/* 2nd value indicates whether option takes an argument */</span><br />static struct option long_opts[] = {<br /><span style=\"white-space: pre-wrap;\">  </span>{\"debug\", no_argument, NULL, 'd'},<br /><span style=\"white-space: pre-wrap;\">  </span>{\"threshold\", required_argument, NULL, 't'},<br /><span style=\"white-space: pre-wrap;\">  </span>{0, 0, 0, 0}<br />};<br /><br />int debug = 0;<br />double threshold = 0.0;<br />char *file = NULL;<br /><br />int ch;<br />int opti;<br />char *endptr;<br /><br />while (1) {<br /><span style=\"white-space: pre-wrap;\">  </span>ch = getopt_long(argc, argv, \"dt:\", long_opts, &amp;opti);<br /><span style=\"white-space: pre-wrap;\">  </span>if (-1 == ch) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br /><span style=\"white-space: pre-wrap;\">  </span>switch (ch) {<br /><span style=\"white-space: pre-wrap;\">  </span>case 'd':<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>debug = 1;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>case 't':<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>threshold = strtod(optarg, &amp;endptr);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>if (*endptr != 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"expected float: %s\\n\", optarg);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>exit(1);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>default:<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fprintf(stderr, \"unexpected arg: %d\\n\", ch);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>exit(1);<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br /><br /><span style=\"color: gray\">/* optind is index of 1st arg not consumed by getopt */</span><br />if (optind != argc - 1) {<br /><span style=\"white-space: pre-wrap;\">  </span>fputs(\"USAGE: foo [<span style=\"white-space: pre-wrap;\">--</span>multi] [<span style=\"white-space: pre-wrap;\">--</span>threshold=NUM] FILE\\n\",<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>stderr);<br /><span style=\"white-space: pre-wrap;\">  </span>exit(1);<br />}<br />else {<br /><span style=\"white-space: pre-wrap;\">  </span>file = argv[optind];<br />}"
},
"libraries-namespaces": {
  "load-lib": "<span style=\"color: gray\">/* The library must also be linked:<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span>$ gcc foo.o main.c<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span>If the library is in an archive:<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span>$ gcc -lfoo main.c<br />*/</span><br />#include \"foo.h\"",
  "load-lib-subdir": "#include \"lib/foo.h\"",
  "lib-path": "<span style=\"color: gray\"><em>Add directory to path searched by</em> #include <em>directive:</em></span><br />$ gcc -I/home/fred/include foo.c<br /><br /><span style=\"color: gray\"><em>Add directory to path searched by -l (lowercase L) option:</em></span><br />$ gcc -L/home/fred/lib -lbar foo.c",
  "declare-namespace": "<span style=\"color: gray\"><em>none</em></span>",
  "alias-namespace": "<span style=\"color: gray\"><em>none</em></span>",
  "unqualified-import": "<span style=\"color: gray\"><em>none</em></span>",
  "unqualified-import-of-definitions": "",
  "pkg-manager": ""
},
"user-defined-types": {
  "typedef": "typedef int customer_id;<br />customer_id cid = 3;",
  "enum": "enum day_of_week {<br /><span style=\"white-space: pre-wrap;\">  </span>mon, tue, wed, thu, fri, sat, sun<br />};<br /><br />enum day_of_week dow = tue;",
  "struct-definition": "struct medal_count {<br /><span style=\"white-space: pre-wrap;\">  </span>const char* country;<br /><span style=\"white-space: pre-wrap;\">  </span>int gold;<br /><span style=\"white-space: pre-wrap;\">  </span>int silver;<br /><span style=\"white-space: pre-wrap;\">  </span>int bronze;<br />};",
  "struct-declaration<br-/>": "struct medal_count spain;",
  "struct-initialization": "struct medal_count spain = {\"Spain\", 3, 7, 4};<br /><br />struct medal_count france = {<br /><span style=\"white-space: pre-wrap;\">  </span>.gold = 8,<br /><span style=\"white-space: pre-wrap;\">  </span>.silver = 7,<br /><span style=\"white-space: pre-wrap;\">  </span>.bronze = 9,<br /><span style=\"white-space: pre-wrap;\">  </span>.country = \"France\"<br />};",
  "struct-literal": "struct medal_count france;<br /><br />france = (struct medal_count) {<br /><span style=\"white-space: pre-wrap;\">  </span>.gold = 8,<br /><span style=\"white-space: pre-wrap;\">  </span>.silver = 7,<br /><span style=\"white-space: pre-wrap;\">  </span>.bronze = 9,<br /><span style=\"white-space: pre-wrap;\">  </span>.country = \"France\"<br />};",
  "struct-member-assignment": "spain.country = \"Spain\";<br />spain.gold = 3;<br />spain.silver = 7;<br />spain.bronze = 4;",
  "struct-member-access": "int spain_total = spain.gold + spain.silver + spain.bronze;"
},
"cpp-macros": {
  "include-file": "<span style=\"color: gray\">/* search path include system directories: */</span><br />#include &lt;stdio.h&gt;<br /><br /><span style=\"color: gray\">/* search path also includes directory of source file */</span><br />#include \"foo.h\"",
  "add-system-dir": "$ gcc -I/opt/local/include foo.c",
  "def-macro": "#define PI 3.14",
  "cmd-line-macro": "$ gcc -DPI=3.14 foo.c",
  "undef-macro": "#undef PI",
  "macro-with-arguments": "#define MIN(X, Y) ((X) &lt; (Y) ? (X) : (Y))",
  "stringify-macro-argument": "",
  "concatenate-tokens": "",
  "conditional-compilation": "#if defined __WIN32<br /><span style=\"white-space: pre-wrap;\">  </span>win32_prinft(\"%f\\n\", x);<br />#else<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"%f\\n\", x);<br />#endif",
  "macro-operators": "<span style=\"color: gray\"><em>The conditional of</em> #if <em>can contain integer literals and the following operators:</em></span><br /><br /><span style=\"white-space: pre-wrap;\">&amp;&amp;</span> <span style=\"white-space: pre-wrap;\">||</span> !<br /><span style=\"white-space: pre-wrap;\">==</span> != &lt; &gt; &lt;= &gt;=<br /><span style=\"white-space: pre-wrap;\">+</span> - * / %<br /><span style=\"white-space: pre-wrap;\"> &lt;&lt; &gt;&gt; &amp; | ^ ~ </span><br /><br /><span style=\"color: gray\"><em>In addition, the</em> defined() <em>operator can be used to test whether a macro is defined.</em></span><br /><br /><span style=\"color: gray\">#ifdef FOO <em>is a shortcut for</em> #if defined(FOO)</span>"
},
"net-web": {
  "http-get": ""
},
"unit-tests": {
  "unit-test-example": "$ sudo apt-get install check<br /><br />$ cat &gt; check_foo.c<br />#include &lt;check.h&gt;<br /><br />START_TEST(test_foo) {<br /><span style=\"white-space: pre-wrap;\">  </span>fail_unless(0, \"not true\");<br />}<br />END_TEST<br /><br />Suite *<br />suite_foo(void) {<br /><span style=\"white-space: pre-wrap;\">  </span>Suite *ste = suite_create(\"suite: foo\");<br /><span style=\"white-space: pre-wrap;\">  </span>TCase *tc = tcase_create(\"case: foo\");<br /><br /><span style=\"white-space: pre-wrap;\">  </span>tcase_add_test(tc, test_foo);<br /><span style=\"white-space: pre-wrap;\">  </span>suite_add_tcase(ste, tc);<br /><br /><span style=\"white-space: pre-wrap;\">  </span>return ste;<br />}<br /><br />int<br />main(void) {<br /><span style=\"white-space: pre-wrap;\">  </span>int number_failed;<br /><span style=\"white-space: pre-wrap;\">  </span>Suite *ste = suite_foo();<br /><span style=\"white-space: pre-wrap;\">  </span>SRunner *sr = srunner_create(ste);<br /><br /><span style=\"white-space: pre-wrap;\">  </span>srunner_run_all(sr, CK_NORMAL);<br /><span style=\"white-space: pre-wrap;\">  </span>number_failed = srunner_ntests_failed(sr);<br /><span style=\"white-space: pre-wrap;\">  </span>srunner_free(sr);<br /><br /><span style=\"white-space: pre-wrap;\">  </span>return (number_failed);<br />}<br /><br />$ gcc -o check_foo check_foo.c -lcheck<br /><br />$ ./check_foo<br />Running suite(s): foo<br />0%: Checks: 1, Failures: 1, Errors: 0<br />check_foo.c:4:F:foo:test_foo:0: not equal",
  "equality-assertion": "fail_unless(1 == 2, \"integers not equal\");<br /><br />char *s = \"lorem\";<br />fail_unless(strcmp(s, \"ipsum\"), \"strings not equal\");",
  "setup-and-teardown": "",
  "unit-test-coverage": ""
},
"debugging-profiling": {
  "check-syntax": "$ gcc -fsyntax-only foo.c",
  "stronger-warnings": "$ gcc -Wall foo.c",
  "suppress-warnings": "$ gcc -w foo.c",
  "warnings-as-err": "$ gcc -Werror foo.c",
  "lint": "$ sudo apt-get install splint<br />$ splint foo.c",
  "src-cleanup": "",
  "debugger": "$ gcc -g -o foo foo.c<br />$ gdb foo",
  "debugger-cmds": "<span style=\"white-space: pre-wrap;\">&gt;</span> h<br /><span style=\"white-space: pre-wrap;\">&gt;</span> l <span style=\"color: gray\">[FIRST_LINENO, LAST_LINENO]</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> file <span style=\"color: gray\">PATH</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> n<br /><span style=\"white-space: pre-wrap;\">&gt;</span> s<br /><span style=\"white-space: pre-wrap;\">&gt;</span> b <span style=\"color: gray\">[FILE:]LINENO</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> i<br /><span style=\"white-space: pre-wrap;\">&gt;</span> d <span style=\"color: gray\">NUM</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> c<br /><span style=\"white-space: pre-wrap;\">&gt;</span> bt<br /><span style=\"white-space: pre-wrap;\">&gt;</span> up<br /><span style=\"white-space: pre-wrap;\">&gt;</span> do<br /><span style=\"white-space: pre-wrap;\">&gt;</span> p <span style=\"color: gray\">EXPR</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> r <span style=\"color: gray\">[ARG1[, [ARG2 <span style=\"white-space: pre-wrap;\">...</span>]]</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> q",
  "cpu-usage": "#include &lt;sys/times.h&gt;<br />#include &lt;unistd.h&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* sysconf */</span><br /><br />struct tms start, end;<br /><br />double ticks_per_s = (double)sysconf(_SC_CLK_TCK);<br /><br />clock_t start_wall = times(&amp;start);<br /><br />if (start_wall &lt; 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>fputs(\"times failed\", stderr);<br /><span style=\"white-space: pre-wrap;\">  </span>return (1);<br />}<br /><br />int i;<br />for (i = 0; i &lt; 1000 * 1000 * 1000; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">/* empty loop */</span><br />}<br /><br />clock_t end_wall = times(&amp;end);<br /><br />if (end_wall &lt; 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>fputs(\"times failed\", stderr);<br /><span style=\"white-space: pre-wrap;\">  </span>return (1);<br />}<br /><br />clock_t wall = end_wall - start_wall;<br />clock_t user = end.tms_utime - start.tms_utime;<br />clock_t system = end.tms_stime - start.tms_stime;<br /><br />printf(\"wall: %f s\\n\", wall / ticks_per_s);<br />printf(\"user: %f s\\n\", user / ticks_per_s);<br />printf(\"system: %f s\\n\", system / ticks_per_s);",
  "profile": "<span style=\"color: gray\"><em>does not work on Mac OS X</em></span><br />$ gcc -pg -o foo foo.c<br />$ ./foo<br />$ gprof foo",
  "memory-tool": "$ sudo apt-get install valgrind<br />$ gcc -o foo foo.c<br />$ valgrind foo"
}
}
