{

"version": {
  "version-used": "<span style=\"color: gray\"><em>GNU Fortran 4.5 (Fortran 95)</em></span>",
  "show-version": "$ gfortran <span style=\"white-space: pre-wrap;\">--</span>version"
},
"grammar-execution": {
  "hello-world": "$ cat hello.f95<br />program hello<br /><span style=\"white-space: pre-wrap;\">  </span>write(*,*) 'Hello, World!'<br />end program hello<br /><br />$ gfortran hello.f95<br /><br />$ ./a.out<br /><span style=\"white-space: pre-wrap;\"> </span>Hello, World!",
  "file-suffixes": ".f95 <span style=\"color: gray\"><em>none</em></span> .o",
  "block-delimiters": "program <span style=\"color: gray\"><em>…</em></span> end program<br />function <span style=\"color: gray\"><em>…</em></span> end function<br />subroutine <span style=\"color: gray\"><em>…</em></span>end subroutine<br />if <span style=\"color: gray\"><em>…</em></span> then <span style=\"color: gray\"><em>…</em></span> elseif <span style=\"color: gray\"><em>…</em></span> then <span style=\"color: gray\"><em>…</em></span> else <span style=\"color: gray\"><em>…</em></span> endif<br />do while <span style=\"color: gray\"><em>…</em></span> end do<br />do <span style=\"color: gray\"><em>…</em></span> end do",
  "stmt-terminator": "<span style=\"color: gray\"><em>newline</em></span><br /><br /><span style=\"color: gray\"><em>when a line ends with</em> &amp; <em>the statement continues on the following line</em></span>",
  "eol-comment": "! <span style=\"color: gray\"><em>comment</em></span>",
  "multiple-line-comment": "<span style=\"color: gray\"><em>none</em></span>"
},
"var-expr": {
  "case-sensitive": "<span style=\"color: gray\"><em>no; Fortran 77 and earlier required all caps</em></span>",
  "var-types": "integer real complex character logical",
  "var-declaration": "integer :: n<br />real :: x = 3.7<br /><span style=\"color: gray\">! variable declarations must appear before<br />! all other statements in a program or function body</span>",
  "undeclared-var-type": "<span style=\"color: gray\">inferred from first letter of name:<br /><br /><span style=\"white-space: pre-wrap;\">  </span>I-N: integer<br /><span style=\"white-space: pre-wrap;\">  </span>A-H, O-Z: real</span>",
  "primitive-type-stack": "integer::i<br />integer::j = 3",
  "assignment": "i = 3",
  "null": "<span style=\"color: gray\"><em>used for pointers only:</em></span><br />null()",
  "undefined-var-access": "<span style=\"color: gray\"><em>evaluate to 0 or 0.0, depending upon the first letter of the variable name</em></span>"
},
"arithmetic-logic": {
  "boolean-type": "logical",
  "true-false": ".true. .false.",
  "falsehoods": ".false.<br /><span style=\"color: gray\"><em>no implicit conversion of values to booleans</em></span>",
  "logical-op": ".and. .or. .not.",
  "relational-op": "== /= &gt; &lt; &gt;= &lt;=",
  "min-max": "min(1, 2, 3)<br />max(1, 2, 3)",
  "int-type": "integer<br /><br /><span style=\"color: gray\"><em>number of bytes can be specified:</em></span><br />integer(kind=4)",
  "int-literal": "-4",
  "float-type": "real<br />double precision<br /><br /><span style=\"color: gray\"><em>number of bytes can be specified:</em></span><br />real(kind=4)",
  "arith-op": "+ - * /",
  "int-div": "7 / 3<br />mod(7, 3)",
  "int-div-zero": "real :: x = 0.0<br />integer :: i = 0<br /><br /><span style=\"color: gray\">! compiler error:</span><br />1.0 / 0.0<br /><br /><span style=\"color: gray\">! +Infinity:</span><br />1.0 / x<br /><br /><span style=\"color: gray\">! floating point exception:</span><br />1 / i",
  "float-div": "3 / float(7)",
  "float-div-zero": "real :: x = 0.0<br />integer :: i = 0<br /><br /><span style=\"color: gray\">! compiler error:</span><br />1.0 / 0.0<br /><br /><span style=\"color: gray\">! +Infinity:</span><br />1.0 / x<br /><br /><span style=\"color: gray\">! floating point exception:</span><br />1 / i",
  "power": "2.0 ** 3.0",
  "sqrt": "sqrt(2)",
  "sqrt-negative-one": "real :: x = -1.0<br />complex :: z = (-1.0, 0.0)<br /><br /><span style=\"color: gray\">! compiler error:</span><br />sqrt(-1.0)<br /><br /><span style=\"color: gray\">! NaN:</span><br />sqrt(x)<br /><br /><span style=\"color: gray\">! (0.000, 1.000)</span><br />sqrt(z)",
  "transcendental-func": "exp(2.0)<br />log(2.0)<br />log10(2.0)<br />sin(2.0)<br />cos(2.0)<br />tan(2.0)<br />asin(0.5)<br />acos(0.5)<br />atan(0.5)<br />atan2(1.0, 2.0)",
  "transcendental-const": "exp(1.0)<br />2.0 * asin(1.0)",
  "float-truncation": "int(3.7)<br /><span style=\"color: gray\"><em>none</em></span><br />ceiling(3.7)<br />floor(3.7)",
  "absolute-val": "abs(-7)<br />abs(-7.77)",
  "complex-type": "complex<br /><br /><span style=\"color: gray\"><em>uses 8 bytes:</em></span><br />complex(kind=4)",
  "complex-construction": "(0.0, 1.0)<br />(0.0, 2.0)<br />(0.0, 3.0)",
  "complex-decomposition": "real(z)<br />imag(z)<br />atan2(imag(z), real(z))<br />abs(z)<br />conjg(z)",
  "random-num": "real r<br /><span style=\"color: gray\">! random float from 0.0 to 1.0:</span><br />call random_number(r)",
  "random-seed": "integer n<br />integer, allocatable :: seed(:)<br /><br />call random_seed(size=n)<br />allocate(seed(n))<br />do i = 1, n<br /><span style=\"white-space: pre-wrap;\">  </span>seed(i) = i + 2<br />end do<br />call random_seed(put=seed)",
  "bit-op": "<span style=\"color: gray\"><em>right shift if</em> pos <em>is positive:</em></span><br />ishft(<span style=\"color: gray\"><em>i</em>, <em>pos</em></span>)<br />iand(<span style=\"color: gray\"><em>i</em></span>, <span style=\"color: gray\"><em>j</em></span>)<br />ior(<span style=\"color: gray\"><em>i</em></span>, <span style=\"color: gray\"><em>j</em></span>)<br />ieor(<span style=\"color: gray\"><em>i</em></span>, <span style=\"color: gray\"><em>j</em></span>)<br />not(<span style=\"color: gray\"><em>i</em></span>)"
},
"str": {
  "str-type": "characater(len=100) s",
  "str-literal": "'don''t say \"no\"'<br />\"don't say \"\"no\"\"\"",
  "newline-in-str-literal": "\"lorem\" <span style=\"white-space: pre-wrap;\">//</span> achar(10) <span style=\"white-space: pre-wrap;\">//</span> \"ipsum\"",
  "str-literal-esc": "<span style=\"color: gray\"><em>none</em></span>",
  "convert-string-to-numeric": "",
  "convert-numeric-to-string": "",
  "split": "<span style=\"color: gray\"><em>none</em></span>",
  "join<br-/>": "",
  "concatenate": "'hello' <span style=\"white-space: pre-wrap;\">//</span> ' world'",
  "replicate": "character(len=80) :: hbar<br />hbar = repeat('-', 80)",
  "substring": "\"hello\"(1:4)",
  "index": "<span style=\"color: gray\"><em>counts from one, returns zero if not found</em></span><br />index(\"hello\", \"el\")",
  "sprintf": "character(len=100) :: s<br />write(s,'(A A F9.3 I9)') 'foo', ':', 2.2, 7",
  "uppercase": "<span style=\"color: gray\"><em>none</em></span>",
  "lowercase": "<span style=\"color: gray\"><em>none</em></span>",
  "trim": "<span style=\"color: gray\"><em>??</em></span><br />adjustl(' foo')<br />trim('foo ')",
  "length<br-/>": "len(\"hello\")",
  "character-access": "\"hello\"(1:1)",
  "chr-and-ord": "achar(65)<br />iachar('A')"
},
"dates-time": {
  "current-local-date-time": "integer dt(8)<br /><br /><span style=\"color: gray\">! yyyy, mm, dd, utf_offset_min, hh24, mi, ss, ms</span><br />call date_and_time(values=dt)",
  "sleep": "<span style=\"color: gray\">! gnu extension; sleep 10s:</span><br />call sleep(10)",
  "cpu-usage": "real t1, t2<br />call cpu_time(t1)<br /><span style=\"color: gray\"><em>…</em></span><br />call cpu_time(t2)<br />write(*, *) 'elapsed time: ', t2 - t1"
},
"arrays": {
  "allocate-array-on-stack": "<span style=\"color: gray\">! uninitialized values get zero values:</span><br />integer, dimension(3) :: a<br />integer :: a2(3)",
  "allocate-array-on-heap": "<span style=\"color: gray\">! unitialized values get zero values:</span><br />integer, dimension(:), allocatable :: a<br />allocate(a(3))",
  "free-array-on-heap": "<span style=\"color: gray\">! usually not necessary, since memory is freed<br />! when the variable goes out of scope.</span><br />deallocate(a)",
  "array-literal": "integer::a(3) = (/ 1, 2, 3 /)",
  "array-size": "size((/ 1, 2, 3 /))",
  "array-lookup": "<span style=\"color: gray\">! indices start at one</span><br />integer :: a(4)<br />a = (/ 7, 8, 9, 10 /)<br />a(2)",
  "array-update": "a(1) = 8",
  "array-out-of-bounds": "<span style=\"color: gray\"><em>If the array dimensions are set at compilation time (i.e. the array is stack allocated), then the code fails to compile.<br /><br />Out-of-bounds references to arrays with dimensions set at run time (i.e. the array is heap allocated) could segfault or return a memory value outside of the array.</em></span>",
  "array-element-index": "",
  "slice-array": "<span style=\"color: gray\">! can't slice literal</span><br />int::a1(3),a2(2)<br /><br />a1 = (/1,2,3/)<br />a2 = a1(1:2)",
  "slice-array-to-end": "",
  "array-back": "",
  "array-front": "",
  "concatenate-array": "",
  "array-replicate": "",
  "copy-array": "",
  "iterate-over-array": "",
  "sort-array": "",
  "reduce": ""
},
"arith-seq": {
  "arith-seq-diff-one": "",
  "arith-seq-diff-ten": "",
  "arith-seq-diff-tenth": ""
},
"functions": {
  "def-func": "integer function add(n, m)<br /><span style=\"white-space: pre-wrap;\">  </span>integer, intent(in) :: n<br /><span style=\"white-space: pre-wrap;\">  </span>integer, intent(in) :: m<br /><span style=\"white-space: pre-wrap;\">  </span>add = n + m<br />end function add",
  "invoke-func": "add(3, 7)",
  "forward-decl-func": "",
  "overload-func": "",
  "nest-func": "",
  "missing-arg": "<span style=\"color: gray\"><em>set to zero</em></span>",
  "extra-arg": "<span style=\"color: gray\"><em>ignored</em></span>",
  "default-val-param": "real function mylog(x, base)<br /><span style=\"white-space: pre-wrap;\">  </span>real :: x<br /><span style=\"white-space: pre-wrap;\">  </span>real, optional :: base<br /><span style=\"white-space: pre-wrap;\">  </span>if (present(base)) then<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>mylog = log(x) / log(base)<br /><span style=\"white-space: pre-wrap;\">  </span>else<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>mylog = log(x) / log(10.0)<br /><span style=\"white-space: pre-wrap;\">  </span>endif<br />end function mylog",
  "variable-num-arg": "<span style=\"color: gray\"><em>none</em></span>",
  "named-param": "",
  "pass-by-val": "",
  "pass-by-addr": "",
  "pass-by-ref": "",
  "retval": "<span style=\"color: gray\"><em>assign to implicit variable with same name as function; can use return statement to terminate function execution</em></span>",
  "no-retval": "",
  "multiple-retval": "",
  "named-retval": "",
  "anonymous-func-literal": "<span style=\"color: gray\"><em>none</em></span>",
  "func-private-state": "",
  "func-as-val": "<span style=\"color: gray\"><em>none; function pointers added in Fortran 2003</em></span>"
},
"execution-control": {
  "for": "do n = 1, 10, 1<br /><span style=\"white-space: pre-wrap;\">  </span>write(*,*) n<br />end do",
  "if": "if (n == 0) then<br /><span style=\"white-space: pre-wrap;\">  </span>write(*,*) 'no hits'<br />elseif (n == 1) then<br /><span style=\"white-space: pre-wrap;\">  </span>write(*,*) 'one hit'<br />else<br /><span style=\"white-space: pre-wrap;\">  </span>write(*,*) n, 'hits'<br />endif",
  "while": "n = 1<br />do while ( n &lt; 10 )<br /><span style=\"white-space: pre-wrap;\">  </span>write(*,*) n<br /><span style=\"white-space: pre-wrap;\">  </span>n = n + 1<br />end do",
  "switch": "",
  "break-continue": "exit cycle"
},
"file-handles": {
  "std-file-handles": "<span style=\"color: gray\">! common unit identifiers for stdin, stdout, and stderr:</span><br />5 6 0",
  "read-line-stdin": "character(len=100) line<br /><br />read(*, fmt=\"(a)\") line",
  "write-line-stdout": "write(*, *) 'Hello, World!'",
  "printf": "write(6, fmt=\"('count: ', i7)\") 7",
  "open-file": "<span style=\"color: gray\">! the 'unit' integer is the file descriptor. Use an unused<br />! number. The standard file handles 0, 5, and 6 are already taken.</span><br />open(unit=7, file='/etc/passwd', action='read')",
  "open-file-write": "open(unit=7, file='/tmp/foo.txt', action='write')",
  "close-file": "close(7)",
  "io-err": "",
  "read-line": "",
  "file-line-iterate": "",
  "read-file-array": "",
  "read-file-str": "",
  "write-str": "",
  "write-line": "",
  "flush": "",
  "eof-test": "",
  "seek": "",
  "tmp-file": ""
},
"processes-environment": {
  "cmd-line-arg": "character(len=10) :: arg<br />integer arg_len<br /><br />i = 1<br />do while (i &lt;= command_argument_count())<br /><span style=\"white-space: pre-wrap;\">  </span>call get_command_argument(i, arg, arg_len)<br /><span style=\"white-space: pre-wrap;\">  </span>if (arg_len &gt; 10) then<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>write(*,*) 'truncated argument: ', arg<br /><span style=\"white-space: pre-wrap;\">  </span>else<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>write(*,*) 'full argument: ', arg<br /><span style=\"white-space: pre-wrap;\">  </span>endif<br /><span style=\"white-space: pre-wrap;\">  </span>i = i + 1<br />end do",
  "env-var": "character(len=100) :: var<br />integer var_len<br /><br />call get_environment_variable('HOME', var, var_len)<br />if (var_len &gt; 100) then<br /><span style=\"white-space: pre-wrap;\">  </span>write(*,*) 'truncated env var: ', var<br />else<br /><span style=\"white-space: pre-wrap;\">  </span>write(*,*) 'full env var: ', var<br />endif",
  "exit": "stop<br /><br /><span style=\"color: gray\">! nonzero status:</span><br />error stop 1"
},
"vectors": {
  "vector-literal": "<span style=\"color: gray\"><em>same as array</em></span>",
  "element-wise-arithmetic-operators": "+ - * /",
  "result-of-vector-length-mismatch": "<span style=\"color: gray\"><em>compilation error</em></span>",
  "scalar-multiplication": "3 * (/1,2,3/)<br />(/1,2,3/) * 3",
  "dot-product": "dot_product((/1,1,1/),(/2,2,2/))"
},
"matrices": {
  "matrix-literal-or-constructor": "<span style=\"color: gray\">! column-major order:</span><br />integer::A(2,2) = &amp;<br /><span style=\"white-space: pre-wrap;\">  </span>reshape((/ 1, 3, 2, 4 /), &amp;<br /><span style=\"white-space: pre-wrap;\">  </span>(/ 2, 2 /))<br /><br />integer::B(2,2) = &amp;<br /><span style=\"white-space: pre-wrap;\">  </span>reshape((/ 4, 2, 3, 1 /), &amp;<br /><span style=\"white-space: pre-wrap;\">  </span>(/ 2, 2 /))",
  "constant-matrices": "",
  "diagonal-matrices": "",
  "matrix-dim": "",
  "matrix-elem-access": "",
  "matrix-row-access": "",
  "matrix-column-access": "",
  "matrix-scalar-multiplication": "",
  "matrix-elem-wise-op": "",
  "marix-transpose": "",
  "multiplication": "matmul(A, B)",
  "matrix-inverse": ""
}
}
