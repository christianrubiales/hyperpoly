{
"version": {
  "version-used": "<span style=\"color: gray\"><em>7.4</em></span>",
  "version": "$ ghc <span style=\"white-space: pre-wrap;\">--</span>version"
},
"grammar-execution": {
  "interpreter": "$ echo 'main = putStrLn \"hello\"' &gt; hello.hs<br /><br />$ runghc hello.hs",
  "shebang": "$ cat <span style=\"white-space: pre-wrap;\">&lt;&lt;</span>EOF &gt; hello.hs<br />#!/usr/bin/env runghc<br /><br />main = putStrLn \"hello\"<br />EOF<br /><br />$ chmod +x hello.hs<br />$ ./hello.hs",
  "bytecode-compiler-interpreter": "<span style=\"color: gray\"><em>none</em></span>",
  "native-compiler": "$ echo 'main = putStrLn \"hello\"' &gt; hello.hs<br />$ ghc -o hello hello.hs<br />$ ./hello",
  "library-always-imported": "Prelude",
  "statement-terminator": "<span style=\"color: gray\"><em>next line has equal or less indentation, or</em></span> ;",
  "blocks": "<span style=\"color: gray\"><em>offside rule or</em></span> { }",
  "end-of-line-comment": "<span style=\"white-space: pre-wrap;\">--</span> <span style=\"color: gray\"><em>comment</em></span>",
  "multiple-line-comment": "{- <span style=\"color: gray\"><em>comment<br />another comment</em></span> -}"
},
"var-expr": {
  "value": "n = 3",
  "variable": "n &lt;- return 3",
  "unit": "()<br />()",
  "conditional-expression": "n = -3<br />let absn = if n &lt; 0 then -n else n",
  "branch-type-mismatch": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> compilation error:</span><br />if True then \"hello\" else 3",
  "null": "Nothing",
  "nullable-type": "list = [Just(3), Nothing, Just(-4)]",
  "null-test": "",
  "coalesce": "import Data.Maybe<br /><br />let foo = Just(3)<br /><span style=\"color: gray\"><em>raises exception if Nothing:</em></span><br />fromJust foo<br /><br />let intId x = x<br /><span style=\"color: gray\"><em>evaluates to 0 if Nothing:</em></span><br />maybe 0 intId foo",
  "nullif": "",
  "expr-type-declaration": "1 :: Double",
  "let-in": "z = let x = 3.0<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>y = 2.0 * x<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>in x * y",
  "where": "z = x * y<br /><span style=\"white-space: pre-wrap;\">  </span>where x = 3.0<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>y = 2.0 * x"
},
"arithmetic-logic": {
  "boolean-type": "Bool",
  "true-false": "True False",
  "logical-op": "&amp;&amp; <span style=\"white-space: pre-wrap;\">||</span> not",
  "relational-op": "== /= &lt; &gt; &lt;= &gt;=",
  "min-max": "min 1 2<br />max 1 2",
  "int-type": "Integer",
  "int-literal": "an expression, not a literal:<br />-4",
  "float-type": "Double",
  "int-op": "+ - * div rem<br /><span style=\"color: gray\">div <em>and</em> rem <em>are functions, not infix operators</em></span>",
  "float-op": "+ - * /",
  "add-int-float": "3 + 7.0",
  "int-div": "div 7 3<br />rem 7 3",
  "int-div-zero": "<span style=\"color: gray\"><em>Exception: divide by zero</em></span>",
  "float-div": "7 / 3",
  "float-div-zero": "<span style=\"color: gray\"><em>evaluates to</em> Infinity, NaN, <em>or</em> -Infinity, <em>values which do not have literals</em></span>",
  "power": "2 ** 32<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> syntax error if exponent not an integer:</span><br />2 ^ 32",
  "sqrt": "sqrt 2",
  "sqrt-negative-one": "<span style=\"color: gray\">sqrt (-1) <em>evaluates to</em> NaN, <em>a value which has no literal</em></span>",
  "transcendental-func": "exp log<br />sin cos tan<br />asin acos atan<br />atan2",
  "transcendental-const": "pi<br />exp 1",
  "float-truncation": "truncate 3.14<br />round 3.14<br />floor 3.14<br />ceiling 3.14",
  "abs-val": "abs (-7)<br />signum (-7)",
  "int-overflow": "<span style=\"color: gray\"><em>has arbitrary length integers</em></span>",
  "float-overflow": "<span style=\"color: gray\"><em>evaluates to</em> Infinity, <em>a value which has no literal</em></span>",
  "arbitrary-len-int": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> Integer is arbitrary length type:</span><br />let n = 7<br />let m = 12",
  "arbitrary-len-int-op": "n + m<br />n - m<br />n * m<br />div n m<br />mod n m<br /><br />n == m<br />n &lt; m<br />n &lt; m<br />n &lt;= m<br />n &gt;= m",
  "rational-type": "Ratio Integer",
  "rational-construction": "import Data.Ratio<br /><br />1 % 7",
  "rational-decomposition": "import Data.Ratio<br /><br />numerator (1 % 7)<br />denominator (1 % 7)",
  "complex-type": "Complex Double",
  "complex-const": "",
  "complex-op": "",
  "complex-construction": "import Data.Complex<br /><br />1 :+ 2.0",
  "complex-decomposition": "import Data.Complex<br /><br />realPart (1 :+ 2)<br />imagPart (1 :+ 2)<br />phase (1 :+ 2)<br />magnitude (1 :+ 2)<br />conjugate (1 :+ 2)",
  "random-num": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> $ cabal install random</span><br />import System.Random<br /><br />getStdRandom (randomR (0, 99))<br />getStdRandom (randomR (0.0, 1.0))<br /><span style=\"color: gray\"><em>none</em></span>",
  "random-seed": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> $ cabal install random</span><br />import System.Random<br /><br />setStdGen $ mkStdGen 17<br />seed &lt;- getStdGen<br />setStdGen seed",
  "bit-op": "import Data.Bits<br /><br />x = 1 :: Integer<br />y = 3 :: Integer<br /><br />shiftL x 4<br />shiftR x 4<br />x .&amp;. y<br />x .|. y<br />xor x y<br />complement x",
  "binary-octal-hex-literals": "<span style=\"color: gray\"><em>none</em></span><br />052<br />0x2a",
  "radix": ""
},
"str": {
  "str-type": "String",
  "str-literal": "\"Hello, World!\"",
  "newline-in-str-literal": "<span style=\"color: gray\"><em>no</em></span>",
  "str-esc": "\\a \\b \\f \\n \\r \\t \\v \\\" \\&amp; \\' \\\\<br />\\o<span style=\"color: gray\"><em>o<span style=\"white-space: pre-wrap;\">...</span></em></span> \\<span style=\"color: gray\"><em>d<span style=\"white-space: pre-wrap;\">...</span></em></span> \\x<span style=\"color: gray\"><em>h<span style=\"white-space: pre-wrap;\">...</span></em></span><br /><br /><span style=\"color: gray\"><em>Octal, decimal, and hex escapes denote Unicode characters and can contain anywhere from 1 to 7 digits. The max values are \\o4177777, \\1114111, and \\x10ffff. The \\&amp; escape does not represent a character, but can separate a numeric backslash escape sequence from a following digit.</em></span>",
  "format-str": "import Text.Printf<br /><br />printf \"foo %s %d %.2f\" \"bar\" 7 3.1415",
  "str-concat": "\"Hello\" ++ \", \" ++ \"World!\"",
  "str-replicate": "concat ( replicate 80 \"-\" )",
  "translate-case": "import Data.Char<br /><br />map toUpper \"hello\"<br />map toLower \"HELLO\"",
  "capitalize": "",
  "trim": "",
  "pad": "",
  "num-to-str": "\"two: \" ++ (show 2)<br />\"pi: \" ++ (show 3.14)",
  "str-to-num": "7 + (read \"12\")::Integer<br />73.9 + (read \"0.037\")::Double<br /><span style=\"color: gray\"><em>raises exception if string doesn't completely parse</em></span>",
  "join": "",
  "split": "",
  "char-type": "Char",
  "char-literal": "'h'",
  "str-len": "length \"hello\"",
  "index-substr": "",
  "substr": "drop 0 (take 4 \"hello\")",
  "extract-char": "\"hello\" !! 0",
  "chr-ord": "Char.ord 'a'<br />Char.chr 97"
},
"dates-time": {
  "dates-time-types": "ClockTime CalendarTime TimeDiff",
  "current-date-time": "import Time<br /><br />t &lt;- getClockTime",
  "current-unix-epoch": "import System.Time<br /><br />getClockTime <span style=\"white-space: pre-wrap;\">&gt;&gt;</span>= (\\(TOD sec _) -&gt; return sec)"
},
"arrays": {
  "literal": "",
  "size": "",
  "lookup": "",
  "update": "",
  "out-of-bounds": ""
},
"lists": {
  "list-literal": "[1, 2, 3]",
  "empty-list": "[]",
  "empty-list-test": "let list = [1, 2, 3]<br /><br />list == []<br />null list",
  "cons": "1 : [2, 3]",
  "head": "head [1, 2, 3]",
  "tail": "tail [1, 2, 3]",
  "head-tail-empty-list": "<span style=\"color: gray\"><em>exceptions</em></span>",
  "list-length": "length [1, 2, 3]",
  "nth-elem-of-list": "[1, 2, 3] !! 0",
  "list-elem-index": "import Data.list<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> Just 1:</span><br />elemIndex 8 [7, 8, 9]<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> Nothing:</span><br />elemIndex 10 [7, 8, 9]",
  "update-list": "",
  "concat-list": "[1, 2] ++ [3, 4]<br /><br />concat [[1, 2], [3, 4]]",
  "list-last": "last [1, 2, 3]<br />init [1, 2, 3]",
  "list-take": "take 2 [1, 2, 3]",
  "list-drop": "drop 2 [1, 2, 3]",
  "iterate-over-list": "mapM_ print [1, 2, 3]",
  "reverse-list": "reverse [1, 2, 3]",
  "sort-list": "import Data.List<br /><br />sort [1, 3, 2, 4]",
  "map-list": "map (\\x -&gt; x * x) [1, 2, 3]",
  "filter-list": "filter (\\x -&gt; x &gt; 2) [1, 2, 3]",
  "fold-list-left": "foldl (+) 0 [1, 2, 3]",
  "fold-list-right": "foldr (-) 0 [1, 2, 3]",
  "list-member": "elem 3 [1, 2, 3]",
  "universal-test-list": "all (\\x -&gt; x &gt; 2) [1, 2, 3]",
  "existential-test-list": "any (\\x -&gt; x &gt; 2) [1, 2, 3]",
  "zip-list": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> list of tuples:</span><br />zip [1, 2, 3] ['a', 'b', 'c']"
},
"tuples": {
  "tuple-literal": "(1, \"hello\", True)",
  "tuple-lookup": "(\\(a, _, _) -&gt; a) (1, \"hello\", True)",
  "pair-lookup": "fst (12, \"December\")<br />snd (12, \"December\")"
},
"dict": {
},
"func": {
  "def-func": "average a b = (a + b) / 2.0",
  "invoke-func": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> 4.5:</span><br />average 1 2 + 3<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> 3.0:</span><br />average 1 (2 + 3)<br />average 1 $ 2 + 3",
  "named-parameter": "<span style=\"color: gray\"><em>none</em></span>",
  "named-parameter-default-value": "<span style=\"color: gray\"><em>none</em></span>",
  "piecewise-defined-function": "to_s Red = \"red\"<br />to_s Green = \"green\"<br />to_s Blue = \"blue\"",
  "recursive-function": "range a b = if a &gt; b then [] else a : range (a+1) b",
  "mutually-recursive-functions": "",
  "anonymous-function": "\\x y -&gt; (x+y) / 2.0",
  "infix-operator-in-prefix-position": "( * ) 3 4",
  "function-in-infix-position": "add x y = x + y<br />3 ‘add` 4",
  "currying": "plus2 = (+) 2",
  "composition": "f x = x + 2<br />g x = x * 3<br />(f . g ) 4",
  "function-composition-operator": "double x = 2 * x<br />quadruple x = double . double",
  "lazy-evaluation": "<span style=\"color: gray\"><em>lazy evaluation is default:</em></span><br />arg1 x y = x<br /><br />arg1 7 (error \"bam!\")",
  "strict-evaluation": "arg1 x y = seq y x<br /><br />arg1 7 (error \"bam!\")"
},
"exec-control": {
  "if": "if x &gt; 0<br /><span style=\"white-space: pre-wrap;\">  </span>then putStrLn \"pos\"<br /><span style=\"white-space: pre-wrap;\">  </span>else return ()",
  "if-else-if-else": "if x &gt; 0<br /><span style=\"white-space: pre-wrap;\">  </span>then putStrLn \"pos\"<br /><span style=\"white-space: pre-wrap;\">  </span>else if x &lt; 0<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>then putStrLn \"neg\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>else putStrLn \"zero\"",
  "sequencing": "do<br /><span style=\"white-space: pre-wrap;\">  </span>putStrLn \"one\"<br /><span style=\"white-space: pre-wrap;\">  </span>putStrLn \"two\"<br /><span style=\"white-space: pre-wrap;\">  </span>putStrLn \"three\"",
  "while": "",
  "for": "",
  "for-in-reverse": "",
  "list-iteration": "",
  "loop": ""
},
"exceptions": {
  "raise-error": "error \"bam!\"",
  "handle-error": "",
  "type-of-exceptions": "",
  "user-defined-exception": "",
  "standard-exceptions": "",
  "assert": ""
},
"concurrency": {
},
"file-handles": {
  "standard-file-handles": "import System.Posix.IO<br /><br />stdInput stdOutput stdError",
  "read-line-from-stdin": "line &lt;- getLine",
  "end-of-file-behavior": "<span style=\"color: gray\"><em>when last data is returned,</em> hIsEOF <em>will return True. Reading after end-of-file throws an exception.</em></span>",
  "chomp": "",
  "write-line-to-stdout": "putStrLn \"lorem ipsum\"",
  "write-formatted-string-to-stdout": "",
  "open-file-for-reading": "import System.IO<br /><br />f &lt;- openFile \"/etc/hosts\" ReadMode",
  "open-file-for-writing": "import System.IO<br /><br />f &lt;- openFile \"/tmp/test\" WriteMode",
  "open-file-for-appending": "import System.IO<br /><br />f &lt;- openFile \"/tmp/err.log\" AppendMode",
  "close-file": "import System.IO<br /><br />hClose f",
  "i/o-errors": "",
  "read-line": "import IO<br /><br />readAndPrintLines h = do<br /><span style=\"white-space: pre-wrap;\">  </span>eof &lt;- hIsEOF h<br /><span style=\"white-space: pre-wrap;\">  </span>if eof<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>then return ()<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>else do<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>line &lt;- hGetLine h<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>putStrLn line<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>readAndPrintLines h<br /><br />main = do<br /><span style=\"white-space: pre-wrap;\">  </span>h &lt;- openFile \"/etc/passwd\" ReadMode<br /><span style=\"white-space: pre-wrap;\">  </span>readAndPrintLines h",
  "iterate-over-file-by-line": "",
  "read-file-into-array-of-strings": "",
  "read-file-into-string": "",
  "write-string": "",
  "write-line": "s = \"hello out\\n\"<br />f = \"/tmp/test-haskell\"<br />main = writeFile f s",
  "flush-file-handle": "",
  "end-of-file-test": "",
  "get-and-set-filehandle-position": ""
},
"file": {
  "file-test,-regular-file-test": "import System<br /><br />Directory.doesFileExist \"/etc/hosts\"<br /><br />import Control.Monad<br />import System.Posix.Files<br /><br />liftM isRegularFile (getFileStatus \"/etc/hosts\")",
  "file-size": "import Control.Monad<br />import System.Posix.Files<br /><br />liftM fileSize (getFileStatus \"/etc/hosts\")",
  "is-file-readable,-writable,-executable": "import Control.Monad<br /><br />liftM readable<br /><span style=\"white-space: pre-wrap;\">  </span>(getPermissions \"/etc/hosts\")<br />liftM writable<br /><span style=\"white-space: pre-wrap;\">  </span>(getPermissions \"/etc/hosts\")<br />liftM executable<br /><span style=\"white-space: pre-wrap;\">  </span>(getPermissions \"/etc/hosts\")",
  "set-file-permissions": "import System.Posix.Files<br /><br />setFileMode \"/tmp/foo\" ownerModes<br />setFileMode \"/tmp/foo\" groupReadMode<br />setFileMode \"/tmp/foo\" groupExecuteMode<br />setFileMode \"/tmp/foo\" otherReadMode<br />setFileMode \"/tmp/foo\" otherExecuteMode",
  "copy-file,-remove-file,-rename-file": "import System.Directory<br /><br />copyFile \"/tmp/foo\" \"/tmp/bar\"<br />removeFile \"/tmp/foo\"<br />renameFile \"/tmp/bar\" \"/tmp/foo\"",
  "create-symlink,-symlink-test,-readlink": "import System.Posix.Files<br /><br />createSymbolicLink \"/etc/hosts\" \"/tmp/hosts\"<br /><span style=\"color: gray\"><em>??</em></span><br />readSymbolicLink \"/tmp/hosts\"",
  "generate-unused-file-name": ""
},
"dir": {
  "build-pathname": "import System.FilePath ((&lt;/&gt;))<br /><br />let path = \"/etc\" &lt;/&gt; \"hosts\"",
  "dirname-and-basename": "import System.FilePath<br /><br />takeFileName \"/etc/hosts\"<br />takeDirectory \"/etc/hosts\"",
  "iterate-over-directory-by-file": "import System<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> returns IO [FilePath]</span><br />Directory.getDirectoryContents \"/etc\"",
  "make-directory": "import System.Directory<br /><br />createDirectoryIfMissing True<br /><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/foo/bar\"",
  "remove-empty-directory": "import System.Directory<br /><br />removeDirectory \"/tmp/foodir\"",
  "remove-directory-and-contents": "import System.Directory<br /><br />removeDirectoryRecursive \"/tmp/foodir\"",
  "directory-test": "import System<br /><br />Directory.doesDirectoryExist \"/tmp\"",
  "temporary-directory": ""
},
"processes-environment": {
  "command-line-arguments": "import System<br /><br />printArgs args = do<br /><span style=\"white-space: pre-wrap;\">  </span>if length args == 0<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>then return ()<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>else do<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>putStrLn (head args)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>printArgs (tail args)<br />main = do<br /><span style=\"white-space: pre-wrap;\">  </span>a &lt;- getArgs<br /><span style=\"white-space: pre-wrap;\">  </span>printArgs a",
  "program-name": "import System<br /><br />s &lt;- getProgName",
  "getopt": "",
  "env-var": "import System.Posix.Env<br /><br />s &lt;- getEnv \"HOME\"<br />putEnv \"PATH=/bin\"",
  "pid": "import System.Posix.Process<br /><br />pid &lt;- getProcessID<br />ppid &lt;- getParentProcessID",
  "user-id-name": "import System.Posix.User<br /><br />uid &lt;- getRealUserID<br />username &lt;- getLoginName",
  "exit": "import System.Exit<br /><br />exitWith ExitSuccess<br /><br /><span style=\"color: gray\"><em>to return nonzero status:</em></span><br />exitWith (ExitFailure 1)",
  "signal-handler": "",
  "external-cmd": "import System.Cmd<br /><br />rawSystem \"ls\" [\"-l\", \"/tmp\"]",
  "escaped-external-cmd": "",
  "backticks": ""
},
"lib-namespaces": {
  "namespace-example": "<span style=\"color: gray\"><em>Foo/Bar.hs</em></span><br />module Foo.Bar where<br /><span style=\"white-space: pre-wrap;\">  </span>data Baz = Baz<br /><span style=\"white-space: pre-wrap;\">  </span>say Baz = putStrLn \"hello\"<br /><br /><span style=\"color: gray\"><em>Main.hs</em></span><br />module Main where<br />import Foo.Bar<br />baz = Baz<br />main = say baz<br /><br /><span style=\"color: gray\"><em>to compile and run</em></span><br />$ ghc -c Foo/Bar.hs<br />$ ghc Main.hs<br />$ ./Main<br />hello",
  "namespaces": "values, constructors, type variables, type constructors, type classes, modules",
  "file-name-restrictions": "<span style=\"color: gray\"><em>module</em> Foo.Bar <em>must be in</em> Foo/Bar.hs</span>",
  "namespace": "import Data.Bytestring",
  "namespace-creation": "",
  "namespace-alias": "import qualified Data.Bytestring as B",
  "namespace-separator": ".",
  "subnamespace": "",
  "pkg-manager-setup": "",
  "pkg-manager": "$ cabal list parsec<br />$ cabal install parsec<br />$ cabal list <span style=\"white-space: pre-wrap;\">--</span>installed",
  "pkg-compile": ""
},
"user-defined-types": {
  "type-synonym": "type Name = String",
  "sum-type": "data Color = Red | Green | Blue<br /><br />col = Red<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">--</span> this won’t compile:</span><br />col &lt; Green",
  "tuple-product-type-with-one-field": "data SpecialIntType = SpecialInt Integer<br /><br />n = SpecialInt 7",
  "tuple-product-type-with-two-fields": "data IntPairType = IntPair Integer Integer<br /><br />p = IntPair 7 11",
  "record-product-type": "data CustomerType = Customer {<br /><span style=\"white-space: pre-wrap;\">  </span>customerId :: Integer,<br /><span style=\"white-space: pre-wrap;\">  </span>name :: String,<br /><span style=\"white-space: pre-wrap;\">  </span>address :: String<br />}",
  "record-product-type-literal": "Customer {<br /><span style=\"white-space: pre-wrap;\">  </span>customerId=7,<br /><span style=\"white-space: pre-wrap;\">  </span>name=\"John\",<br /><span style=\"white-space: pre-wrap;\">  </span>address=\"Topeka, KS\" }",
  "generic-type": "data TwosomeType a b = Twosome a b<br /><br />p = Twosome (\"pi\", 3.14)",
  "recursive-type": "data BinaryTree = Leaf Integer | Tree BinaryTree BinaryTree",
  "pattern-match-sum-type": "c = Red<br />case c of Red -&gt; \"red\"<br /><span style=\"white-space: pre-wrap;\">  </span>Green -&gt; \"green\"<br /><span style=\"white-space: pre-wrap;\">  </span>Blue -&gt; \"blue\"",
  "pattern-match-product-type": "",
  "pattern-match-guard": "<span style=\"color: gray\"><em>none, use if or piecewise function definition</em></span>",
  "pattern-match-catchall": "c = Green<br />case c of Red -&gt; \"red\"; _ -&gt; \"not red\""
},
"objects": {
  "class-definition": "",
  "object-creation": "",
  "method-invocation": "",
  "field-access": ""
},
"inheritance-polymorphism": {
  "overload-function": "",
  "inheritance": ""
},
"net-web": {
},
"unit-tests": {
},
"debug-profile": {
},
"repl": {
  "invoke-repl": "$ ghci",
  "repl-limitations": "<span style=\"color: gray\"><em>Must use let to define values and functions; when defining functions with multiple equations the equations must be separated by semicolons; the clauses of case/of statements must be separated by semicolons; it is not possible to define data types.</em></span>",
  "repl-last-value": "it",
  "help": ":?",
  "quit": "",
  "inspect-type": "let a = 3<br />:type a",
  "inspect-namespace": "",
  "load-source-file": ":edit hello.hs<br />:load hello",
  "load-package": "",
  "search-path": "",
  "set-search-path-on-command-line": ""
}
}
