{

"version": {
  "version-used": "<span style=\"color: gray\"><em>5.18</em></span>",
  "show-version": "$ perl <span style=\"white-space: pre-wrap;\">--</span>version",
  "implicit-prologue": "use strict;"
},
"grammar-execution": {
  "interpreter": "$ perl foo.p",
  "repl": "$ perl -de 0",
  "cmd-line-program": "$ perl -e 'print(\"hi\\n\")'",
  "block-delimiters": "{}",
  "stmt-separator": ";",
  "expr-stmt": "",
  "source-code-encoding": "use utf8;",
  "eol-comment": "<span style=\"color: gray\"># comment</span>",
  "multiple-line-comment": "<span style=\"color: gray\">=for<br />comment line<br />another line<br />=cut</span>"
},
"var-expr": {
  "local-var": "my $v;<br />my (@a, %d);<br />my $x = 1;<br />my ($y, $z) = (2, 3);",
  "local-scope-region": "top level:<br /><span style=\"white-space: pre-wrap;\">  </span>file<br /><br />nestable:<br /><span style=\"white-space: pre-wrap;\">  </span>function body<br /><span style=\"white-space: pre-wrap;\">  </span>anonymous function body<br /><span style=\"white-space: pre-wrap;\">  </span>anonymous block",
  "global-var": "our ($g1, $g2) = (7, 8);<br /><br />sub swap_globals {<br /><span style=\"white-space: pre-wrap;\">  </span>($g1, $g2) = ($g2, $g1);<br />}",
  "const": "use constant PI =&gt; 3.14;",
  "assignment": "$v = 1;",
  "parallel-assignment": "($x, $y, $z) = (1, 2, 3);<br /><br /><span style=\"color: gray\"># 3 is discarded:</span><br />($x, $y) = (1, 2, 3);<br /><br /><span style=\"color: gray\"># $z set to undef:</span><br />($x, $y, $z) = (1, 2);",
  "swap": "($x, $y) = ($y, $x);",
  "compound-assignment": "+= -= *= /= %= **=<br />.= x=<br />&amp;&amp;= <span style=\"white-space: pre-wrap;\">||=</span> ^=<br /><span style=\"white-space: pre-wrap;\">&lt;&lt;= &gt;&gt;=</span> &amp;= |= ^=",
  "incr-decr": "my $x = 1;<br />my $y = ++$x;<br />my $z = <span style=\"white-space: pre-wrap;\">--</span>$y;",
  "null": "undef",
  "null-test": "! defined $v",
  "undef-var": "<span style=\"color: gray\"><em>error under</em> use strict; <em>otherwise</em> undef</span>",
  "conditional-expr": "$x &gt; 0 ? $x : -$x"
},
"arithmetic-logic": {
  "true-false": "1 \"\"",
  "falsehoods": "undef 0 0.0 \"\" \"0\" ()",
  "logical-op": "<span style=\"white-space: pre-wrap;\">&amp;&amp; ||</span> !<br /><span style=\"color: gray\"><em>lower precedence:</em></span><br />and or xor not",
  "relational-expr": "<span style=\"color: gray\"><em>numbers:</em></span> == != &gt; &lt; &gt;= &lt;=<br /><span style=\"color: gray\"><em>strings:</em></span> eq ne gt lt ge le",
  "relational-op": "",
  "min-max": "use List::Util qw(min max);<br /><br />min(1, 2, 3);<br />max(1, 2, 3);<br /><br />@a = (1, 2, 3);<br />min(@a);<br />max(@a);",
  "three-val-comparison": "0 &lt;=&gt; 1<br />\"do\" cmp \"re\"",
  "arith-expr": "+ - * / <span style=\"color: gray\"><em>none</em></span> %",
  "arith-op": "",
  "int-div": "int(13 / 5)",
  "int-div-zero": "<span style=\"color: gray\"><em>error</em></span>",
  "float-div": "13 / 5",
  "float-div-zero": "<span style=\"color: gray\"><em>error</em></span>",
  "power": "2 <span style=\"white-space: pre-wrap;\">**</span> 32",
  "sqrt": "sqrt(2)",
  "sqrt-negative-one": "<span style=\"color: gray\"><em>error unless</em> use Math::Complex <em>in effect</em></span>",
  "transcendental-func": "use Math::Trig qw(tan asin acos atan);<br /><br />exp log sin cos tan asin acos atan atan2",
  "transcendental-const": "",
  "float-truncation": "<span style=\"color: gray\"># cpan -i Number::Format</span><br />use Number::Format 'round';<br />use POSIX qw(ceil floor);<br /><br />int($x)<br />round($x, 0)<br />ceil($x)<br />floor($x)",
  "absolute-val": "abs($x)",
  "int-overflow": "<span style=\"color: gray\"><em>converted to float;</em> use Math::BigInt <em>to create arbitrary length integers</em></span>",
  "float-overflow": "inf",
  "rational-construction": "use Math::BigRat;<br /><br />my $x = Math::BigRat-&gt;new(\"22/7\");",
  "rational-decomposition": "$x-&gt;numerator();<br />$x-&gt;denominator();",
  "complex-construction": "use Math::Complex;<br /><br />my $z = 1 + 1.414 * i;",
  "complex-decomposition": "Re($z);<br />Im($z);<br />arg($z);<br />abs($z);<br />~$z;",
  "random-num": "int(rand() * 100)<br />rand()<br /><span style=\"color: gray\"><em>none</em></span>",
  "random-seed": "srand 17;<br /><br />my $seed = srand;<br />srand($seed);",
  "bit-op": "<span style=\"white-space: pre-wrap;\">&lt;&lt; &gt;&gt; &amp; | ^ ~</span>",
  "binary-oct-hex-literals": "0b101010<br />052<br />0x2a",
  "radix": "<span style=\"color: gray\"># cpan -i Math::BaseCalc</span><br />use Math::BaseCalc;<br /><br />$c = new Math::BaseCalc(<br /><span style=\"white-space: pre-wrap;\">  </span>digits =&gt; [0..6]);<br />$c-&gt;to_base(42);<br />$c-&gt;from_base(\"60\");"
},
"str": {
  "str-literal": "\"don't say \\\"no\\\"\"<br />'don\\'t say \"no\"'",
  "str-literal-newline": "'first line<br />second line'<br /><br />\"first line<br />second line\"",
  "char-esc": "<span style=\"color: gray\"><em>double quoted:</em></span><br />\\a \\b \\cx \\e \\f \\n \\r \\t \\xhh \\x{hhhh} \\ooo \\o{ooo}<br /><br /><span style=\"color: gray\"><em>single quoted:</em></span><br />\\' \\\\",
  "here-doc": "$word = \"amet\";<br /><br />$s = «EOF;<br />lorem ipsum<br />dolor sit $word<br />EOF",
  "var-interpolation": "my $count = 3;<br />my $item = \"ball\";<br />print \"$count ${item}s\\n\";",
  "expr-interpolation": "<span style=\"color: gray\"><em>none</em></span>",
  "str-concat": "my $s = \"Hello, \";<br />my $s2 = $s . \"World!\";",
  "str-replicate": "my $hbar = \"-\" x 80;",
  "sprintf": "my $fmt = \"lorem %s %d %f\";<br />sprintf($fmt, \"ipsum\", 13, 3.7)",
  "case": "uc(\"lorem\")<br />lc(\"LOREM\")",
  "capitalize": "<span style=\"color: gray\"># cpan -i Text::Autoformat</span><br />use Text::Autoformat;<br /><br />ucfirst(\"lorem\")<br />autoformat(\"lorem ipsum\",<br /><span style=\"white-space: pre-wrap;\">  </span>{case =&gt; 'title'})",
  "trim": "<span style=\"color: gray\"># cpan -i Text::Trim</span><br />use Text::Trim;<br /><br />trim \" lorem \"<br />ltrim \" lorem\"<br />rtrim \"lorem \"",
  "pad": "<span style=\"color: gray\"># cpan -i Text::Format</span><br />use Text::Format;<br /><br />sprintf(\"%-10s\", \"lorem\")<br />sprintf(\"%10s\", \"lorem\")<br /><br />$text = Text::Format-&gt;new(columns =&gt; 10);<br />$text-&gt;center(\"lorem\");",
  "str-to-num": "7 + \"12\"<br />73.9 + \".037\"",
  "num-to-str": "\"value: \" . 8",
  "join": "join(\" \", qw(do re mi fa))",
  "split": "split(/\\s+/, \"do re mi fa\")",
  "split-in-two": "split(/\\s+/, \"do re mi fa\", 2)",
  "split-keep-delimiters": "split(/(\\s+)/, \"do re mi fa\")",
  "str-length": "length(\"lorem\")",
  "index-substr": "<span style=\"color: gray\"># returns -1 if not found:</span><br />index(\"lorem ipsum\", \"ipsum\")<br />rindex(\"do re re\", \"re\")",
  "extract-substr": "substr(\"lorem ipsum\", 6, 5)",
  "lookup-char": "<span style=\"color: gray\"># can't use index notation with<br /># strings:</span><br />substr(\"lorem ipsum\", 6, 1)",
  "chr-ord": "chr(65)<br />ord(\"A\")",
  "str-to-char-array": "split(<span style=\"white-space: pre-wrap;\">//</span>, \"abcd\")",
  "translate-char": "$s = \"hello\";<br />$s =~ tr/a-z/n-za-m/;",
  "delete-char": "$s = \"disemvowel me\";<br />$s =~ tr/aeiou<span style=\"white-space: pre-wrap;\">//</span>d;",
  "squeeze-char": "$s = \"too much space\";<br />$s =~ tr/ <span style=\"white-space: pre-wrap;\">//</span>s;"
},
"regex": {
  "regex-literal": "/lorem|ipsum/<br />qr(/etc/hosts)",
  "char-class-abbrev": ". \\d \\D \\h \\H \\s \\S \\v \\V \\w \\W",
  "regex-anchors": "^ $ \\A \\b \\B \\z \\Z",
  "regex-match": "if ($s =~ /1999/) {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"party!\\n\";<br />}",
  "case-insensitive-regex": "\"Lorem\" =~ /lorem/i",
  "regex-modifiers": "i m s p x",
  "subst": "my $s = \"do re mi mi mi\";<br />$s =~ s/mi/ma/g;",
  "match-prematch-postmatch": "f ($s =~ /\\d{4}/p) {<br /><span style=\"white-space: pre-wrap;\">  </span>$match = ${^MATCH};<br /><span style=\"white-space: pre-wrap;\">  </span>$prematch = ${^PREMATCH};<br /><span style=\"white-space: pre-wrap;\">  </span>$postmatch = ${^POSTMATCH};<br />}",
  "group-capture": "$rx = qr/(\\d{4})-(\\d{2})-(\\d{2})/;<br />\"2010-06-03\" =~ $rx;<br />($yr, $mo, $dy) = ($1, $2, $3);",
  "named-group-capture": "$s = \"foo.txt\";<br />$s =~ /^(?&lt;file&gt;.+)\\.(?&lt;suffix&gt;.+)$/;<br /><br />$+{\"file\"}<br />$+{\"suffix\"}",
  "scan": "my $s = \"dolor sit amet\";<br />@a = $s =~ m/\\w+/g;",
  "backreference": "\"do do\" =~ /(\\w+) \\1/<br /><br />my $s = \"do re\";<br />$s =~ s/(\\w+) (\\w+)/$2 $1/;",
  "recursive-regex": "/\\(([^()]*|(?R))\\)/"
},
"dates-time": {
  "date-time-type": "<span style=\"color: gray\">Time::Piece <em>if</em> use Time::Piece <em>in effect, otherwise tm array</em></span>",
  "current-date-time": "use Time::Piece;<br /><br />my $t = localtime(time);<br />my $utc = gmtime(time);",
  "unix-epoch": "use Time::Local;<br />use Time::Piece;<br /><br />my $epoch = timelocal($t);<br />my $t2 = localtime(1304442000);",
  "current-unix-epoch": "$epoch = time;",
  "strftime": "use Time::Piece;<br /><br />$t = localtime(time);<br />$fmt = \"%Y-%m-%d %H:%M:%S\";<br />print $t-&gt;strftime($fmt);",
  "strptime": "use Time::Local;<br />use Time::Piece;<br /><br />$s = \"2011-05-03 10:00:00\";<br />$fmt = \"%Y-%m-%d %H:%M:%S\";<br />$t = Time::Piece-&gt;strptime($s,$fmt);",
  "parse-date": "<span style=\"color: gray\"># cpan -i Date::Parse</span><br />use Date::Parse;<br /><br />$epoch = str2time(\"July 7, 1999\");",
  "get-date-parts": "$t-&gt;year<br />$t-&gt;mon<br />$t-&gt;mday",
  "get-time-parts": "$t-&gt;hour<br />$t-&gt;min<br />$t-&gt;sec",
  "date-from-parts": "$dt = DateTime-&gt;new(<br /><span style=\"white-space: pre-wrap;\">  </span>year=&gt;2014,<br /><span style=\"white-space: pre-wrap;\">  </span>month=&gt;4,<br /><span style=\"white-space: pre-wrap;\">  </span>day=&gt;1,<br /><span style=\"white-space: pre-wrap;\">  </span>hour=&gt;10,<br /><span style=\"white-space: pre-wrap;\">  </span>minute=&gt;3,<br /><span style=\"white-space: pre-wrap;\">  </span>second=&gt;56);",
  "date-subtraction": "<span style=\"color: gray\">Time::Seconds <em>object if</em> use Time::Piece <em>in effect; not meaningful to subtract tm arrays</em></span>",
  "add-time-duration": "use Time::Seconds;<br /><br />$now = localtime(time);<br />$now += 10 * ONE_MINUTE() + 3;",
  "local-tmz": "<span style=\"color: gray\">Time::Piece <em>has local timezone if created with localtime and UTC timezone if created with gmtime; tm arrays have no timezone or offset info</em></span>",
  "tmz-offset": "<span style=\"color: gray\"># cpan -i DateTime</span><br />use DateTime;<br />use DateTime::TimeZone;<br /><br />$dt = DateTime-&gt;now();<br />$tz = DateTime::TimeZone-&gt;new(<br /><span style=\"white-space: pre-wrap;\">  </span>name=&gt;\"local\");<br /><br />$tz-&gt;name;<br />$tz-&gt;offset_for_datetime($dt) /<br /><span style=\"white-space: pre-wrap;\">  </span>3600;<br />$tz-&gt;is_dst_for_datetime($dt);",
  "microseconds": "use Time::HiRes qw(gettimeofday);<br /><br />($sec, $usec) = gettimeofday;",
  "sleep": "<span style=\"color: gray\"># a float argument will be truncated<br /># to an integer:</span><br />sleep 1;",
  "timeout": "eval {<br /><span style=\"white-space: pre-wrap;\">  </span>$SIG{ALRM}= sub {die \"timeout!\";};<br /><span style=\"white-space: pre-wrap;\">  </span>alarm 5;<br /><span style=\"white-space: pre-wrap;\">  </span>sleep 10;<br />};<br />alarm 0;"
},
"arrays": {
  "array-literal": "@a = (1, 2, 3, 4);",
  "quote-words": "@a = qw(do re mi);",
  "array-size": "$#a + 1<br />scalar(@a)",
  "array-lookup": "$a[0]<br /><br /><span style=\"color: gray\"># returns last element:</span><br />$a[-1]",
  "array-update": "$a[0] = \"lorem\";",
  "array-out-of-bounds": "@a = ();<br /><span style=\"color: gray\"># evaluates as undef:</span><br />$a[10];<br /><span style=\"color: gray\"># increases array size to 11:</span><br />$a[10] = \"lorem\";",
  "array-element-index": "use List::Util 'first';<br /><br />@a = qw(x y z w);<br />$i = first {$a[$_] eq \"y\"} (0..$#a);",
  "array-slice": "<span style=\"color: gray\"># select 3rd and 4th elements:</span><br />@a[2..3]<br />splice(@a, 2, 2)",
  "array-slice-to-end": "@a[1..$#a]",
  "array-back": "@a = (6, 7, 8);<br />push @a, 9;<br />pop @a;",
  "array-front": "@a = (6, 7, 8);<br />unshift @a, 5;<br />shift @a;",
  "array-concat": "@a = (1, 2, 3);<br />@a2 = (@a, (4, 5, 6));<br />push @a, (4,5,6);",
  "array-replicate": "@a = (undef) x 10;",
  "array-copy": "use Storable 'dclone'<br /><br />my @a = (1,2,[3,4]);<br />my $a2 = \\@a;<br />my @a3 = @a;<br />my @a4 = @{dclone(\\@a)};",
  "array-arg": "<span style=\"color: gray\"><em>each element passed as separate argument; use reference to pass array as single argument</em></span>",
  "array-iter": "for $i (1, 2, 3) { print \"$i\\n\" }",
  "range-iteration": "for $i (1..1_000_000) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><em>code</em></span><br />}",
  "range-array": "@a = 1..10;",
  "array-reverse": "@a = (1, 2, 3);<br /><br />reverse @a;<br />@a = reverse @a;",
  "array-sort": "@a = qw(b A a B);<br /><br />sort @a;<br />@a = sort @a;<br />sort { lc($a) cmp lc($b) } @a;",
  "array-dedupe": "use List::MoreUtils 'uniq';<br /><br />my @a = (1, 2, 2, 3);<br /><br />my @a2 = uniq @a;<br />@a = uniq @a;",
  "membership": "7 ~~ @a",
  "intersection": "",
  "union": "",
  "set-diff": "",
  "map": "map { $_ * $_ } (1,2,3)",
  "filter": "grep { $_ &gt; 1 } (1,2,3)",
  "reduce": "use List::Util 'reduce';<br /><br />reduce { $x + $y } 0, (1,2,3)",
  "universal-existential-test": "<span style=\"color: gray\"># cpan -i List::MoreUtils</span><br />use List::MoreUtils qw(all any);<br /><br />all { $_ % 2 == 0 } (1, 2, 3, 4)<br />any { $_ % 2 == 0 } (1, 2, 3, 4)",
  "shuffle": "use List::Util 'shuffle';<br /><br />@a = (1, 2, 3, 4);<br />shuffle(@a);",
  "zip": "<span style=\"color: gray\"># cpan -i List::MoreUtils</span><br />use List::MoreUtils 'zip';<br /><br />@nums = (1, 2, 3);<br />@lets = qw(a b c);<br /><span style=\"color: gray\"># flat array of 6 elements:</span><br />@a = zip @nums, @lets;"
},
"dict": {
  "dict-literal": "%d = ( \"t\" =&gt; 1, \"f\" =&gt; 0 );<br /><br /><span style=\"color: gray\"># barewords permitted in front of =&gt;<br /># under 'use strict'</span>",
  "dict-size": "scalar(keys %d)",
  "dict-lookup": "$d{\"t\"}<br /><br /><span style=\"color: gray\"># barewords permitted inside { }<br /># under 'use strict'</span>",
  "dict-update": "",
  "dict-out-of-bounds": "%d = ();<br /><span style=\"color: gray\"># evaluates as undef:</span><br />$d{\"lorem\"};<br /><span style=\"color: gray\"># adds key/value pair:</span><br />$d{\"lorem\"} = \"ipsum\";",
  "dict-key-check": "exists $d{\"y\"}",
  "dict-delete": "%d = ( 1 =&gt; \"t\", 0 =&gt; \"f\" );<br />delete $d{1};",
  "dict-assoc-array": "@a = (1,\"a\",2,\"b\",3,\"c\");<br />%d = @a;",
  "dict-merge": "%d1 = (a =&gt; 1, b =&gt; 2);<br />%d2 = (b =&gt; 3, c =&gt; 4);<br />%d1 = (%d1, %d2);",
  "dict-invert": "%to_num = (t=&gt;1, f=&gt;0);<br />%to_let = reverse %to_num;",
  "dict-iter": "while (($k, $v) = each %d) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><em>code</em></span><br />}",
  "dict-key-val-array": "keys %d<br />values %d",
  "dict-sort-val": "foreach $k (sort<br /><span style=\"white-space: pre-wrap;\">  </span>{ $d{$a} &lt;=&gt; $d{$b} } keys %d) {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"$k: $d{$k}\\n\";<br />}",
  "dict-default-val": "my %counts;<br />$counts{'foo'} += 1<br /><br /><span style=\"color: gray\"><em>define a tied hash for computed values and defaults other than zero or empty string</em></span>"
},
"func": {
  "func-def": "sub add3 { $_[0] + $_[1] + $_[2] }<br /><br />sub add3 {<br /><span style=\"white-space: pre-wrap;\">  </span>my ($x1, $x2, $x3) = @_;<br /><span style=\"white-space: pre-wrap;\">  </span>$x1 + $x2 + $x3;<br />}",
  "func-invocation": "add3(1, 2, 3);<br /><br /><span style=\"color: gray\"># parens are optional:</span><br />add3 1, 2, 3;",
  "nested-func": "<span style=\"color: gray\"><em>defined when containing function is defined; visible outside containing function</em></span>",
  "missing-arg": "<span style=\"color: gray\"><em>set to</em> undef</span>",
  "extra-arg": "",
  "default-arg": "sub my_log {<br /><span style=\"white-space: pre-wrap;\">  </span>my $x = shift;<br /><span style=\"white-space: pre-wrap;\">  </span>my $base = shift // 10;<br /><br /><span style=\"white-space: pre-wrap;\">  </span>log($x) / log($base);<br />}<br /><br />my_log(42);<br />my_log(42, exp(1));",
  "var-arg": "sub first_and_last {<br /><br /><span style=\"white-space: pre-wrap;\">  </span>if ( @_ &gt;= 1 ) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>print \"first: $_[0]\\n\";<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br /><span style=\"white-space: pre-wrap;\">  </span>if ( @_ &gt;= 2 ) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>print \"last: $_[-1]\\n\";<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "apply-func": "@a = (2, 3);<br /><br />add3(1, @a);<br /><br /><span style=\"color: gray\"># arrays are always expanded when used<br /># as arguments</span>",
  "retval": "<span style=\"color: gray\">return <em>arg or last expression evaluated</em></span>",
  "multiple-retval": "sub first_and_second {<br /><span style=\"white-space: pre-wrap;\">  </span>return ($_[0], $_[1]);<br />}<br /><br />@a = (1,2,3);<br />($x, $y) = first_and_second(@a);",
  "lambda-decl": "$sqr = sub { $_[0] * $_[0] }",
  "lambda-invocation": "$sqr-&gt;(2)",
  "func-as-val": "my $func = \\&amp;add;",
  "private-state-func": "use feature state;<br /><br />sub counter {<br /><span style=\"white-space: pre-wrap;\">  </span>state $i = 0;<br /><span style=\"white-space: pre-wrap;\">  </span>++$i;<br />}<br /><br />print counter() . \"\\n\";",
  "closure": "sub make_counter {<br /><span style=\"white-space: pre-wrap;\">  </span>my $i = 0;<br /><span style=\"white-space: pre-wrap;\">  </span>return sub { ++$i };<br />}<br /><br />my $nays = make_counter;<br />print $nays-&gt;() . \"\\n\";",
  "generator": ""
},
"exec-control": {
  "if": "if ( 0 == $n ) {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"no hits\\n\"<br />} elsif ( 1 == $n ) {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"one hit\\n\"<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"$n hits\\n\"<br />}",
  "while": "while ( $i &lt; 100 ) { $i++ }",
  "break-continue": "last next",
  "for": "for ( $i=0; $i &lt;= 10; $i++ ) {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"$i\\n\";<br />}",
  "stmt-modifiers": "print \"positive\\n\" if $i &gt; 0;<br />print \"nonzero\\n\" unless $i == 0;"
},
"exceptions": {
  "raise-exc": "die \"bad arg\";",
  "catch-exc": "eval { risky };<br />if ($@) {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"risky failed: $@\\n\";<br />}",
  "last-exc-global": "<span style=\"color: gray\">$EVAL_ERROR: $@<br />$OS_ERROR: $!<br />$CHILD_ERROR: $?</span>",
  "finally-ensure": "",
  "uncaught-exc": ""
},
"streams": {
  "standard-file-handles": "STDIN STDOUT STDERR",
  "read-stdin": "$line = &lt;STDIN&gt;;",
  "eof": "<span style=\"color: gray\"><em>returns string without newline or</em> undef</span>",
  "chomp": "chomp $line;",
  "print-to-stdout": "print \"Hello, World!\\n\";",
  "printf": "use Math::Trig 'pi';<br /><br />printf(\"%.2f\\n\", pi);",
  "open-file": "open my $f, \"/etc/hosts\" or die;",
  "open-file-write": "open my $f, \"&gt;/tmp/test\" or die;",
  "file-encoding": "open my $fin, \"&lt;:encoding(UTF-8)\", \"/tmp/foo\"<br /><span style=\"white-space: pre-wrap;\">  </span>or die;<br /><br />open my $fout, \"&gt;:encoding(UTF-8)\", \"/tmp/bar\"<br /><span style=\"white-space: pre-wrap;\">  </span>or die;",
  "open-file-append": "open my $f, \"<span style=\"white-space: pre-wrap;\">&gt;&gt;</span>/tmp/err.log\" or die;",
  "close-file": "close $f or die;",
  "close-file-implicitly": "{<br /><span style=\"white-space: pre-wrap;\">  </span>open(my $f, \"&gt;/tmp/test\") or die;<br /><span style=\"white-space: pre-wrap;\">  </span>print $f \"lorem ipsum\\n\";<br />}",
  "io-err": "<span style=\"color: gray\"><em>return false value</em></span>",
  "encoding-err": "<span style=\"color: gray\"><em>emit warning and replace bad byte with 4 character \\xHH sequence</em></span>",
  "read-line": "$line = &lt;$f&gt;;",
  "file-iter": "while ($line = &lt;$f&gt;) {<br /><span style=\"white-space: pre-wrap;\">  </span>print $line;<br />}",
  "read-file-array": "@a = &lt;$f&gt;;",
  "read-file-str": "$s = do { local $/; &lt;$f&gt; };",
  "write-file": "print $f \"lorem ipsum\";",
  "write-line": "print $f \"lorem ipsum\\n\";",
  "flush-file": "use IO::Handle;<br /><br />$f-&gt;flush();",
  "eof-test": "eof($f)",
  "seek": "tell($f)<br />seek($f, 0, SEEK_SET);",
  "open-tmp-file": "use File::Temp;<br /><br />$f = File::Temp-&gt;new();<br /><br />print $f \"lorem ipsum\\n\";<br /><br />print \"tmp file: \";<br />print $f-&gt;filename . \"\\n\";<br /><br />close $f or die;<br /><br /><span style=\"color: gray\"># file is removed when file handle goes<br /># out of scope</span>",
  "in-memory-stream": "my ($f, $s);<br />open($f, \"&gt;\", \\$s);<br />print $f \"lorem ipsum\\n\";<br />$s;"
},
"file": {
  "file-test": "-e \"/etc/hosts\"<br />-f \"/etc/hosts\"",
  "file-size": "-s \"/etc/hosts\"",
  "readable-writable-executable": "-r \"/etc/hosts\"<br />-w \"/etc/hosts\"<br />-x \"/etc/hosts\"",
  "chmod": "chmod 0755, \"/tmp/foo\";",
  "last-modification-time": "my @data = stat('/etc/passwd');<br /><br /><span style=\"color: gray\"># unix epoch:</span><br />my $t = $data['mtime'];",
  "file-cp-rm-mv": "use File::Copy;<br /><br />copy(\"/tmp/foo\", \"/tmp/bar\");<br />unlink \"/tmp/foo\";<br />move(\"/tmp/bar\", \"/tmp/foo\");",
  "symlink": "symlink \"/etc/hosts\", \"/tmp/hosts\";<br />-l \"/etc/hosts\"<br />readlink \"/tmp/hosts\"",
  "tmpfile": "use File::Temp;<br /><br />$f = File::Temp-&gt;new(DIR=&gt;\"/tmp\",<br /><span style=\"white-space: pre-wrap;\">  </span>TEMPLATE=&gt;\"fooXXXXX\",<br /><span style=\"white-space: pre-wrap;\">  </span>CLEANUP=&gt;0);<br />$path = $f-&gt;filename;"
},
"file-fmt": {
  "parse-csv": "# cpan -i Text::CSV<br />use Text::CSV;<br /><br />my $csv = Text::CSV-&gt;new or die;<br />open my $f, $ARGV[0] or die;<br />while (my $row = $csv-&gt;getline($f)) {<br /><span style=\"white-space: pre-wrap;\">  </span>print join(\"\\t\", @$row) . \"\\n\";<br />}",
  "generate-csv": "<span style=\"color: gray\"># cpan -i Text::CSV</span><br />use Text::CSV;<br /><br />my $csv = Text::CSV-&gt;new or die;<br />$csv-&gt;eol (\"\\r\\n\");<br />open my $f, \"&gt;nums.csv\" or die;<br />$csv-&gt;print($f, [\"one\", \"une\", \"uno\"]);<br />$csv-&gt;print($f, [\"two\", \"deux\", \"dos\"]);<br />$f-&gt;close or die;",
  "parse-json": "<span style=\"color: gray\"># cpan -i JSON</span><br />use JSON;<br /><br />$json = JSON-&gt;new-&gt;allow_nonref;<br />$data = $json-&gt;decode('{\"t\": 1, \"f\": 0}');",
  "generate-json": "<span style=\"color: gray\"># cpan -i JSON</span><br />use JSON;<br /><br />$json = JSON-&gt;new-&gt;allow_nonref;<br />$data = {t =&gt; 1, f =&gt; 0};<br />$s = $json-&gt;encode($data);",
  "parse-xml": "<span style=\"color: gray\"># cpan -i XML::XPath</span><br />use XML::XPath;<br /><br />my $xml = \"&lt;a&gt;&lt;b&gt;&lt;c&gt;foo&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;\";<br /><br /><span style=\"color: gray\"># fatal error if XML not well-formed</span><br />my $doc = XML::XPath-&gt;new(xml =&gt; $xml);<br /><br />my $nodes = $doc-&gt;find(\"/a/b/c\");<br />print $nodes-&gt;size . \"\\n\";<br /><br />$node = $nodes-&gt;get_node(0);<br />print $node-&gt;string_value . \"\\n\";<br />print $node-&gt;getAttribute(\"ref\") . \"\\n\";",
  "generate-xml": "<span style=\"color: gray\"># cpan -i XML::Writer</span><br />use XML::Writer;<br /><br />my $writer = XML::Writer-&gt;new(<br />OUTPUT =&gt; STDOUT);<br />$writer-&gt;startTag(\"a\");<br />$writer-&gt;startTag(\"b\", id =&gt; \"123\");<br />$writer-&gt;characters(\"foo\");<br />$writer-&gt;endTag(\"b\");<br />$writer-&gt;endTag(\"a\");<br /><br /><span style=\"color: gray\"># &lt;a&gt;&lt;b id=\"123\"&gt;foo&lt;/b&gt;&lt;/a&gt;:</span><br />$writer-&gt;end;"
},
"dir": {
  "working-dir": "use Cwd;<br /><br />my $old_dir = cwd();<br /><br />chdir(\"/tmp\");",
  "build-pathname": "use File::Spec;<br /><br />File::Spec-&gt;catfile(\"/etc\", \"hosts\")",
  "dirname-basename": "use File::Basename;<br /><br />print dirname(\"/etc/hosts\");<br />print basename(\"/etc/hosts\");",
  "absolute-pathname": "use Cwd;<br /><br /><span style=\"color: gray\"># symbolic links are resolved:</span><br />Cwd::abs_path(\"foo\")<br />Cwd::abs_path(\"/foo\")<br />Cwd::abs_path(\"../foo\")<br />Cwd::abs_path(\".\")",
  "dir-iter": "opendir(my $dh, $ARGV[0]);<br /><br />while (my $file = readdir($dh)) {<br /><span style=\"white-space: pre-wrap;\">  </span>print $file . \"\\n\";<br />}<br /><br />closedir($dh);",
  "glob": "while ( &lt;/etc/*&gt; ) {<br /><span style=\"white-space: pre-wrap;\">  </span>print $_ . \"\\n\";<br />}",
  "mkdir": "use File::Path 'make_path';<br /><br />make_path \"/tmp/foo/bar\";",
  "recursive-cp": "<span style=\"color: gray\"># cpan -i File::Copy::Recursive</span><br />use File::Copy::Recursive 'dircopy';<br /><br />dircopy \"/tmp/foodir\",<br /><span style=\"white-space: pre-wrap;\">  </span>\"/tmp/bardir\";",
  "rmdir": "rmdir \"/tmp/foodir\";",
  "rm-rf": "use File::Path 'remove_tree';<br /><br />remove_tree \"/tmp/foodir\";",
  "dir-test": "-d \"/tmp\"",
  "unused-dir": "use File::Temp qw(tempdir);<br /><br />$path = tempdir(DIR=&gt;\"/tmp\",<br /><span style=\"white-space: pre-wrap;\">  </span>CLEANUP=&gt;0);",
  "system-tmp-dir": "use File::Spec;<br /><br />File::Spec-&gt;tmpdir"
},
"processes-environment": {
  "cmd-line-arg": "@ARGV",
  "program-name": "$0",
  "env-var": "$ENV{\"HOME\"}<br /><br />$ENV{\"PATH\") = \"/bin\";",
  "pid": "$$<br />getppid",
  "user-id-name": "$&lt;<br />getpwuid($&lt;)",
  "exit": "exit 0;",
  "signal-handler": "$SIG{INT} = sub {<br /><span style=\"white-space: pre-wrap;\">  </span>die \"exiting…\\n\";<br />};",
  "exec-test": "-x \"/bin/ls\"",
  "external-cmd": "system(\"ls -l /tmp\") == 0 or<br /><span style=\"white-space: pre-wrap;\">  </span>die \"ls failed\";",
  "shell-esc-external-cmd": "$path = &lt;&gt;;<br />chomp($path);<br />system(\"ls\", \"-l\", $path) == 0 or<br /><span style=\"white-space: pre-wrap;\">  </span>die \"ls failed\";",
  "cmd-subst": "my $files = ‘ls -l /tmp`;<br /><span style=\"color: gray\"># or</span><br />my $files = qx(ls);"
},
"option-parsing": {
  "cmd-line-opt": "use Getopt::Long;<br /><br />my ($file, $help, $verbose);<br /><br />my $usage =<br /><span style=\"white-space: pre-wrap;\">  </span>\"usage: $0 [-f FILE] [-v] [ARG …]\\n\";<br /><br />if (!GetOptions(\"file=s\" =&gt; \\$file,<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"help\" =&gt; \\$help,<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"verbose\" =&gt; \\$verbose)) {<br /><span style=\"white-space: pre-wrap;\">  </span>print $usage;<br /><span style=\"white-space: pre-wrap;\">  </span>exit 1;<br />}<br /><br />if ($help) {<br /><span style=\"white-space: pre-wrap;\">  </span>print $usage;<br /><span style=\"white-space: pre-wrap;\">  </span>exit 0;<br />}<br /><br /><span style=\"color: gray\"># After call to GetOptions() only<br /># positional arguments are in @ARGV.<br />#<br /># Options can follow positional arguments.<br />#<br /># Long options can be preceded by one or two<br /># hyphens. Single letters can be used if<br /># only one long option begins with that<br /># letter.<br />#<br /># Single letter options cannot be bundled<br /># after a single hyphen.<br />#<br /># Single letter options must be separated<br /># from an argument by a space or =.</span>"
},
"lib-namespaces": {
  "compile-lib": "<span style=\"color: gray\"><em>none</em></span>",
  "load-lib": "require ’Foo.pm';<br /><br /><span style=\"color: gray\"># searches @INC for Foo.pm:</span><br />require Foo;",
  "load-lib-subdir": "require 'Foo/Bar.pm';<br /><br />require Foo::Bar;",
  "hot-patch": "do 'Foo.pm';",
  "load-err": "<span style=\"color: gray\"><em>fatal error if library not found or if last expression in library does not evaluate as true; fatal error parsing library propagates to client</em></span>",
  "main-in-lib": "unless (caller) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><em>code</em></span><br />}",
  "lib-path": "@INC<br /><br />push @INC, \"/some/path\";",
  "lib-path-env": "$ PERL5LIB=~/lib perl foo.pl",
  "lib-path-cmd-line": "$ perl -I ~/lib foo.pl",
  "simple-global-id": "<span style=\"color: gray\"><em>none</em></span>",
  "multiple-label-id": "<span style=\"color: gray\"><em>all identifiers not declared with</em> my</span>",
  "namespace-label-separator": "Foo::Bar::baz();",
  "namespace-decl": "package Foo;<br />require Exporter;<br />our @ISA = (\"Exporter\");<br />our @EXPORT_OK = qw(bar baz);",
  "subnamespace-decl": "package Foo::Bar;",
  "import-def": "<span style=\"color: gray\"># bar and baz must be in<br /># @EXPORT or @EXPORT_OK:</span><br />use Foo qw(bar baz);",
  "import-namespace": "<span style=\"color: gray\"># imports symbols in @EXPORT:</span><br />use Foo;",
  "shadow-avoidance": "",
  "pkg-management": "$ perldoc perllocal<br />$ cpan -i Moose"
},
"objects": {
  "def-class": "package Int;<br /><br />sub new {<br /><span style=\"white-space: pre-wrap;\">  </span>my $class = shift;<br /><span style=\"white-space: pre-wrap;\">  </span>my $v = $_[0] <span style=\"white-space: pre-wrap;\">||</span> 0;<br /><span style=\"white-space: pre-wrap;\">  </span>my $self = {value =&gt; $v};<br /><span style=\"white-space: pre-wrap;\">  </span>bless $self, $class;<br /><span style=\"white-space: pre-wrap;\">  </span>$self;<br />}<br /><br />sub value {<br /><span style=\"white-space: pre-wrap;\">  </span>my $self = shift;<br /><span style=\"white-space: pre-wrap;\">  </span>if ( @_ &gt; 0 ) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>$self-&gt;{'value'} = shift;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>$self-&gt;{'value'};<br />}",
  "create-obj": "my $i = new Int(); <span style=\"color: gray\"># or</span><br />my $i = Int-&gt;new();",
  "blank-obj": "",
  "instance-var-visibility": "<span style=\"color: gray\"><em>private; getters and setters must be explicitly defined</em></span>",
  "obj-literal": "",
  "set-attr": "$i-&gt;value($v + 1);",
  "get-attr": "my $v = $i-&gt;value;",
  "def-method": "sub plus {<br /><span style=\"white-space: pre-wrap;\">  </span>my $self = shift;<br /><span style=\"white-space: pre-wrap;\">  </span>$self-&gt;value + $_[0];<br />}",
  "invoke-method": "$i-&gt;plus(7)",
  "method-missing": "our $AUTOLOAD;<br /><br />sub AUTOLOAD {<br /><span style=\"white-space: pre-wrap;\">  </span>my $self = shift;<br /><span style=\"white-space: pre-wrap;\">  </span>my $argc = scalar(@_);<br /><span style=\"white-space: pre-wrap;\">  </span>print \"no def: $AUTOLOAD\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>. \" arity: $argc\\n\";<br />}",
  "def-class-method": "",
  "invoke-class-method": "Counter-&gt;instances();",
  "def-class-var": "",
  "get-set-class-var": ""
},
"inheritance-polymorphism": {
  "subclass": "package Counter;<br /><br />our @ISA = \"Int\";<br /><br />my $instances = 0;<br /><br />sub new {<br /><span style=\"white-space: pre-wrap;\">  </span>my $class = shift;<br /><span style=\"white-space: pre-wrap;\">  </span>my $self = Int-&gt;new(@_);<br /><span style=\"white-space: pre-wrap;\">  </span>$instances += 1;<br /><span style=\"white-space: pre-wrap;\">  </span>bless $self, $class;<br /><span style=\"white-space: pre-wrap;\">  </span>$self;<br />}<br /><br />sub incr {<br /><span style=\"white-space: pre-wrap;\">  </span>my $self = shift;<br /><span style=\"white-space: pre-wrap;\">  </span>$self-&gt;value($self-&gt;value + 1);<br />}<br /><br />sub instances {<br /><span style=\"white-space: pre-wrap;\">  </span>$instances;<br />}"
},
"reflection": {
  "inspect-type": "ref([]) eq \"ARRAY\"<br /><br /><span style=\"color: gray\"><em>returns empty string if argument not a reference; returns package name for objects</em></span>",
  "basic-types": "SCALAR<br />ARRAY<br />HASH<br />CODE<br />REF<br />GLOB<br />LVALUE<br />FORMAT<br />IO<br />VSTRING<br />Regexp",
  "inspect-class": "ref($o) eq \"Foo\"",
  "has-method": "$o-&gt;can(\"reverse\")",
  "msg-passing": "for $i (0..10) {<br /><span style=\"white-space: pre-wrap;\">  </span>$meth = \"phone$i\";<br /><span style=\"white-space: pre-wrap;\">  </span>$o-&gt;$meth(undef);<br />}",
  "eval": "while(&lt;&gt;) {<br /><span style=\"white-space: pre-wrap;\">  </span>print ((eval), \"\\n\");<br />}",
  "methods": "",
  "attributes": "keys %$o;",
  "loaded-lib": "<span style=\"color: gray\"># relative to directory in lib path:</span><br />keys %INC<br /><br /><span style=\"color: gray\"># absolute path:</span><br />values %INC",
  "loaded-namespaces": "grep { $_ =~ /::/ } keys %::",
  "inspect-namespace": "keys %URI::",
  "pretty-print": "use Data::Dumper;<br /><br />%d = (lorem=&gt;1, ipsum=&gt;[2, 3]);<br /><br />print Dumper(\\%d);",
  "src-line-file": "<span style=\"white-space: pre-wrap;\">__LINE__</span><br /><span style=\"white-space: pre-wrap;\">__FILE__</span>",
  "cmd-line-doc": "$ perldoc Math::Trig"
},
"net-web": {
  "hostname-ip": "use Sys::Hostname;<br />use IO::Socket;<br /><br />$host = hostname;<br />$ip = inet_ntoa(<br /><span style=\"white-space: pre-wrap;\">  </span>(gethostbyname(hostname))[4]);<br />$host2 = (gethostbyaddr(<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>inet_aton(\"10.45.234.23\"),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>AF_INET))[0];",
  "http-get": "use LWP::UserAgent;<br /><br />$url = <span style=\"white-space: pre-wrap;\">\"http://www.google.com\";</span><br />$r = HTTP::Request-&gt;new(GET=&gt;$url);<br />$ua = LWP::UserAgent-&gt;new;<br />$resp = $ua-&gt;request($r);<br />my $s = $resp-&gt;content();",
  "http-post": "",
  "absolute-url": "use URI;<br /><br />URI-&gt;new_abs(\"analytics\",<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">\"http://google.com\"</span>);",
  "parse-url": "use URI;<br /><br />$url = <span style=\"white-space: pre-wrap;\">\"http://foo.com:80/baz?q=3#baz\";</span><br />$up = URI-&gt;new($url);<br /><br />$protocol = $up-&gt;scheme;<br />$hostname = $up-&gt;host;<br />$port = $up-&gt;port;<br />$path = $up-&gt;path;<br />$query_str = $up-&gt;query;<br />$fragment = $up-&gt;fragment;<br /><br /><span style=\"color: gray\"># flat list of alternating keys and<br /># values:</span><br />@params = $up-&gt;query_form();",
  "url-encode": "use CGI;<br /><br />CGI::escape(\"lorem ipsum?\")<br />CGI::unescape(\"lorem%20ipsum%3F\")",
  "base64": "use MIME::Base64;<br /><br />open my $f, \"&lt;\", \"foo.png\";<br />my $s = do { local $/; &lt;$f&gt; };<br />my $b64 = encode_base64($s);<br />my $s2 = decode_base64($b64);"
},
"unit-tests": {
  "test-class": "<span style=\"color: gray\"># cpan -i Test::Class Test::More</span><br />package TestFoo;<br />use Test::Class;<br />use Test::More;<br />use base qw(Test::Class);<br /><br />sub test_01 : Test {<br /><span style=\"white-space: pre-wrap;\">  </span>ok(1, \"not true!\");<br />}<br /><br />1;",
  "run-test": "$ cat TestFoo.t<br />use TestFoo;<br />Test::Class-&gt;runtests;<br /><br />$ perl ./TestFoo.t",
  "assert-equal": "my $s = \"do re me\";<br />is($s, \"do re me\");",
  "assert-approx": "",
  "assert-regex": "my $s = \"lorem ipsum\";<br />like($s, qr/lorem/);",
  "assert-exc": "use Test::Fatal;<br /><br />ok(exception { 1 / 0 });",
  "test-setup": "<span style=\"color: gray\"># in class TestFoo:</span><br />sub make_fixture : Test(setup) {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"setting up\";<br />};",
  "test-teardown": "<span style=\"color: gray\"># in class TestFoo:</span><br />sub teardown : Test(teardown) {<br /><span style=\"white-space: pre-wrap;\">  </span>print \"tearing down\";<br />};"
},
"debug-profile": {
  "check-syntax": "$ perl -c foo.pl",
  "warning-flag": "$ perl -w foo.pl<br />$ perl -W foo.pl",
  "lint": "$ perl MO=Lint foo.pl",
  "debugger": "$ perl -d foo.pl",
  "debugger-cmd": "h l n s b c T ?? ?? p q",
  "benchmark-code": "use Benchmark qw(:all);<br /><br />$t = timeit(1_000_000, '$i += 1;');<br />print timestr($t);",
  "profile-code": "$ perl -d:DProf foo.pl<br />$ dprofpp"
}
}
