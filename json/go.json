{

"version": {
  "version-used": "<span style=\"color: gray\"><em>1.4</em></span>",
  "show-version": "$ go version",
  "implicit-prologue": "import \"fmt\""
},
"grammar-invocation": {
  "hello-world": "$ cat hello.go<br />package main<br />import \"fmt\"<br /><br />func main() {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Hello, World!\\n\")<br />}<br /><br />$ go build hello.go<br /><br />$ ./hello<br />Hello, World!",
  "file-suffixes": "",
  "stmt-separator": "; <span style=\"color: gray\"><em>or sometimes newline</em></span><br /><br /><span style=\"color: gray\"><em>a new line terminates a statement when the last token on the line is<br /><span style=\"white-space: pre-wrap;\">  </span>(1) an identifier,<br /><span style=\"white-space: pre-wrap;\">  </span>(2) a numeric, character, or string literal,<br /><span style=\"white-space: pre-wrap;\">  </span>(3) one of the keywords</em> break, continue,<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fallthrough, <em>or</em> return, <em><br /><span style=\"white-space: pre-wrap;\">  </span>(4) one of</em> ++, <span style=\"white-space: pre-wrap;\">--</span>, ), ], <em>or</em> }</span>",
  "block-delimiters": "{ <span style=\"color: gray\"><em>…</em></span> }",
  "eol-comment": "<span style=\"white-space: pre-wrap;\">//</span> <span style=\"color: gray\"><em>comment</em></span>",
  "multiple-line-comment": "/* <span style=\"color: gray\"><em>comment line</em></span><br /><span style=\"color: gray\"><em>another line</em></span> */"
},
"variables-expressions": {
  "local-var": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> memory allocated on stack:</span><br />var i int<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> allocated on stack; type inferred from literal:</span><br />j := 3<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> memory allocated on heap:</span><br />ptr := new(int)<br />*ptr = 7",
  "free-heap": "<span style=\"color: gray\"><em>none; uses garbage collection</em></span>",
  "global-var": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> foo.go:</span><br />package foo<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> capitalized top-level identifiers are exported:</span><br />var X = 7<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> bar.go:</span><br />package bar<br />import foo<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> package scope:</span><br />var y = 3<br /><br />func baz() {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> local scope:</span><br /><span style=\"white-space: pre-wrap;\">  </span>var z = 5<br /><br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(foo.X + y + z)<br />}",
  "uninitialized-var": "<span style=\"color: gray\"><em>Every type has a zero value. For numeric types it is zero and for strings it is the empty string.</em></span>",
  "compile-time-const": "const Pi = 3.14",
  "immutable-var": "<span style=\"color: gray\"><em>none</em></span>",
  "assignment": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> defines variable of appropriate type:</span><br />i := 3<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> variable must already be declared:</span><br />i = 3",
  "parallel-assignment": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> define variables of appropriate type:</span><br />m, n := 3, 7<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> x and y must already be declared:</span><br />x, y = 2, 8",
  "swap": "x, y = y, x",
  "compound-assignment": "<span style=\"color: gray\"><em>arithmetic:</em></span><br />+= -= *= /= %=<br /><br /><span style=\"color: gray\"><em>bit:</em></span><br /><span style=\"white-space: pre-wrap;\">&lt;&lt;= &gt;&gt;= &amp;= |= ^=</span>",
  "incr-decr": "<span style=\"color: gray\"><em>postmodifiers only; cannot be used in expressions:</em></span><br />i++ i<span style=\"white-space: pre-wrap;\">--</span>",
  "addr": "i := 3<br /><br />var ptr *int<br />ptr = &amp;i<br />ptr2 := &amp;i",
  "dereference": "i2 := *ptr",
  "type-size": "import \"unsafe\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> use expression or name of variable with type:</span><br />unsafe.Sizeof(i)<br />unsafe.Sizeof(1 + 1)",
  "addr-arith": "<span style=\"color: gray\"><em>none</em></span>",
  "null": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> cannot be stored in numeric or string variable:</span><br />nil",
  "null-test": "ptr == nil",
  "conditional-expr": "<span style=\"color: gray\"><em>none</em></span>"
},
"arithmetic-logic": {
  "boolean-type": "bool",
  "true-false": "true false",
  "falsehoods": "false",
  "logical-op": "&amp;&amp; <span style=\"white-space: pre-wrap;\">||</span> !",
  "relational-op": "== != &lt; &gt; &lt;= &gt;=",
  "int-type": "int<br />int8<br />int16<br />int32<br />int64",
  "unsigned-type": "uint8 (byte)<br />uint16<br />uint32<br />uint64",
  "float-type": "float32<br />float64",
  "arith-op": "<span style=\"white-space: pre-wrap;\">+</span> - * / %",
  "int-div": "3 / 7",
  "int-div-zero": "<span style=\"color: gray\"><em>on Unix, process sent a</em> SIGFPE <em>signal</em></span>",
  "float-div": "3 / float32(7)",
  "float-div-zero": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> these are float values but not literals:</span><br />+Inf, NaN, <span style=\"color: gray\"><em>or</em></span> -Inf<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> to get the float values:</span><br />import \"math\"<br /><br />math.Inf(1) math.Nan() math.Inf(-1)",
  "power": "import \"math\"<br /><br />math.Pow(2.0, 3.0)",
  "sqrt": "include \"math\"<br /><br />math.Sqrt(2)",
  "sqrt-negative-one": "import \"math\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> NaN</span><br />x := math.Sqrt(-2.0)<br /><br />import \"math/cmplx\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> (0+1.41421356i)</span><br />z := cmplx.Sqrt(-2.0)",
  "transcendental-func": "include \"math\"<br /><br />math.Exp math.Log math.Log2 math.Log10<br />math.Sin math.Cos math.Tan<br />math.Asin math.Acos math.Atan<br />math.Atan2",
  "transcendental-const": "import \"math\"<br /><br />math.Pi<br />Math.E",
  "float-truncation": "include \"math\"<br /><br />x = 3.77<br /><br />trunc := int(x)<br /><span style=\"color: gray\"><em>none</em></span><br />flr := int(math.Floor(x))<br />cl := int(math.Ceil(x))",
  "absolute-val": "include \"math\"<br /><br /><span style=\"color: gray\"><em>none</em></span><br />math.Abs(-7.77)",
  "complex-type": "complex64<br />complex128",
  "complex-construction": "var z complex128 = 1.0 + 2.0i",
  "complex-decomposition": "import \"math/cmplx\"<br /><br />var x float64<br />var w complex128<br /><br />x = real(z)<br />x = imag(z)<br />x = cmplx.Phase(z)<br />x = cmplx.Abs(z)<br />w = cmplx.Conj(z)",
  "random-num": "import \"math/rand\"<br /><br />n := rand.Intn(100)<br />x := rand.Float64()",
  "random-seed": "import \"math/rand\"<br /><br />rand.Seed(17)",
  "bit-op": "<span style=\"white-space: pre-wrap;\">&lt;&lt; &gt;&gt; &amp; |</span> <span style=\"color: gray\"><em>none</em></span> ^"
},
"strings": {
  "str-type": "string",
  "str-literal": "\"hello\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> raw string literal:</span><br /><span style=\"white-space: pre-wrap;\">`hello`</span>",
  "newline-in-str-literal": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> backquote literals only:</span><br />let s := <span style=\"white-space: pre-wrap;\">`first line</span><br />second line<span style=\"white-space: pre-wrap;\">`</span>",
  "str-literal-esc": "<span style=\"color: gray\"><em>Double quote literals only:</em></span><br /><br />\\a \\b \\f \\n \\r \\t \\v \\\\ \\\"<br />\\<span style=\"color: gray\"><em>ooo</em></span> \\x<span style=\"color: gray\"><em>hh</em></span> \\u<span style=\"color: gray\"><em>hhhh</em></span> \\U<span style=\"color: gray\"><em>hhhhhhhh</em></span>",
  "expr-interpolation": "",
  "compare-str": "\"hello\" == \"world\"<br />\"hello\" &lt; \"world\"",
  "str-to-num": "import \"strconv\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span>2nd arg is base, 3rd arg is size of int in bits:</span><br />i, _ := strconv.ParseInt(\"17\", 10, 32)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 2nd arg is size of float in bits:</span><br />x, _ := strconv.ParseFloat(\"3.14\", 32)",
  "num-to-str": "import \"strconv\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span>3rd arg is precision after decimal point;<br /><span style=\"white-space: pre-wrap;\">//</span> 4th arg is size of float in bits:</span><br />strconv.FormatFloat(3.14, 'f', 4, 32)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 2nd arg is base:</span><br />strconv.FormatInt(7, 10)",
  "split": "import \"strings\"<br /><br />s := \"foo bar baz\"<br />parts := strings.Split(s, \" \")",
  "str-join": "import \"strings\"<br /><br />parts := []string{\"foo\", \"bar\", \"baz\"}<br />s := strings.Join(parts, \" \")",
  "str-concat": "\"hello\" + \" world\"",
  "str-replicate": "import \"strings\"<br /><br />hbar := strings.Repeat(\"-\", 80)",
  "extract-substr": "\"hello\"[2:4]",
  "index-substr": "import \"strings\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> zero-based index; -1 if not found:</span><br />strings.Index(\"hello\", \"ll\")",
  "fmt-str": "",
  "translate-case": "import \"strings\"<br /><br />strings.ToUpper(\"hello\")<br />strings.ToLower(\"HELLO\")",
  "trim": "import \"strings\"<br /><br />s := \" lorem \"<br />strings.Trim(s, \" \")<br />strings.TrimLeft(s, \" \")<br />strings.TrimRight(s, \" \")",
  "pad": "",
  "str-len": "len(\"hello\")",
  "char-type": "rune",
  "char-literal": "",
  "char-lookup": "",
  "char-index": "",
  "char-tests": "",
  "chr-ord": ""
},
"regexes": {
  "regex-metachar": ". [ ] \\ ( ) * + ? { } | ^ $<br /><br /><span style=\"color: gray\"><em>use raw string (i.e. backtick) literals to avoid having to escape backslashes.</em></span>",
  "char-class-abbrev": ". \\d \\D \\s \\S \\w \\W",
  "regex-anchors": "^ $ \\A \\b \\B \\z",
  "regex-test": "import \"regexp\"<br /><br />var rx = regexp.MustCompile(\"1999\")<br />if (rx.MatchString(\"It's 1999.\")) {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(\"Party!\")<br />}",
  "case-insensitive-regex": "import \"regexp\"<br /><br />var rx = regexp.MustCompile(\"(?i)lorem\")<br />if (rx.MatchString(\"Lorem Ipsum\")) {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(\"case insensitive match\")<br />}",
  "regex-modifiers": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> use (?i), (?m), <span style=\"white-space: pre-wrap;\">...</span> to insert in regex:</span><br />i m s U",
  "subst": "import \"regexp\"<br /><br />s := \"do re mi mi mi\"<br />var rx = regexp.MustCompile(\"mi\")<br />fmt.Println(rx.ReplaceAllString(s, \"ma\"))",
  "group-capture": ""
},
"dates-time": {
  "unix-epoch-type": "int64",
  "broken-down-datetime-type": "Time",
  "current-unix-epoch": "import \"time\"<br /><br />t := time.Now().Unix()",
  "current-datetime": "import \"time\"<br /><br />dt := time.Now()",
  "broken-down-datetime-to-unix-epoch": "t := dt.Unix()",
  "unix-epoch-to-broken-down-datetime": "var t int64 = 1421929926<br />var ns int64 = 0<br />dt := time.Unix(t, ns)",
  "fmt-datetime": "layout := \"2006-01-02 15:04:05\"<br /><br />fmt.Println(dt.Format(layout))",
  "parse-datetime": "layout := \"2006-01-02:15:04:05\"<br /><br />dt, err := time.Parse(layout, \"1999-09-10 23:30:00\")",
  "date-subtraction": "var delta time.Duration<br /><br />delta = dt.Sub(dt2)",
  "add-duration": "dt2 := dt + 1000 * time.Second<br />dt3 := dt + 1000 * time.Hour",
  "date-parts": "yr := dt.Year()<br />var mo time.Month = dt2.Month()<br />dy := dt.Day()",
  "time-parts": "hr := dt.Hour()<br />mi := dt.Minute()<br />ss := dt.Second()",
  "build-datetime": "import \"time\"<br /><br />yr := 1999<br />var mo time.Month = 9<br />dy, hr, mi, ss, ns := 10, 23, 30, 0, 0<br />loc, _ := time.LoadLocation(\"Local\")<br /><br />dt := time.Date(yr, mo, dy, hr, mi, ss, ns, loc)",
  "local-tmz-determination": "",
  "tmz-info": "name, offset_sec := dt.Zone()<br /><br /><span style=\"color: gray\"><em>offset abbreviation:</em></span><br />name<br /><br /><span style=\"color: gray\"><em>UTC offset in hours:</em></span><br />offset_sec / 3600.0",
  "daylight-savings-test": "",
  "microseconds": "dt.Nanosecond() / 1000"
},
"fixed-length-arrays": {
  "declare-array": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> values are zero-initialized:</span><br />var a [10]int",
  "allocate-array-on-stack": "<span style=\"color: gray\"><em>compiler decides location in memory</em></span>",
  "allocate-array-on-heap": "<span style=\"color: gray\"><em>compiler decides location in memory</em></span>",
  "free-array-on-heap": "<span style=\"color: gray\"><em>none; garbage collected</em></span>",
  "array-literal": "a := []int{1, 2, 3}",
  "array-size": "len(a)",
  "array-lookup": "a[0]",
  "array-update": "a[0] = 4",
  "array-out-of-bounds": "<span style=\"color: gray\">panic: index out of range</span><br /><br /><span style=\"color: gray\"><em>if compiler detects a problem the code won't compile</em></span>",
  "array-element-index": "a := []string{\"foo\", \"bar\", \"baz\"}<br />loc := -1<br /><br />for i, val := range a {<br /><span style=\"white-space: pre-wrap;\">  </span>if val == \"bar\" {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>loc = i<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "slice-array": "a := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> {\"c\", \"d\"}:</span><br />a2 := a[2:4]",
  "slice-array-to-end": "a := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> {\"c\", \"d\", \"e\"}:</span><br />a2 := a[2:]",
  "concatenate-array": "a := []int{1, 2, 3}<br />a2 := []int{4, 5, 6}<br />a3 := append(a, a2<span style=\"white-space: pre-wrap;\">...</span>)",
  "copy-array": "a := []int{1, 2, 3}<br /><br />a2 := a<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> also sets a[0] to 4:</span><br />a2[0] = 4<br /><br />a3 := make([]int, len(a))<br />copy(a3, a)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> a[0] is unchanged:</span><br />a3[0] = 5",
  "iterate-over-array": "",
  "iterate-indices-elem": "",
  "reverse-array": "import \"sort\"<br /><br />a := []int{1, 2, 3}<br />sort.Sort(sort.Reverse(sort.IntSlice(a)))",
  "sort-array": ""
},
"resizable-arrays": {
  "declare-array": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> slice of length 5; capacity 10:</span><br />a := make([]int, 5, 10)",
  "array-literal": "a := []int{1, 2, 3}",
  "array-size": "len(a)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> number of elements that can be stored in allocated memory;<br /><span style=\"white-space: pre-wrap;\">//</span> runtime reallocates when needed:</span><br />cap(a)",
  "array-lookup": "a[0]",
  "array-update": "a[0] = 4",
  "array-out-of-bounds": "<span style=\"color: gray\">panic: index out of range</span><br /><br /><span style=\"color: gray\"><em>if compiler detects a problem the code won't compile</em></span>",
  "array-element-index": "a := []string{\"foo\", \"bar\", \"baz\"}<br />loc := -1<br /><br />for i, val := range a {<br /><span style=\"white-space: pre-wrap;\">  </span>if val == \"bar\" {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>loc = i<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "slice-array": "a := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> {\"c\", \"d\"}:</span><br />a2 := a[2:4]",
  "slice-array-to-end": "a := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> {\"c\", \"d\", \"e\"}:</span><br />a2 := a[2:]",
  "array-back": "a := []int{1, 2, 3}<br /><br />a = append(a, 4)<br />num := a[len(a) - 1]<br />a = a[:len(a) - 1]",
  "array-front": "",
  "concatenate-array": "a := []int{1, 2, 3}<br />a2 := []int{4, 5, 6}<br />a3 := append(a, a2<span style=\"white-space: pre-wrap;\">...</span>)",
  "copy-array": "a := []int{1, 2, 3}<br /><br />a2 := a<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> also sets a[0] to 4:</span><br />a2[0] = 4<br /><br />a3 := make([]int, len(a))<br />copy(a3, a)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> a[0] is unchanged:</span><br />a3[0] = 5",
  "iterate-over-array": "a := []string{\"do\", \"re\", \"mi\"}<br />for _, s := range(a) {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"value: %s\\n\", s)<br />}",
  "iterate-indices-elem": "a := []string{\"do\", \"re\", \"mi\"}<br />for i, s := range(a) {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"value at %d: %s\\n\", i, s)<br />}",
  "reverse-array": "import \"sort\"<br /><br />a := []int{1, 2, 3}<br />sort.Sort(sort.Reverse(sort.IntSlice(a)))",
  "sort-array": "",
  "map": "<span style=\"color: gray\"><em>none</em></span>",
  "filter": "<span style=\"color: gray\"><em>none</em></span>",
  "reduce": "<span style=\"color: gray\"><em>none</em></span>"
},
"dictionaries": {
  "declare-dict": "d := make(map[string]int)",
  "dict-literal": "d := map[string]int {\"t\": 1, \"f\": 0}",
  "dict-size": "len(d)",
  "dict-lookup": "d[\"t\"]",
  "dict-update": "d[\"t\"] = 2",
  "dict-missing-key": "<span style=\"color: gray\"><em>returns zero value for value type</em></span>",
  "dict-is-key-present": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> If key not present, val will contain<br /><span style=\"white-space: pre-wrap;\">//</span> zero value for type and ok will contain false:</span><br />val, ok = d[\"y\"]]",
  "dict-delete": "delete(d, \"f\")",
  "dict-iter": "for k, v := range d {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"%s: %d\\n\", k, v)<br />}",
  "dict-key-val-arrays": ""
},
"functions": {
  "def-func": "func add(n int, m int) int {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + m<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> parameters can share type declaration:</span><br />func add(n, m int) int {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + m<br />}",
  "invoke-func": "add(3, 7)",
  "forward-decl-func": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> function can be invoked before definition</span><br />fmt.Printf(\"%f\\n\", add(2.2, 3.5))<br /><br />func add(n float32, m float32) float32 {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + m<br />}",
  "overload-func": "<span style=\"color: gray\"><em>not permitted</em></span>",
  "nest-func": "<span style=\"color: gray\"><em>not permitted</em></span>",
  "default-val-param": "<span style=\"color: gray\"><em>none</em></span>",
  "variable-num-arg": "func concat(strs <span style=\"white-space: pre-wrap;\">...</span>string) string {<br /><span style=\"white-space: pre-wrap;\">  </span>var ret = \"\"<br /><span style=\"white-space: pre-wrap;\">  </span>for _, str := range strs {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>ret += str<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br /><span style=\"white-space: pre-wrap;\">  </span>return ret<br />}",
  "named-param": "<span style=\"color: gray\"><em>none</em></span>",
  "pass-by-val": "",
  "pass-by-addr": "",
  "pass-by-ref": "",
  "retval": "<span style=\"color: gray\">return <em>arg. If return values have names and no arguments are provided to</em> return <em>the values assigned to the return variables are used.</em></span>",
  "no-retval": "",
  "multiple-retval": "func divmod(m, n int) (int, int) {<br /><span style=\"white-space: pre-wrap;\">  </span>return m / n, m % n<br />}<br /><br />q, r := divmod(7, 3)",
  "named-retval": "func divmod(m, n int) (q, r int) {<br /><span style=\"white-space: pre-wrap;\">  </span>q = m / n<br /><span style=\"white-space: pre-wrap;\">  </span>r = m % n<br /><span style=\"white-space: pre-wrap;\">  </span>return<br />}<br /><br />q, r := divmod(7, 3)",
  "exec-on-return": "import \"os\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> prints \"x is 7\"</span><br />func x_is_7() {<br /><span style=\"white-space: pre-wrap;\">  </span>x := 7<br /><span style=\"white-space: pre-wrap;\">  </span>defer fmt.Println(x)<br /><span style=\"white-space: pre-wrap;\">  </span>x = 8<br /><span style=\"white-space: pre-wrap;\">  </span>defer os.Stdout.WriteString(\"x is \")<br />}",
  "anonymous-func-literal": "",
  "invoke-anonymous-func": "",
  "func-private-state": "",
  "func-as-val": ""
},
"execution-control": {
  "if": "var signum int<br /><br />if x &gt; 0 {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 1<br />} else if x == 0 {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 0<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = -1<br />}",
  "switch": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> switch expression can have any type</span><br /><br />switch i {<br />case 0, 1:<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(\"i is boolean\")<br />default:<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(\"i is not a boolean\")<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> use \"fallthrough\" to fall through</span>",
  "while": "i := 0<br /><br />for i &lt; 10 {<br /><span style=\"white-space: pre-wrap;\">  </span>i++<br />}",
  "for": "var i, n int<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Initialization and afterthought must be single<br /><span style=\"white-space: pre-wrap;\">//</span> statements; there is no comma operator.</span><br />n = 1<br />for i = 1; i &lt;= 10; i++ {<br /><span style=\"white-space: pre-wrap;\">  </span>n *= i;<br />}",
  "for-local-scope": "n := 1<br /><br />for i := 1; i &lt;= 10; i++ {<br /><span style=\"white-space: pre-wrap;\">  </span>n *= i;<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> i is no longer in scope</span>",
  "infinite-loop": "for {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> code</span><br />}",
  "break": "break",
  "break-from-nested-loops": "<span style=\"white-space: pre-wrap;\">  </span>var a, b int<br /><br />Outer:<br /><span style=\"white-space: pre-wrap;\">  </span>for a = 1; ; a++ {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>for b = 1; b &lt; a; b++ {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>c := int(math.Sqrt(float64(a * a + b * b)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>if c * c == a * a + b * b {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break Outer<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>}",
  "continue": "continue",
  "single-stmt-branch-loop": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> braces are mandatory:</span><br />if n &lt; 0 {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(\"negative\")<br />}",
  "dangling-else": "<span style=\"color: gray\"><em>no ambiguity</em></span>",
  "goto": "<span style=\"white-space: pre-wrap;\">  </span>if err {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>goto Cleanup<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> code</span><br /><br />Cleanup:<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(\"cleaning up<span style=\"white-space: pre-wrap;\">...</span>\")",
  "longjmp": "<span style=\"color: gray\"><em>none</em></span>",
  "finally-block": ""
},
"concurrency": {
  "sleep": "dur := time.Duration(10 * time.Second)<br />time.Sleep(dur)<br /><br />dur2 := time.Duration(10000 * time.Microsecond)<br />time.Sleep(dur2)",
  "timeout": "",
  "start-thread": "",
  "terminate-current-thread": "",
  "terminate-other-thread": "",
  "list-threads": "",
  "wait-on-thread": "",
  "lock": "",
  "create-msg-queue": "",
  "send-msg": "",
  "receive-msg": ""
},
"file-handles": {
  "std-file-handles": "import \"os\"<br /><br />os.Stdin os.Stdout os.Stderr",
  "read-line-stdin": "import \"bufio\"<br />import \"os\"<br /><br />var line string<br />var err error<br /><br />b := bufio.NewReader(os.Stdin)<br /><br />line, err = b.ReadString('\\n')<br /><br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>os.Stderr.WriteString(\"error!\")<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> use line here</span><br />}",
  "write-line-stdout": "import \"os\"<br /><br />os.Stdout.WriteString(\"Hello, World!\\n\")",
  "printf": "fmt.Printf(\"count: %d\\n\", 7)",
  "open-file": "raw, err := os.Open(\"/etc/hosts\")<br />if err == nil {<br /><span style=\"white-space: pre-wrap;\">  </span>f := bufio.NewReader(f)<br />}",
  "open-file-write": "",
  "open-file-append": "",
  "close-file": "",
  "close-file-implicitly": "<span style=\"color: gray\"><em>defer</em></span>",
  "io-err": "",
  "read-line": "",
  "file-line-iterate": "",
  "read-file-array": "",
  "read-file-str": "",
  "write-str": "",
  "write-line": "",
  "flush": "",
  "eof-test": "",
  "seek": "",
  "tmp-file": ""
},
"files": {
  "file-test": "import \"os\"<br /><br />fi, err := os.Stat(\"/tmp/foo\")<br />if os.IsNotExist(err) {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Does not exit\\n\")<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Exists\\n\")<br /><span style=\"white-space: pre-wrap;\">  </span>fm := fi.Mode()<br /><span style=\"white-space: pre-wrap;\">  </span>if fm.IsRegular() {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Is Regular\")<br /><span style=\"white-space: pre-wrap;\">  </span>} else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Is Not Regular\")<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "file-size": "fi.Size()",
  "readable-writable-executable": "",
  "chmod": "import \"os\"<br /><br />err := os.Chmod(\"/tmp/foo\", 0755)<br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Chmod failed\\n\")<br />}",
  "last-modification-time": "",
  "file-cp-rm-mv": "import \"os\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> no copy function in standard library</span><br /><br />err := os.Remove(\"/tmp/foo\")<br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Remove failed: %s\\n\", err)<br />}<br /><br />err2 := os.Rename(\"/tmp/bar\", \"/tmp/foo\")<br />if err2 != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Rename failed: %s\\n\", err2)<br />}",
  "symlink": "import \"os\"<br /><br />err := os.Symlink(\"/etc/hosts\", \"/tmp/hosts\")<br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Symlink failed: %s\\n\", err)<br />}<br /><br />fi, err2 := os.Lstat(\"/tmp/hosts\")<br />if err2 == nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fm := fi.Mode()<br /><span style=\"white-space: pre-wrap;\">  </span>if fm &amp; os.ModeSymlink != 0 {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(\"File is a Symlink\")<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Lstat failed: %s\\n\", err2)<br />}<br /><br />s, err3 := os.Readlink(\"/tmp/hosts\")<br />if err3 != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Readlink failed: %s\\n\", err3)<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Link target: %s\\n\", s)<br />}",
  "unused-file-name": "import \"io/ioutil\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Uses system tmp dir if 1st arg is empty string:</span><br />f, err := ioutil.TempFile(\"/tmp\", \"foo\")<br />if err == nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"writing to: %s\\n\", f.Name())<br /><span style=\"white-space: pre-wrap;\">  </span>f.WriteString(\"foo content\")<br />}"
},
"directories": {
  "working-dir": "import \"os\"<br /><br />dir, err := os.Getwd()<br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>os.Stderr.WriteString(\"Gtwd failed\\n\")<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"pwd: %s\\n\", dir)<br />}<br /><br />err2 := os.Chdir(\"/tmp\")<br />if err2 != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>os.Stderr.WriteString(\"Chdir failed\\n\");<br />}",
  "build-pathname": "import \"path\"<br /><br />pathname := path.Join(\"/etc\", \"hosts\")<br />fmt.Printf(\"path: %s\\n\", pathname)",
  "dirname-basename": "import \"path\"<br /><br />path.Dir(\"/etc/hosts\")<br />path.Base(\"/etc/hosts\")",
  "absolute-pathname": "",
  "dir-iterate": "import \"io/ioutil\"<br /><br />a, err := ioutil.ReadDir(\"/etc\")<br />if err == nil {<br /><span style=\"white-space: pre-wrap;\">  </span>for _, fi := range a {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"name: %s\\n\", fi.Name())<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "glob": "import \"path/filepath\"<br /><br />a, err := filepath.Glob(\"/etc/*\")<br />if err == nil {<br /><span style=\"white-space: pre-wrap;\">  </span>for _, path := range(a) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"path: %s\\n\", path)<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "mkdir": "err := os.Mkdir(\"/tmp/foo\", 0775)<br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Mkdir failed: %s\\n\", err)<br />}",
  "recursive-cp": "",
  "rmdir": "err := os.Remove(\"/tmp/foo\")<br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Remove failed: %s\", err)<br />}",
  "rm-rf": "err := os.RemoveAll(\"/tmp/foo\")<br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"RemoveAll failed: %s\", err)<br />}",
  "dir-test": "",
  "unused-dir": "import \"io/ioutil\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Uses system tmp dir if 1st arg is empty string:</span><br />path, err := ioutil.TempDir(\"/tmp\", \"foo\")<br />if err == nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"dir path: %s\\n\", path)<br />}",
  "system-tmp-dir": "import \"os\"<br /><br />path := os.TempDir()"
},
"processes-environment": {
  "cmd-line-arg": "import \"os\"<br /><br />if len(os.Args) &gt; 1 {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"first arg: %\\n\", os.Args[1])<br />}",
  "program-name": "import \"os\"<br /><br />fmt.Printf(\"program name: %s\\n\", os.Args[0])",
  "env-var": "import \"os\"<br /><br />home := os.Getenv(\"HOME\")<br /><br />err := os.Setenv(\"EDITOR\", \"emacs\")<br />if err != nil {<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"Setenv failed: %s\\n\", err)<br />}",
  "env-var-iter": "import \"os\"<br />import \"strings\"<br /><br />for _, s := range os.Environ() {<br /><span style=\"white-space: pre-wrap;\">  </span>a := strings.SplitN(s, \"=\", 2)<br /><span style=\"white-space: pre-wrap;\">  </span>fmt.Printf(\"key: %s value: %s\\n\", a[0], a[1])<br />}",
  "user-id-name": "import \"os\"<br /><br />os.Getuid()<br /><span style=\"color: gray\">/* username? */</span>",
  "exit": "import \"os\"<br /><br />os.Exit(1)",
  "executable-test": "",
  "external-cmd": "",
  "fork": "",
  "exec": "",
  "pipe": "",
  "wait": "",
  "pid": "import \"os\"<br /><br />fmt.Println(os.Getpid())<br />fmt.Println(os.Getppid())",
  "signal-handler": "",
  "send-signal": ""
},
"option-parsing": {
  "getopt": ""
},
"libraries-namespaces": {
  "load-lib": "import \"foo\"<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Only capitalized identifiers are visible:</span><br />var bar = foo.GetBar()",
  "load-lib-subdir": "import \"lib/foo\"",
  "lib-path": "<span style=\"color: gray\"><em>The installation libraries are in the</em> GOROOT <em>directory. Additional directories can be listed in the</em> GOPATH <em>environment variable. The directories are separated by colons (semicolons) on Unix (Windows).<br /><br />Each directory contains a</em> src <em>subdirectory containing source code and a</em> pkg/ARCH <em>subdirectory containing compiled libraries.</em></span>",
  "declare-namespace": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> A package declaration must be first statement<br /><span style=\"white-space: pre-wrap;\">//</span> in every source file..</span><br />package foo",
  "alias-namespace": "import fu \"foo\"",
  "unqualified-import": "import . \"foo\"",
  "unqualified-import-of-definitions": "",
  "pkg-manager": ""
},
"user-defined-types": {
  "typedef": "",
  "enum": "",
  "struct-definition": "type MedalCount struct {<br /><span style=\"white-space: pre-wrap;\">  </span>country string<br /><span style=\"white-space: pre-wrap;\">  </span>gold int<br /><span style=\"white-space: pre-wrap;\">  </span>silver int<br /><span style=\"white-space: pre-wrap;\">  </span>bronze int<br />}",
  "struct-declaration<br-/>": "",
  "struct-initialization": "spain := MedalCount{\"Spain\", 3, 2, 1}<br /><br />france := MedalCount{<br /><span style=\"white-space: pre-wrap;\">  </span>bronze: 9,<br /><span style=\"white-space: pre-wrap;\">  </span>silver: 7,<br /><span style=\"white-space: pre-wrap;\">  </span>gold: 8,<br /><span style=\"white-space: pre-wrap;\">  </span>country: \"France\"}",
  "struct-literal": "",
  "struct-member-assignment": "france := MedalCount{}<br />france.country = \"France\"<br />france.gold = 7<br />france.silver = 6<br />france.bronze = 5",
  "struct-member-access": "france_total = france.gold +<br /><span style=\"white-space: pre-wrap;\">  </span>france.silver +<br /><span style=\"white-space: pre-wrap;\">  </span>france.bronze"
},
"cpp-macros": {
  "include-file": "",
  "add-system-dir": "",
  "def-macro": "",
  "cmd-line-macro": "",
  "undef-macro": "",
  "macro-with-arguments": "",
  "stringify-macro-argument": "",
  "concatenate-tokens": "",
  "conditional-compilation": "",
  "macro-operators": ""
},
"net-web": {
  "http-get": "import \"io/ioutil\"<br />import \"net/http\"<br /><br />resp, err := http.Get(<span style=\"white-space: pre-wrap;\">\"http://www.google.com\"</span>)<br />if err == nil {<br /><span style=\"white-space: pre-wrap;\">  </span>defer resp.Body.Close()<br /><span style=\"white-space: pre-wrap;\">  </span>body, err := ioutil.ReadAll(resp.Body)<br /><span style=\"white-space: pre-wrap;\">  </span>if err == nil {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fmt.Println(string(body))<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}"
},
"unit-tests": {
  "unit-test-example": "",
  "equality-assertion": "",
  "setup-and-teardown": "",
  "unit-test-coverage": ""
},
"debugging-profiling": {
  "check-syntax": "",
  "stronger-warnings": "",
  "suppress-warnings": "",
  "warnings-as-err": "",
  "lint": "",
  "src-cleanup": "",
  "debugger": "",
  "debugger-cmds": "",
  "cpu-usage": "",
  "profile": "",
  "memory-tool": ""
}
}
