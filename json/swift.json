{
"version": {
  "version-used": "<span style=\"color: gray\"><em>2.1</em></span>",
  "version": "$ swift <span style=\"white-space: pre-wrap;\">--</span>version",
  "implicit-prologue": "import Foundation"
},
"grammar-invocation": {
  "interpreter": "<span style=\"color: gray\"><em>none</em></span>",
  "compiler": "$ cat hello.swift<br />print(\"Hello, World!\")<br /><br />$ swift hello.swift<br /><br />$ ./hello<br />Hello, World!",
  "statement-terminator": "; <span style=\"color: gray\"><em>or sometimes newline<br /><br />A newline does not terminate a statement when:<br /><span style=\"white-space: pre-wrap;\">  </span>(1) inside [ ] of an array literal,<br /><span style=\"white-space: pre-wrap;\">  </span>(2) inside of ( ) parens,<br /><span style=\"white-space: pre-wrap;\">  </span>(3) after a binary operator,<br /><span style=\"white-space: pre-wrap;\">  </span>(4) other situations?</em></span>",
  "blocks": "{ }",
  "end-of-line-comment": "<span style=\"white-space: pre-wrap;\">//</span> <span style=\"color: gray\"><em>comment</em></span>",
  "multiple-line-comment": "/* <span style=\"color: gray\"><em>comment line</em></span><br />/* <span style=\"color: gray\"><em>nested comment</em></span> */<br />*/"
},
"var-expr": {
  "value": "let Pi = 3.14",
  "variable": "var n = 3<br />n += 1",
  "assignment": "var i = 0<br /><br />i = 3",
  "parallel-assignment": "var (m, n) = (3, 7)",
  "swap": "(x, y) = (y, x)",
  "compound-assignment": "<span style=\"color: gray\"><em>arithmetic:</em></span><br />+= -= *= /= %=<br /><br /><span style=\"color: gray\"><em>string:</em></span><br />+=<br /><br /><span style=\"color: gray\"><em>bit:</em></span><br /><span style=\"white-space: pre-wrap;\">&lt;&lt;= &gt;&gt;= &amp;= |= ^=</span>",
  "unit": "Void<br />()",
  "conditional-expression": "x &gt; 0 ? x : -x",
  "branch-type-mismatch": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> syntax error:</span><br />true ? \"hello\" : 3",
  "null": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> option types only:</span><br />nil",
  "nullable-type": "",
  "null-test": "",
  "coalesce": "",
  "nullif": "",
  "expr-type-declaration": ""
},
"arithmetic-logic": {
  "boolean-type": "Bool",
  "true-false": "true false",
  "falsehoods": "false",
  "logical-op": "<span style=\"white-space: pre-wrap;\">&amp;&amp; || !</span>",
  "relational-op": "== != &lt; &gt; &lt;= &gt;=",
  "min-max": "",
  "int-type": "Int8<br />Int16<br />Int32 (Int)<br />Int64",
  "unsigned-int-type": "UInt8<br />UInt16<br />UInt32<br />UInt64 (UInt)",
  "int-literal": "",
  "float-type": "Float<br />Double",
  "arith-op": "+ - * / %",
  "add-int-float": "",
  "int-div": "7 / 3<br />7 % 3",
  "int-div-zero": "<span style=\"color: gray\"><em>process sent a</em> SIGILL <em>signal</em></span>",
  "float-div": "Double(7) / 3",
  "float-div-zero": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> these are float values but not literals:</span><br />+Inf, NaN, <span style=\"color: gray\"><em>or</em></span> -Inf",
  "power": "pow(2.0, 32.0)",
  "sqrt": "sqrt(2.0)",
  "sqrt-negative-one": "<span style=\"color: gray\">// NaN:</span><br />sqrt(-1)",
  "transcendental-func": "exp log log2 log10<br />sin cos tan<br />asin acos atan<br />atan2",
  "transcendental-const": "",
  "float-truncation": "Int(3.77)<br />Int(round(3.77))<br />Int(floor(3.77))<br />Int(ceil(3.77))",
  "abs-val": "abs(-7)<br />fabs(-7.77)",
  "int-overflow": "",
  "float-overflow": "",
  "arbitrary-len-int": "",
  "arbitrary-len-int-op": "",
  "random-num": "let i = rand()<br /><span style=\"color: gray\"><em>??</em></span>",
  "random-seed": "srand(17)",
  "bit-op": "<span style=\"white-space: pre-wrap;\">&lt;&lt; &gt;&gt; &amp; | ^ ~</span>",
  "binary-octal-hex-literals": "",
  "radix": ""
},
"strings": {
  "str-type": "String",
  "str-literal": "\"hello\"",
  "newline-in-str-literal": "<span style=\"color: gray\"><em>no</em></span>",
  "str-esc": "\\0 \\\\ \\t \\n \\r \\\" \\'<br />\\x<span style=\"color: gray\"><em>hh</em></span> \\u<span style=\"color: gray\"><em>hhhh</em></span> \\U<span style=\"color: gray\"><em>hhhhhhhh</em></span>",
  "format-str": "let n = 3, m = 5<br />let msg = \"\\(n) + \\(m) is \\(n + m)\"",
  "str-concat": "\"hello\" + \" world\"",
  "str-replicate": "let ch: Character = \"-\"<br />let hbar = String(count: 80, repeatedValue: ch)",
  "translate-case": "let s = \"hello\"<br />let s2 = s.uppercaseString<br /><br />let s3 = \"HELLO\"<br />let s4 = s3.lowercaseString",
  "capitalize": "",
  "trim": "",
  "pad": "",
  "num-to-str": "let n = String(17)<br />let x = String(17.3)",
  "str-to-num": "\"17\".toInt()<br /><br /><span style=\"color: gray\">// evaluates to nil:</span><br />\"17foo\".toInt()<br /><br /><span style=\"color: gray\">// convert to float?</span>",
  "join": "",
  "split": "",
  "char-type": "Character",
  "char-literal": "",
  "str-len": "countElements(\"hello\")",
  "index-substr": "",
  "substr": "",
  "extract-char": "",
  "chr-ord": ""
},
"dates-time": {
  "dates-time-types": "",
  "current-date-time": "",
  "current-unix-epoch": "",
  "to-unix-epoch,-from-unix-epoch": "",
  "format-date": "",
  "parse-date": "",
  "date-subtraction": "",
  "add-duration": "",
  "date-parts": "",
  "time-parts": "",
  "build-broken-down-datetime": ""
},
"fixed-length-arrays": {
  "array-literal": "",
  "array-size": "",
  "array-lookup": "",
  "array-update": "",
  "array-out-of-bounds": ""
},
"resizable-arrays": {
  "declare-array": "let a: Array&lt;Int&gt; = []<br />let a2: Int[] = []",
  "array-literal": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> array is mutable; variable is not:</span><br />let a = [1, 2, 3]",
  "array-size": "a.count",
  "array-lookup": "a[0]",
  "array-update": "a[0] = 4",
  "array-out-of-bounds": "<span style=\"color: gray\"><em>raises</em> SIGILL</span>",
  "array-element-index": "",
  "slice-array": "var a = [\"a\", \"b\", \"c\", \"d\", \"e\"]<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> [\"c\", \"d\"]:</span><br />a[2<span style=\"white-space: pre-wrap;\">...</span>3]<br />a[2..4]",
  "slice-array-to-end": "",
  "array-back": "let a = [1, 2, 3]<br />a.append(4)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> sets num to 4:</span><br />let num = a.removeLast()",
  "array-front": "let a = [1, 2, 3]<br />a.insert(0, atIndex: 0)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> sets num to 0:</span><br />let num = a.removeAtIndex(0)",
  "concatenate-array": "let a = [1, 2, 3]<br />a += [4, 5, 6]<br /><br />let a3 = [1, 2, 3] + [4, 5, 6]",
  "copy-array": "let a = [1, 2, 3]<br /><br />let a2 = a<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> also modifies a[0]:</span><br />a2[0] = 4<br /><br />a3 = Array(a)<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> a[0] remains 4:</span><br />a3[0] = 5",
  "iterate-over-array": "",
  "iterate-indices-elem": "",
  "reverse-array": "let a = [1, 2, 3]<br />let a2 = a.reverse()",
  "sort-array": "let a = [1, 3, 2, 4]<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> modifies a in-place and returns it:</span><br />sort(a)",
  "array-dedupe": "",
  "array-membership": "",
  "array-intersection": "",
  "array-union": "",
  "array-relative-complement": "",
  "map": "",
  "filter": "",
  "array-fold-left": "",
  "array-fold-right": "",
  "array-shuffle": "",
  "array-flatten": "",
  "array-zip": ""
},
"lists": {
  "list-literal": "",
  "empty-list": "",
  "empty-list-test": "",
  "cons": "",
  "head": "",
  "tail": "",
  "head-tail-empty-list": "",
  "list-length": "",
  "nth-elem-of-list": "",
  "list-elem-index": "",
  "update-list": "",
  "concat-list": "",
  "list-last": "",
  "list-take": "",
  "list-drop": "",
  "iterate-over-list": "",
  "reverse-list": "",
  "sort-list": "",
  "map-list": "",
  "filter-list": "",
  "fold-list-left": "",
  "fold-list-right": "",
  "list-member": "",
  "universal-test-list": "",
  "existential-test-list": "",
  "zip-list": ""
},
"tuples": {
  "tuple-literal": "(1, \"hello\", true)",
  "tuple-type": "let tup: (Int, String, Bool) = (1, \"hello\", true)",
  "tuple-lookup": "let tup = (1, \"hello\", true)<br />let n: Int = tup.0",
  "deconstruct-tuple": "let tup = (1, \"hello\", true)<br />let (n, s, b) = tup<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> use underscores for unneeded elements:</span><br />let (n, _, _) = tup"
},
"dictionaries": {
  "declare-dict": "let dict = Dictionary&lt;String, Int&gt;()",
  "dict-literal": "let dict = [\"t\": 1, \"f\": 0]",
  "dict-size": "dict.count",
  "dict-lookup": "dict[\"t\"]",
  "dict-update": "dict[\"t\"] = 2",
  "dict-out-of-bounds": "<span style=\"color: gray\"><em>returns</em></span> nil",
  "dict-is-key-present": "if dict[\"y\"] {<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"key found\")<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"no such key\")<br />}",
  "dict-delete": "dict.removeValueForKey(\"t\")",
  "dict-iterate": "for (k, v) in dict {<br /><span style=\"white-space: pre-wrap;\">  </span>println(\"\\(k): \\(v)\")<br />}",
  "dict-key-val": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> dict.keys and dict.values are iterable:</span><br />Array(dict.keys)<br />Array(dict.values)"
},
"functions": {
  "def-func": "func add(n: Int, m: Int) -&gt; Int {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + m<br />}",
  "invoke-func": "add(3, 7)",
  "define-function-with-block-body": "",
  "nest-func": "func add_one(n: Int) -&gt; Int {<br /><span style=\"white-space: pre-wrap;\">  </span>func add(a: Int, b: Int) -&gt; Int {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>return a + b<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>return add(1, n)<br />}",
  "named-parameter": "func my_log(#exp: Double, #base: Double) -&gt; Double {<br /><span style=\"white-space: pre-wrap;\">  </span>return log(exp) / log(base)<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> expose different parameter names:</span><br />func my_log(exp e: Double, base b: Double) -&gt; Double {<br /><span style=\"white-space: pre-wrap;\">  </span>return log(e) / log(b)<br />}<br /><br />my_log(exp: 8, base: 2)",
  "named-parameter-default-value": "func incr(n: Int, amount: Int = 1) -&gt; Int {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + amount<br />}<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 4:</span><br />incr(3)<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 5:</span><br />incr(3, amount: 2)",
  "variable-num-arg": "func concat(strings: String<span style=\"white-space: pre-wrap;\">...</span>) -&gt; String {<br /><span style=\"white-space: pre-wrap;\">  </span>var retval = \"\"<br /><span style=\"white-space: pre-wrap;\">  </span>for string in strings {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>retval += string<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>return retval<br />}",
  "overload-function": "func add(a: String, b: String) -&gt; String {<br /><span style=\"white-space: pre-wrap;\">  </span>return a + b<br />}",
  "retval": "<span style=\"color: gray\">return <em>arg</em></span>",
  "multiple-retval": "func divmod(dividend: Int, divisor: Int) -&gt; (Int, Int) {<br /><span style=\"white-space: pre-wrap;\">  </span>return (dividend / divisor, dividend % divisor)<br />}",
  "recursive-function": "",
  "anonymous-function": "let add_one = {(n: Int) -&gt; Int in n + 1}",
  "invoke-anonymous-func": "add_one(2)",
  "func-as-val": "func add(n: Int, m: Int) -&gt; Int {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + m<br />}<br /><br />let f = add",
  "infix-operator-in-prefix-position": "",
  "function-in-infix-position": "",
  "currying": "",
  "lazy-evaluation": ""
},
"execution-control": {
  "if": "var signum: Int<br /><br />if i &gt; 0 {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 1<br />} else if i == 0 {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 0<br />} else {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = -1<br />}",
  "while": "var i = 0<br /><br />while i &lt; 10 {<br /><span style=\"white-space: pre-wrap;\">  </span>i += 1<br />}",
  "for": "var n = 1<br /><br />for var i = 1; i &lt;= 10; i++ {<br /><span style=\"white-space: pre-wrap;\">  </span>n *= i<br />}",
  "infinite-loop": "",
  "break-continue": ""
},
"exceptions": {
  "raise-error": "",
  "handle-error": "",
  "standard-exceptions": "",
  "assert": ""
},
"concurrency": {
},
"file-handles": {
  "standard-file-handles": "let stdin =<br /><span style=\"white-space: pre-wrap;\">  </span>NSFileHandle.fileHandleWithStandardInput()<br />let stdout =<br /><span style=\"white-space: pre-wrap;\">  </span>NSFileHandle.fileHandleWithStandardOutput()<br />let stderr<br /><span style=\"white-space: pre-wrap;\">  </span>NSFileHandle.fileHandleWithStandardError()",
  "read-line-from-stdin": "<span style=\"color: gray\"><em>none</em></span>",
  "write-line-to-stdout": "print(\"Hello, World!\")",
  "write-formatted-string-to-stdout": "let s = \"Spain\"<br />let i = 17<br />let x = 3.1415<br />let fmtx = NSString(format: \"%.2f\", x)<br /><br />print(\"\\(s) \\(i) \\(fmtx)\")",
  "open-file-for-reading": "import scala.io.Source<br /><br />val path = \"/etc/hosts\"<br />val f = Source.fromFile(path)",
  "open-file-for-writing": "let path = \"/tmp/test\"<br />NSFileManager().copyItemAtPath(<br /><span style=\"white-space: pre-wrap;\">  </span>\"/dev/null\",<br /><span style=\"white-space: pre-wrap;\">  </span>toPath: path,<br /><span style=\"white-space: pre-wrap;\">  </span>error: nil)<br />let f = NSFileHandle(<br /><span style=\"white-space: pre-wrap;\">  </span>forWritingAtPath: path)",
  "open-file-for-appending": "let f = NSFileHandle(<br /><span style=\"white-space: pre-wrap;\">  </span>forWritingAtPath: \"/tmp/err.log\")<br />f.seekToEndOfFile()",
  "close-file": "f.closeFile()",
  "close-file-implicitly": "class Defer {<br /><span style=\"white-space: pre-wrap;\">  </span>var fun: ()-&gt;()<br /><span style=\"white-space: pre-wrap;\">  </span>init(fun: ()-&gt;()) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>self.fun = fun<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>deinit {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>fun()<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br />var defer = Defer({()-&gt;() in f.closeFile()})",
  "read-line": "<span style=\"color: gray\"><em>none</em></span>",
  "iterate-over-file-by-line": "<span style=\"color: gray\"><em>none</em></span>",
  "read-file-into-array-of-strings": "<span style=\"color: gray\"><em>none</em></span>",
  "read-file-into-string": "let data = f.readDataToEndOfFile()<br />let s = NSString(<br /><span style=\"white-space: pre-wrap;\">  </span>data: data,<br /><span style=\"white-space: pre-wrap;\">  </span>encoding: NSUTF8StringEncoding)",
  "write-string": "f.writeData(\"Hello, World!\".dataUsingEncoding(<br /><span style=\"white-space: pre-wrap;\">  </span>NSUTF8StringEncoding))",
  "write-line": "f.writeData(\"Hello, World!\\n\".dataUsingEncoding(<br /><span style=\"white-space: pre-wrap;\">  </span>NSUTF8StringEncoding))",
  "flush-file-handle": "f.synchronizeFile()",
  "get-and-set-filehandle-position": "let pos = f.offsetInFile<br />f.seekToFileOffset(0)"
},
"files": {
  "file-test,-regular-file-test": "",
  "file-size": "",
  "is-file-readable,-writable,-executable": "",
  "set-file-permissions": "",
  "copy-file,-remove-file,-rename-file": "",
  "create-symlink,-symlink-test,-readlink": "",
  "generate-unused-file-name": ""
},
"directories": {
  "build-pathname": "",
  "dirname-and-basename": "",
  "iterate-over-directory-by-file": "",
  "make-directory": "",
  "remove-empty-directory": "",
  "remove-directory-and-contents": "",
  "directory-test": "",
  "temporary-directory": ""
},
"processes-environment": {
  "command-line-arguments": "",
  "program-name": "",
  "getopt": "",
  "env-var": "",
  "pid": "",
  "user-id-name": "",
  "exit": "",
  "signal-handler": "",
  "external-cmd": "",
  "escaped-external-cmd": "",
  "backticks": ""
},
"libraries-namespaces": {
  "define-namespace": "",
  "define-child-namespace": "",
  "reference-identifier-in-another-file": "",
  "import-definitions": "",
  "import-all-definitions-in-namespace": "",
  "import-namespace": "",
  "shadow-avoidance": "",
  "library-path-environment-variable": "",
  "create-package": "",
  "inspect-package": "",
  "install-package": "",
  "list-installed-packages": ""
},
"user-defined-types": {
  "type-synonym": "typealias CustomerId = Int<br />var customer_id: CustomerId = 3",
  "sum-type": "enum DayOfWeek {<br /><span style=\"white-space: pre-wrap;\">  </span>case Mon, Tue, Wed, Thu, Fri, Sat, Sun<br />}<br />let dow = DayOfWeek.Tue",
  "tuple-product-type-with-one-field": "",
  "tuple-product-type-with-two-fields": "",
  "record-product-type": "struct MedalCount {<br /><span style=\"white-space: pre-wrap;\">  </span>var country: String<br /><span style=\"white-space: pre-wrap;\">  </span>var gold: Int,<br /><span style=\"white-space: pre-wrap;\">  </span>silver: Int,<br /><span style=\"white-space: pre-wrap;\">  </span>bronze: Int<br />}",
  "record-product-type-literal": "var spain = MedalCount(<br /><span style=\"white-space: pre-wrap;\">  </span>country: \"Spain\",<br /><span style=\"white-space: pre-wrap;\">  </span>gold: 3,<br /><span style=\"white-space: pre-wrap;\">  </span>silver: 2,<br /><span style=\"white-space: pre-wrap;\">  </span>bronze: 1<br />)",
  "product-type-member-access": "let france_total = france.gold + france.silver + france.bronze",
  "product-type-member-assignment": "var france: MedalCount<br />france.country = \"France\"<br />france.gold = 7<br />france.silver = 6<br />france.bronze = 5",
  "generic-type": "",
  "recursive-type": "",
  "pattern-match-sum-type": "",
  "pattern-match-product-type": "",
  "pattern-match-guard": "",
  "pattern-match-catchall": ""
},
"objects": {
  "define-class": "",
  "create-object": "",
  "invoke-method": "",
  "define-class-variable-and-method": "",
  "invoke-class-method": ""
},
"inheritance-polymorphism": {
  "subclass": "",
  "abstract-base-class": "",
  "mixin": ""
},
"unit-tests": {
  "test-class": "",
  "run-all-tests,-run-test-suite": "",
  "exception-assertion": "",
  "setup": "",
  "teardown": ""
},
"debugging-profiling": {
  "lint": "",
  "run-debugger": "",
  "profile-code": "",
  "memory-tool": ""
},
"repl": {
  "invoke-repl": "$ swift",
  "previous-values": "$R0, $R1, …",
  "help": ":help",
  "quit": ":quit",
  "inspect-type": ""
}
}
