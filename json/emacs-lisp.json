{
"version": {
  "version-used": "<span style=\"color: gray\"><em>Emacs 24.5</em></span>",
  "show-version": "$ emacs <span style=\"white-space: pre-wrap;\">--</span>version"
},
"grammar-execution": {
  "compiler": "M-x byte-compile-file",
  "standalone-executable": "",
  "interpreter": "",
  "shebang": "#!/usr/bin/env emacs <span style=\"white-space: pre-wrap;\">--</span>script",
  "repl": "M-x ielm",
  "cmd-line-program": "",
  "word-separator": "<span style=\"color: gray\"><em>whitespace</em></span>",
  "eol-comment": "(+ 1 1) <span style=\"color: gray\">; adding</span>",
  "multiple-line-comment": ""
},
"var-expr": {
  "id": "<span style=\"color: gray\"><em>case sensitive, cannot start with digit</em></span><br /><br /><span style=\"color: gray\"><em>excluded characters:</em></span><br />SP ( ) \" , ' <span style=\"white-space: pre-wrap;\">`</span> ; # | \\ _ [ ]",
  "quoted-id": "<span style=\"color: gray\"><em>none</em></span><br /><br />(setq white\\ space\\ symbol 3)",
  "local-var": "<span style=\"color: gray\">; parallel assignment:</span><br />(lexical-let ((x 3) (y 4))<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))<br /><br />(lexical-let* ((x 3) (y (* x x)))<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))",
  "global-var": "(set 'x 3)<br />(setq x 3)",
  "rm-var": "(makunbound 'x)",
  "null": "nil '()",
  "null-test": "(null x)",
  "id-as-val": "'x<br />(quote x)",
  "id-test": "(symbolp 'x)",
  "identifier-equality-test": "(eq 'x 'x)",
  "non-referential-id": ":foo",
  "id-attr": "(set 'x 13)<br /><br />(setf (get 'x :desc) \"unlucky\")<br />(get 'x :desc)<br />(remprop 'x :desc)"
},
"arithmetic-logic": {
  "true-false": "t nil",
  "falsehoods": "nil ()",
  "logical-op": "(or (not t) (and t nil))",
  "relational-op": "<span style=\"white-space: pre-wrap;\">=</span> /= &lt; &gt; &lt;= &gt;=",
  "min-max": "(min 1 2 3)<br />(max 1 2 3)",
  "num-predicates": "numberp integerp<br /><span style=\"color: gray\"><em>none</em></span> floatp<br /><span style=\"color: gray\"><em>none</em></span> <span style=\"color: gray\"><em>none</em></span>",
  "arith-op": "+ - * / %",
  "int-div": "(/ 7 3)<br />(% 7 3)",
  "int-div-zero": "<span style=\"color: gray\">arith-error</span>",
  "float-div": "<span style=\"color: gray\"><em>integer quotient:</em></span><br />(/ 7 3)<br /><br /><span style=\"color: gray\"><em>float:</em></span><br />(/ 7 (* 3 1.0))",
  "float-div-zero": "-1.0e+INF, -0.0e+NaN, <span style=\"color: gray\"><em>or</em></span> 1.0e+INF",
  "power": "(expt 2 32)",
  "sqrt": "(sqrt 2)",
  "sqrt-negative-one": "-0.0e+NaN",
  "transcendental-func": "exp log sin cos tan asin acos atan atan",
  "float-truncation": "truncate round ceiling floor<br />fround fceiling ffloor<br /><span style=\"color: gray\">truncate <em>returns integer</em></span>",
  "abs-val": "abs signum",
  "int-overflow": "",
  "float-overflow": "",
  "rational-construction": "",
  "rational-decomposition": "<span style=\"color: gray\"><em>none</em></span> <span style=\"color: gray\"><em>none</em></span>",
  "complex-construction": "<span style=\"color: gray\"><em>none</em></span>",
  "complex-decomposition": "<span style=\"color: gray\"><em>none</em></span> <span style=\"color: gray\"><em>none</em></span>",
  "random-num": "(random 100)<br /><span style=\"color: gray\"><em>none</em></span><br /><span style=\"color: gray\"><em>none</em></span>",
  "random-seed": "",
  "bit-op": "lsh <span style=\"color: gray\"><em>left shift when 2nd argument positive</em></span> logand logior logxor lognot",
  "binary-octal-hex-literals": "",
  "radix": ""
},
"str": {
  "str-test": "(stringp \"foo\")",
  "str-literal": "\"foo bar\"",
  "newline-in-str-literal": "<span style=\"color: gray\"><em>yes</em></span>",
  "str-literal-esc": "\\b \\t \\n \\f \\r \\\" \\\\ \\<span style=\"color: gray\"><em>ooo</em></span> \\u<span style=\"color: gray\"><em>hhhh</em></span> \\x<span style=\"color: gray\"><em>h</em></span> - \\x<span style=\"color: gray\"><em>hhhhhh</em></span> \\C-<span style=\"color: gray\"><em>x</em></span> \\M-<span style=\"color: gray\"><em>x</em></span>",
  "str-ctor": "(string ?f ?o ?o)",
  "fmt-str": "(format \"%s: %d %.2f\" \"Foo\" 7 13.457)",
  "fmt-specifiers": "",
  "compare-str": "(string= \"foo\" \"bar\")<br />(string&lt; \"foo\" \"bar\")",
  "str-concat": "(concat \"foo \" \"bar \" \"baz\")",
  "str-replicate": "(make-string 3 ?f)",
  "translate-case": "(downcase \"FOO\")<br />(upcase \"foo\")",
  "capitalize": "<span style=\"color: gray\">; \"Foo Bar\":</span><br />(capitalize \"foo\")",
  "trim": "<span style=\"color: gray\"><em>none; see notes for an implementation</em></span>",
  "pad": "",
  "num-to-str": "(concat<br /><span style=\"white-space: pre-wrap;\">  </span>\"value: \"<br /><span style=\"white-space: pre-wrap;\">  </span>(number-to-string 8))",
  "str-to-num": "(+ 7 (string-to-number \"12\"))<br /><span style=\"white-space: pre-wrap;\"> </span><br />(+ 73.9 (string-to-number \".037\"))",
  "split": "(split-string \"foo bar baz\")",
  "str-join": "(reduce<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (m o) (concat m \" \" o))<br /><span style=\"white-space: pre-wrap;\">  </span>'(\"foo\" \"bar\" \"baz\"))",
  "str-len": "(length \"foo\")",
  "index-substr": "(search \"bar\" \"foo bar\")",
  "extract-substr": "(substring \"foo bar\" 4 7)",
  "char-literal": "?a ?\\b ?\\t ?\\n ?\\f ?\\r ?\\\" ?\\\\ ?\\<span style=\"color: gray\"><em>ooo</em></span> ?\\u<span style=\"color: gray\"><em>hhhh</em></span> ?\\x<span style=\"color: gray\"><em>h</em></span> - ?\\x<span style=\"color: gray\"><em>hhhhhh</em></span> ?\\C-<span style=\"color: gray\"><em>x</em></span> ?\\M-<span style=\"color: gray\"><em>x</em></span>",
  "char-test": "(characterp ?x)",
  "chr-ord": "",
  "str-to-char-array": "",
  "lookup-char": "(aref \"foo\" 0)"
},
"regex": {
  "regex-literal": "",
  "char-class-abbrev": ". \\w \\W \\ca \\cl \\cg \\Ca \\Cl \\Cg \\s<span style=\"color: gray\"><em>x</em></span><br /><br /><span style=\"color: gray\">\\ca \\cl <em>and</em> \\cg <em>match ASCII, Latin, and Greek characters.</em></span><br /><br /><span style=\"color: gray\"><em>Character classes of the form</em> \\sx <em>depend on the current syntax table.</em></span>",
  "regex-anchors": "^ $ \\b \\B",
  "regex-test": "(string-match \"bar\" \"foo bar\")",
  "case-insensitive-regex": "",
  "subst": "<span style=\"color: gray\"><em>?</em></span><br /><span style=\"white-space: pre-wrap;\"> </span><br />(replace-regexp-in-string \"[^l]l\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"EL\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"hello hello\")",
  "group-capture": "",
  "scan": "",
  "backreference": ""
},
"dates-time": {
  "broken-down-datetime-type": "",
  "current-datetime": "(current-time)",
  "current-unix-epoch": "(float-time)",
  "unix-epoch-to-broken-down-datetime": "(seconds-to-time (float-time))",
  "broken-down-datetime-to-unix-epoch": "(multiple-value-bind (b s)<br /><span style=\"white-space: pre-wrap;\">  </span>(current-time)<br /><span style=\"white-space: pre-wrap;\">  </span>(+ (* b (expt 2 16)) s))",
  "fmt-datetime": "(format-time-string<br /><span style=\"white-space: pre-wrap;\">  </span>\"%Y-%m-%d %H:%M:%S\"<br /><span style=\"white-space: pre-wrap;\">  </span>(current-time))",
  "parse-datetime": "",
  "datet-parts": "(multiple-value-bind<br /><span style=\"white-space: pre-wrap;\">  </span>(ss mi hr dy mo yr)<br /><span style=\"white-space: pre-wrap;\">  </span> (decode-time (current-time))<br /><span style=\"white-space: pre-wrap;\">  </span>(list dy mo yr))",
  "time-parts": "(multiple-value-bind<br /><span style=\"white-space: pre-wrap;\">  </span>(ss mi hr dy mo yr)<br /><span style=\"white-space: pre-wrap;\">  </span> (decode-time (current-time))<br /><span style=\"white-space: pre-wrap;\">  </span>(list ss mi hr))",
  "build-datetime": "(encode-time 0 50 8 31 5 2015)"
},
"lists": {
  "literal<br-/>": "'(1 2 3)<br />(quote (1 2 3))",
  "constructor<br-/>": "(list 1 2 3)",
  "predicate<br-/>": "(listp '(1 2 3))",
  "empty-test": "<span style=\"color: gray\">nil <em>and</em> '() <em>are synonyms and evaluate as false in a boolean context. All other values are true.</em></span>",
  "evaluating-the-empty-list": "nil",
  "cons<br-/>": "(cons 1 '(2 3))",
  "head<br-/>": "car",
  "tail<br-/>": "(cdr '(1 2 3))<br />(rest '(1 2 3))",
  "head-and-tail-of-empty-list": "<span style=\"color: gray\"><em>both evaluate to</em> nil</span>",
  "length<br-/>": "(length '(1 2 3))",
  "equality-test<br-/>": "(equal '(1 2 3) '(1 2 3))",
  "nth-element": "(nth 2 '(1 2 3 4))",
  "out-of-bounds-behavior": "nil",
  "element-index": "(position 7 '(5 6 7 8))",
  "concatenate<br-/>": "(append '(1 2 3) '(4 5 6))",
  "take<br-/>": "(subseq '(1 2 3 4) 0 2)",
  "drop<br-/>": "(nthcdr 2 '(1 2 3 4))",
  "last-element<br-/>": "(car (last '(1 2 3)))",
  "all-but-last-element": "(butlast '(1 2 3))",
  "reverse<br-/>": "(reverse '(1 2 3))",
  "sort<br-/>": "(sort '(3 2 4 1) '&lt;)",
  "dedupe<br-/>": "(remove-duplicates '(1 1 2 3))",
  "membership<br-/>": "(member 7 '(1 2 3)",
  "map": "(mapcar<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (x) (* x x))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3))",
  "filter": "(remove-if-not<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (x) (&gt; x 2))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3))<br /><br /><span style=\"color: gray\">; remove-if returns complement</span>",
  "reduce": "(reduce '-<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3 4)<br /><span style=\"white-space: pre-wrap;\">  </span>:initial-value 0)",
  "right-fold": "(reduce '-<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3 4)<br /><span style=\"white-space: pre-wrap;\">  </span>:initial-value 0<br /><span style=\"white-space: pre-wrap;\">  </span>:from-end t)",
  "iterate": "(dolist (x '(1 2 3))<br /><span style=\"white-space: pre-wrap;\">  </span>(print x)<br /><span style=\"white-space: pre-wrap;\">  </span>(print (- x)))",
  "universal-predicate": "(every<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (i) (= 0 (% i 2)))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3 4))",
  "existential-predicate": "(some<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (i) (= 0 (% i 2)))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 2 3 4))",
  "list-comprehension": "",
  "shuffle<br-/>": "",
  "set-head": "(setq a '(1 2 3)<br />(setcar a 3)",
  "set-tail": "(setq a '(1 2 3)<br />(setcar a 3)<br />(setcdr a '(4 5 6))",
  "manipulate-back": "(setq a '(1 2 3))<br />(push 4 a)<br />(pop a)",
  "flatten": "",
  "associative-array-lookup<br-/>": "(assoc 3 '((1 2) (3 4)))",
  "flat-associative-array-lookup<br-/>": "(getf '(1 2 3 4) 3)",
  "pair-literal<br-/>": "'(1 . 2)",
  "cons-cell-test": "(cons '(1 . 2))<br />(not (atom '(1 . 2)))",
  "translate-elements-recursively": "(sublis '((1 . 2) (3 . 4))<br /><span style=\"white-space: pre-wrap;\">  </span>'(1 (3 3 (1))))"
},
"fixed-length-arrays": {
  "fixed-len-array-literal": "[1 2 3]",
  "constructor<br-/>": "(vector 1 2 3)",
  "size<br-/>": "(length [1 2 3])",
  "lookup": "(elt [1 2 3] 0)",
  "update": "(setq v #(1 2 3))<br />(setf (aref v 2) 4)",
  "out-of-bounds-behavior": "",
  "array-to-list<br-/>": "(coerce [1 2 3] 'list)",
  "list-to-array<br-/>": "(coerce '(1 2 3) 'vector)",
  "reverse": "",
  "sort": "",
  "map": "",
  "filter": "",
  "reduce": ""
},
"dict": {
  "dict-literal": "<span style=\"color: gray\"><em>none</em></span>",
  "dict-ctor": "(setq h (make-hash-table :test 'equal))",
  "dict-pred": "(hash-table-p h)",
  "dict-size": "(hash-table-count h)",
  "dict-lookup": "(gethash \"t\" h)",
  "dict-update": "(puthash \"t\" 1 h)",
  "dict-missing-key": "<span style=\"color: gray\"><em>returns</em> nil</span>",
  "dict-is-key-present": "<span style=\"color: gray\"><em>none</em></span>",
  "dict-dele": "(remhash \"hello\" h)",
  "dict-merge": "",
  "dict-invert": "",
  "dict-iter": "(maphash<br /><span style=\"white-space: pre-wrap;\">  </span>(lambda (k v)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(print k)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(print v))<br /><span style=\"white-space: pre-wrap;\">  </span>h)",
  "dict-key-val-lists": "<span style=\"color: gray\"><em>none</em></span>"
},
"user-defined-types": {
  "defstruct": "(defstruct account id balance)",
  "struct": "(setq a<br /><span style=\"white-space: pre-wrap;\">  </span>(make-account :id 3 :balance 17.12))",
  "struct-getter<br-/>": "(account-id a)",
  "struct-setter<br-/>": "(setf (account-balance a) 0)",
  "struct-predicate<br-/>": "(account-p a)"
},
"func": {
  "define-function<br-/>": "(defun add (x y) (+ x y))",
  "can-function-and-variable-share-name": "<span style=\"color: gray\"><em>yes</em></span>",
  "optional-argument": "(defun add (a &amp;optional b)<br /><span style=\"white-space: pre-wrap;\">  </span>(if (null b) a (+ a b)))",
  "variable-number-of-arguments": "(defun add (a &amp;rest b)<br /><span style=\"white-space: pre-wrap;\">  </span>(if (null b)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(+ a (eval (cons '+ b)))))",
  "default-value": "<span style=\"color: gray\"><em>none</em></span>",
  "named-parameter": "(defun logarithm<br /><span style=\"white-space: pre-wrap;\">  </span>(&amp;key number &amp;key base)<br /><span style=\"white-space: pre-wrap;\">  </span>(if base<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(/ (log number) (log base))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(log number)))<br /><span style=\"white-space: pre-wrap;\"> </span><br /><span style=\"color: gray\"><em>order significant, not key names:</em></span><br />(logarithm :foo 8 :bar 2)",
  "return-multiple-values": "<span style=\"color: gray\">values <em>creates a list:</em></span><br />(defun sqrts (x)<br /><span style=\"white-space: pre-wrap;\">  </span>(values (sqrt x) (- (sqrt x))))",
  "assign-multiple-values-to-local-variables": "(multiple-value-bind<br /><span style=\"white-space: pre-wrap;\">  </span>(r1 r2)<br /><span style=\"white-space: pre-wrap;\">  </span>(sqrts 3)<br /><span style=\"white-space: pre-wrap;\">  </span>r2)",
  "assign-multiple-values-to-global-variables": "(multiple-value-setq (r1 r2) (sqrts 3))",
  "convert-list-to-multiple-values": "<span style=\"color: gray\"><em>multiple values are lists</em></span>",
  "assign-multiple-values-to-list": "<span style=\"color: gray\"><em>multiple values are lists</em></span>",
  "tail-call-optimization": "<span style=\"color: gray\"><em>no</em></span>",
  "lambda": "(lambda (x) (* x x))",
  "apply": "((lambda (x) (* x x)) 2)<br /><span style=\"white-space: pre-wrap;\"> </span><br />(apply<br /><span style=\"white-space: pre-wrap;\">  </span>#'(lambda (x) (* x x))<br /><span style=\"white-space: pre-wrap;\">  </span>'(2))"
},
"exec-control": {
  "progn<br-/>": "progn prog1 prog2",
  "loop": "(setq i 1)<br />(loop (print \"hello\")<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(if (&gt; i 10)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(return)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(setq i (+ i 1))))",
  "do": "(do ((i 1) (sum 0))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>((&gt; i 100) sum)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(setq sum (+ sum i))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(setq i (+ i 1)))<br /><span style=\"color: gray\">do* <em>initializes sequentially</em></span>",
  "dotimes": "(dotimes (i 10 nil)<br /><span style=\"white-space: pre-wrap;\">  </span>(print \"hello\\n\"))",
  "if<br-/>": "(if (&lt; x 0) (- x) x)",
  "when": "(when (&lt; x y)<br /><span style=\"white-space: pre-wrap;\">  </span>(print \"x is less \")<br /><span style=\"white-space: pre-wrap;\">  </span>(print \"than y\"))",
  "cond": "(cond ((&gt; x 0) 1)<br /><span style=\"white-space: pre-wrap;\">  </span>((= x 0) 0)<br /><span style=\"white-space: pre-wrap;\">  </span>(t -1))",
  "lazy-evaluation": "",
  "continuations": ""
},
"exceptions": {
  "error<br-/>": "(error \"failed\")",
  "handle-error": "(condition-case e<br /><span style=\"white-space: pre-wrap;\">  </span>(error \"failed\")<br /><span style=\"white-space: pre-wrap;\">  </span>(error (message \"error: %s\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(error-message-string e))))",
  "define-exception": "<span style=\"color: gray\"><em>only symbols and keywords can be thrown and caught</em></span>",
  "throw-exception": "(throw 'odd-err t)",
  "catch-exception": "(catch 'failed (throw 'failed nil) t)",
  "restart-case": "<span style=\"color: gray\"><em>none</em></span>",
  "invoke-restart": "<span style=\"color: gray\"><em>none</em></span>",
  "finally-clause": "(unwind-protect<br /><span style=\"white-space: pre-wrap;\">  </span>(error \"failure\")<br /><span style=\"white-space: pre-wrap;\">  </span>(print \"clean up\"))"
},
"streams": {
  "std-file-handles": "",
  "eof": "",
  "read-stdin": "",
  "chomp": "",
  "println": "",
  "format-stdout": "",
  "open-file": "",
  "open-file-write": "",
  "open-file-append": "",
  "close-file": "",
  "close-file-implicitly": "",
  "read-line": "",
  "iterate-file": "",
  "read-file-array": "",
  "read-file-str": "",
  "write-str": "",
  "write-line": "",
  "flush-file": "",
  "seek": "",
  "in-memory-stream": ""
},
"emacs-buffers": {
  "list-buffers": "<span style=\"color: gray\">;; list of buffer objects:</span><br />(buffer-list)<br /><br /><span style=\"color: gray\">;; name of first buffer in list:</span><br />(buffer-name (car (buffer-list)))<br /><br /><span style=\"color: gray\">;; name of current buffer:</span><br />(buffer-name (current-buffer))",
  "current-buffer": "<span style=\"color: gray\">;; name of current buffer:</span><br />(buffer-name (current-buffer))<br /><br /><span style=\"color: gray\">;; open in current pane:</span><br />(switch-to-buffer \"foo.txt\")<br /><br /><span style=\"color: gray\">;; open in other pane:</span><br />(switch-to-buffer-other-window<br /><span style=\"white-space: pre-wrap;\">  </span>\"bar.txt\")",
  "clear-buffer": "<span style=\"color: gray\">;; current buffer:</span><br />(erase-buffer)<br /><br /><span style=\"color: gray\">;; buffer named \"foo.txt:</span><br />(with-current-buffer \"foo.txt\"<br /><span style=\"white-space: pre-wrap;\">  </span>(erase-buffer))",
  "point": "<span style=\"color: gray\">;; 1-based index of char under cursor:</span><br />(point)<br /><br /><span style=\"color: gray\">;; go to beginning of current buffer:</span><br />(goto-char 1)<br /><br /><span style=\"color: gray\">;; go to end of current buffer:</span><br />(goto-char (buffer-size))",
  "search-and-set-point": "<span style=\"color: gray\">;; Set point to character after string.<br />;; 1st arg is position in buffer beyond<br />;;<span style=\"white-space: pre-wrap;\">   </span>which search stops.<br />;; If 2nd arg is true, return nil<br />;;<span style=\"white-space: pre-wrap;\">   </span>on failure, otherwise raise error.<br />;; 3rd argument is the occurrence<br />;;<span style=\"white-space: pre-wrap;\">   </span>of the string, if negative<br />;;<span style=\"white-space: pre-wrap;\">   </span>search backwards from point.</span><br />(search-forward \"lorem\" nil t 1)",
  "insert-at-string-point": "<span style=\"color: gray\">;; takes 1 or more args:</span><br />(insert \"lorem\" \" ipsum\")",
  "current-buffer-as-string": "(buffer-string)",
  "insert-file-contents-at-point": "(insert-file \"/etc/passwd\")",
  "mark": "<span style=\"color: gray\">;; to beginning of current buffer:</span><br />(set-mark 1)<br /><br /><span style=\"color: gray\">;; to point of current buffer:</span><br />(set-mark (point))"
},
"file": {
  "file-test": "(file-exists-p \"/etc/hosts\")<br /><br />(file-regular-p \"/etc/hosts\")",
  "file-size": "(eighth<br /><span style=\"white-space: pre-wrap;\">  </span>(file-attributes \"/etc/hosts\"))",
  "file-readable-writable-executable": "",
  "chmod": "(set-file-modes \"/tmp/foo\" #o755)",
  "last-modification-time": "",
  "cp-rm-mv": "(copy-file \"/tmp/foo\" \"/tmp/bar\")<br />(delete-file \"/tmp/foo\")<br />(rename-file \"/tmp/bar\" \"/tmp/foo\")",
  "symlink": "(make-symbolic-link \"/etc/hosts\" /tmp/hosts\")<br /><span style=\"color: gray\"><em>returns target if symlink or nil:</em></span><br />(file-symlink-p \"/tmp/hosts\")",
  "tmp-file": "(make-temp-file \"foo\")"
},
"dir": {
  "build-pathname": "",
  "dirname-basename": "(file-name-directory \"/etc/hosts\")<br /><br />(file-name-nondirectory<br /><span style=\"white-space: pre-wrap;\">  </span>\"/etc/hosts\")",
  "abs-pathname": "(expand-file-name \"..\")",
  "iterate-dir": "(dolist<br /><span style=\"white-space: pre-wrap;\">  </span>(file (directory-files \"/etc\"))<br /><span style=\"white-space: pre-wrap;\">  </span>(print file)))",
  "mkdir": "<span style=\"color: gray\"><em>creates parents if 2nd arg non-nil:</em></span><br />(make-directory \"/tmp/foo/bar\" t)",
  "recursive-cp": "",
  "rmdir": "(delete-directory \"/tmp/foo.d\")",
  "rm-rf": "(delete-directory \"/tmp/foo.d\" t)",
  "dir-test": "(file-directory-p \"/etc\")"
},
"processes-environment": {
  "cmd-line-arg": "<span style=\"color: gray\"><em>in shebang mode only:</em></span><br />command-line-args <span style=\"color: gray\"><em>or</em></span> argv",
  "program-name": "",
  "env-var": "(getenv \"HOME\")",
  "user-id-name": "",
  "exit": "",
  "external-cmd": "(shell-command \"ls /etc\")",
  "cmd-subst": "(shell-command-to-string \"ls /etc\")"
},
"lib-namespaces": {
  "complete-example": "",
  "compile-library": "$ emacs -batch -Q -L . \\<br /><span style=\"white-space: pre-wrap;\">  </span>-f batch-byte-compile a.el",
  "load-library<br-/>": "(require \"a\")",
  "load-library-in-subdirectory": "",
  "hot-patch": "(load \"a\")",
  "load-error": "<span style=\"color: gray\"><em>raises</em> file-err</span>",
  "library-path": "<span style=\"color: gray\">; adds directory to library path:</span><br />(add-to-list 'load-path (\"/home/ed/.emacs.d/lib\"))",
  "library-path-environment-variable": "<span style=\"color: gray\">EMACSLOADPATH</span>",
  "library-path-command-line-option": "$ emacs -L /foo/bar",
  "namespace-declaration": "<span style=\"color: gray\"><em>No namespaces; a common convention is to use a prefix on all identifiers in a library, separated from the rest of the identifier by a hyphen.</em></span>",
  "subnamespace-declaration": "",
  "namespace-separator": "",
  "import-definitions": "",
  "import-all-definitions-in-namespace": "",
  "namespace-shadow-avoidance": "",
  "identifier-shadow-avoidance": "",
  "package-manager-help": "",
  "list-installed-packages": "M-x list packages",
  "search-packages": "M-x list-packages",
  "install-package": "<span style=\"color: gray\"><em>Use</em> M-x list-packages <em>to bring up the package menu;</em> i <em>to select a package to install, and</em> x <em>to install it.</em></span>",
  "remove-package": "<span style=\"color: gray\"><em>In the package menu, use</em> d <em>to select a package to uninstall and</em> x <em>to uninstall it.</em></span>"
},
"objects": {
  "define-class": "",
  "make-instance": "",
  "read-attribute<br-/>": "",
  "write-attribute<br-/>": "",
  "define-method": "",
  "invoke-method<br-/>": "",
  "universal-superclass": "",
  "multiple-inheritance": ""
},
"lisp-macros": {
  "backquote-and-comma": "(setq op '+)<br />(eval <span style=\"white-space: pre-wrap;\">`</span>(,op 1 1))",
  "defmacro": "(defmacro rpn (arg1 arg2 op)<br /><span style=\"white-space: pre-wrap;\">  </span>(list op arg1 arg2))",
  "defmacro-w/-backquote": "(defmacro rpn (arg1 arg2 op)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">`</span>(,op ,arg1 ,arg2))",
  "macro-predicate": "<span style=\"color: gray\"><em>none</em></span>",
  "macroexpand": "(macroexpand '(rpn 1 2 +))",
  "splice-quote": "(defmacro add ( &amp;rest args )<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">`</span>(+ ,@args))",
  "recursive-macro": "(defmacro add (a &amp;rest b)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">`</span>(if (null ',b)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(+ ,a)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(+ ,a (add ,@b))))",
  "hygienic<br-/>": "<span style=\"color: gray\"><em>no</em></span>",
  "local-values": "(defmacro square-sum (x y)<br /><span style=\"white-space: pre-wrap;\">  </span>(let ((sum (gensym)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">`</span>(let ((,sum (+ ,x ,y)))<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(* ,sum ,sum))))"
},
"reflection": {
  "inspect-type<br-/>": "(type-of [1 2 3] 'vector)<br />(typep [1 2 3] 'vector)<br />(vectorp [1 2 3])",
  "instance-of": "",
  "basic-types": "",
  "sequence-data-types": "list vector",
  "docstring": "(describe-function 'mapcar)",
  "define-docstring": "(defun add (x y)<br /><span style=\"white-space: pre-wrap;\">  </span>\"add x and y\"<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))",
  "search-doc": "(apropos \"^add$\")<br /><span style=\"color: gray\"><em>none</em></span>"
},
"java-interop": {
  "new": "",
  "method": "",
  "class-method<br-/>": "",
  "chain<br-/>": "",
  "import": "",
  "to-java-array": ""
}
}
