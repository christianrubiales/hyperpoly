{

"version": {
  "version-used": "<span style=\"color: gray\"><em>C++11</em><br /><em>gcc 4.8</em><br /><em>clang 3.5</em></span>",
  "show-version": "$ g++ <span style=\"white-space: pre-wrap;\">--</span>version",
  "implicit-prologue": "#include &lt;iostream&gt;<br />#include &lt;string&gt;<br /><br />using namespace std;"
},
"grammar-execution": {
  "hello-world": "$ cat hello.cpp<br />#include &lt;iostream&gt;<br /><br />using namespace std;<br /><br />int main(int argc, char<span style=\"white-space: pre-wrap;\">**</span> arg) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"Hello, World!\" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}<br /><br />$ g++ -std=c++0x hello.cpp<br /><br />$ ./a.out",
  "file-suffixes": "foo.cpp<br />foo.h<br />foo.o",
  "block-delimiters": "{ }",
  "stmt-terminator": ";",
  "top-level-stmt": "<span style=\"color: gray\"><em>A source file will normally have</em> #include <em>directives at the top, followed by declarations, definitions, and namespaces containing declarations and definitions.<br /><br />After the preprocessor has finished processing a source file, the compilation unit will only contain declarations, definitions, and namespaces at the top level.</em></span>",
  "eol-comment": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> comment</span>",
  "multiple-line-comment": "<span style=\"color: gray\">/* comment<br />another comment */</span>"
},
"var-expr": {
  "local-var": "int i;<br />int j = 3;<br />int k(7);",
  "uninitialized-local-var": "<span style=\"color: gray\"><em>The behavior is undefined.<br /><br />Most implementations do not zero-initialize stack variables, so the value will be whatever happened to be in memory.</em></span>",
  "global-var": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> in foo.cpp and outside of any function<br /><span style=\"white-space: pre-wrap;\">//</span> or class definition:</span><br />int foo = 7;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> in bar.cpp and outside of any function<br /><span style=\"white-space: pre-wrap;\">//</span> or class definition:</span><br />extern int foo;",
  "uninitialized-global-var": "<span style=\"color: gray\"><em>Zero initialized: numeric types and pointers are set to zero. Classes, structs, and arrays have all of their members or elements zero-initialized recursively.</em></span>",
  "write-once-var": "const int i = 7;",
  "assignment": "int n;<br />n = 3;",
  "compound-assignment": "+= -= *= /= %=<br /><span style=\"white-space: pre-wrap;\">&lt;&lt;= &gt;&gt;= </span>&amp;= ^= |=",
  "incr-decr": "int n = 1;<br />int one = n++;<br />int three = ++n;<br />int two = <span style=\"white-space: pre-wrap;\">--</span>n;",
  "addr": "int i(3);<br />int* ip = &amp;i;",
  "dereference": "int i(3);<br />int* ip = &amp;i;<br />int i2 = *ip + 1;",
  "type-size": "cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> sizeof(int) <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> sizeof(int*) <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "addr-arith": "",
  "unique-ptr": "",
  "ref-cnt-ptr": "",
  "weak-ptr": "",
  "allocate-heap": "int* ip = new int;",
  "uninitialized-heap": "<span style=\"color: gray\"><em>Memory allocated by the</em> new <em>operator is zero-initialized.</em></span>",
  "free-heap": "delete i;",
  "null": "NULL",
  "coalesce": "string s1 = s2 <span style=\"white-space: pre-wrap;\">||</span> \"was null\";"
},
"arithmetic-logic": {
  "boolean-type": "bool",
  "true-false": "true false",
  "falsehoods": "false 0 0.0 NULL",
  "logical-op": "&amp;&amp; <span style=\"white-space: pre-wrap;\">||</span> !<br />and or not",
  "relational-op": "== != &lt; &gt; &lt;= &gt;=",
  "int-type": "signed char n1;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 1+ bytes</span><br />short int n2;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 2+ bytes</span><br />int n3;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 2+ bytes</span><br />long int n4;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 4+ bytes</span><br />long long int n5;<span style=\"white-space: pre-wrap;\"> </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 4+ bytes</span>",
  "unsigned-type": "unsigned char n1;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 1+ bytes</span><br />unsigned short int n2;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 2+ bytes</span><br />unsigned int n3;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 2+ bytes</span><br />unsigned long int n4;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 4+ bytes</span><br />unsigned long long int n5; <span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 4+ bytes</span>",
  "float-type": "float x1;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 4 bytes</span><br />double x2;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 8 bytes</span><br />long double x3; <span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 16 bytes</span>",
  "fixed-type": "<span style=\"color: gray\"><em>none</em></span>",
  "arithmetic-op": "+ - * / %",
  "int-div": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> evaluates to 2:</span><br />7 / 3",
  "int-div-zero": "<span style=\"color: gray\"><em>process sent a</em></span> SIGFPE <span style=\"color: gray\"><em>signal</em></span>",
  "float-div": "7 / static_cast&lt;float&gt;(3)",
  "float-div-zero": "inf<br />nan<br />-inf<br /><br /><span style=\"color: gray\"><em>There are no portably defined literals or constants for the above values.</em></span>",
  "power": "#include &lt;cmath&gt;<br /><br />double x = pow(2.0, 32.0);",
  "sqrt": "#include &lt;cmath&gt;<br /><br />double x = sqrt(2);",
  "sqrt-negative-one": "nan",
  "transcendental-func": "#include &lt;cmath&gt;<br /><br />exp log log2 log10<br />sin cos tan<br />asin acos atan<br />atan2",
  "transcendental-const": "#include &lt;cmath&gt;<br /><br />double e = M_E;<br />double pi = M_PI;",
  "float-truncation": "#include &lt;cmath&gt;<br /><span style=\"white-space: pre-wrap;\"> </span><br />double x = 3.7;<br /><span style=\"white-space: pre-wrap;\"> </span><br />long trnc = static_cast&lt;long&gt;(x);<br />long rnd = round(x);<br />long flr = floorl(x);<br />long cl = ceill(x);",
  "absolute-val": "#include &lt;cmath&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> fabs()</span><br />#include &lt;cstdlib&gt;<span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> abs()</span><br /><br />int n = -7;<br />int absn = abs(n);<br /><br />double x = -7.77;<br />double absx = fabs(x);",
  "int-overflow": "<span style=\"color: gray\"><em>modular arithmetic<br /><br />The C standard does not define behavior for signed integers, however.</em></span>",
  "float-overflow": "<span style=\"color: gray\"><em>no behavior defined by standard; many implementations return</em> inf</span>",
  "float-limits": "#include &lt;cfloat&gt;<br /><br />FLT_MAX<br />FLT_MIN<br />DBL_MAX<br />DBL_MIN<br />LDBL_MAX<br />LDBL_MIN",
  "complex-construction": "#include &lt;complex&gt;<br /><br />complex&lt;double&gt; z(1.0, 2.0);",
  "complex-decomposition": "z.real()<br />z.imag()<br />arg(z)<br />abs(z)<br />conj(z)",
  "random-num": "#include &lt;random&gt;<br /><br />default_random_engine dre;<br /><br />uniform_int_distribution&lt;int&gt; uid(0, 99);<br />uniform_real_distribution&lt;double&gt;<br /><span style=\"white-space: pre-wrap;\">  </span>urd(0.0, 1.0);<br />normal_distribution&lt;double&gt; nd(0.0, 1.0);<br /><br />int i = uid(dre);<br />double x = urd(dre);<br />double y = nd(dre);",
  "random-seed": "#include &lt;random&gt;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> set seed in constructor:</span><br />default_random_engine dre(17);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> set seed of existing engine:</span><br />dre.seed(17);",
  "bit-op": "<span style=\"white-space: pre-wrap;\"> &lt;&lt; &gt;&gt; &amp; | ^ ~ </span><br /><span style=\"white-space: pre-wrap;\"> </span>bitand bitor compl<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">&gt;&gt;</span> <em>is arithmetic right shift on signed integers and logical right shift on unsigned integers</em></span>",
  "binary-octal-hex-literals": "0b0101010<br />052<br />0x2a",
  "radix": ""
},
"str": {
  "str-type": "string s(\"lorem ipsum\");<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> convert to C string:</span><br />const char* s2 = s.c_str();",
  "str-literal": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> const char*:</span><br />\"don't say \\\"no\\\"\"",
  "newline-literal": "<span style=\"color: gray\"><em>Newlines in string literals are ignored.</em></span>",
  "str-literal-escape": "\\a \\b \\f \\n \\r \\t \\v<br />\\\\ \\\" \\'<br />\\x<span style=\"color: gray\"><em>hh</em></span> \\<span style=\"color: gray\"><em>o</em></span> \\<span style=\"color: gray\"><em>oo</em></span> \\<span style=\"color: gray\"><em>ooo</em></span>",
  "allocate-str": "string* s = new string(\"hello\");",
  "mutable-str": "string s(\"bar\");<br />s[2] = 'z';",
  "copy-str": "string s(\"bar\");<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> use assignment or copy constructor:</span><br />string s2 = s;<br />string s3(s);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> s contains \"baz\";</span><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> s2 and s3 contain \"bar\":</span><br />s[2] = 'z';",
  "fmt-str": "#include &lt;sstream&gt;<br /><br />ostringstream oss;<br />oss <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"Spain: \" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> 7;<br />string s(oss.str());",
  "compare-str": "string s1(\"hello\");<br />string s2(\"world\");<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> negative if s1 lexically before s2;<br /><span style=\"white-space: pre-wrap;\">//</span> zero if s1 and s2 are equal:</span><br />int result1 = s1.compare(s2);<br /><br />bool result2 = s1 == s2;",
  "str-concat": "string s(\"hello\");<br />string s2 = s + \" world\";<br />s += \" world\";",
  "str-replicate": "string hbar(80, '-');",
  "translate-case": "#include &lt;algorithm&gt;<br /><br />string s(\"foo\");<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> in place:</span><br />transform(s.begin(), s.end(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>s.begin(), ::toupper);<br />transform(s.begin(), s.end(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>s.begin(), ::tolower);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> non-destructive:</span><br />string s2;<br />s2.resize(s.size();<br />transform(s.begin(), s.end(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>s2.begin(), ::toupper);",
  "trim": "#include &lt;algorithm&gt;<br /><br />string s(\" hello \");<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> trim in place on left:</span><br />s.erase(<br /><span style=\"white-space: pre-wrap;\">  </span>s.begin(),<br /><span style=\"white-space: pre-wrap;\">  </span>find_if(<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>s.begin(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>s.end(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>not1(ptr_fun&lt;int, int&gt;(isspace))<br /><span style=\"white-space: pre-wrap;\">  </span>)<br />);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> trim in place on right:</span><br />s.erase(<br /><span style=\"white-space: pre-wrap;\">  </span>find_if(<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>s.rbegin(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>s.rend(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>not1(ptr_fun&lt;int, int&gt;(isspace))<br /><span style=\"white-space: pre-wrap;\">  </span>).base(),<br /><span style=\"white-space: pre-wrap;\">  </span>s.end()<br />);",
  "pad": "#include &lt;iomanip&gt;<br />#include &lt;sstream&gt;<br /><br />string s(\"hello\");<br />string rpad(s);<br />rpad += string(10 - s.length(), ' ');<br /><br />ostringstream oss;<br />oss <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> setw(10) <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> s;<br />string lpad(oss.str());",
  "num-to-str": "char buf[100];<br />long n = 123;<br /><br />sprintf(buf, \"%ld\", n);<br /><span style=\"color: gray\">/* prevent buffer overflow: */</span><br />snprintf(buf, 100, \"%ld\", n);",
  "str-to-num": "#include &lt;sstream&gt;<br /><br />stringstream ss(\"7 14.3 12\");<br />int n1;<br />double x;<br />long n2;<br /><br />ss <span style=\"white-space: pre-wrap;\">&gt;&gt;</span> n1 <span style=\"white-space: pre-wrap;\">&gt;&gt;</span> x <span style=\"white-space: pre-wrap;\">&gt;&gt;</span> n2;",
  "join": "",
  "split": "",
  "serialize": "",
  "str-length": "string s(\"hello\");<br />size_t len = s.length();",
  "index-substr": "string(\"hello\").find(\"ll\")",
  "extract-substr": "string(\"hello\").substr(2, 2)",
  "char-type": "char<br />wchar_t",
  "char-literal": "char n = 'X';",
  "test-char": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> functions have this signature:<br /><span style=\"white-space: pre-wrap;\">//</span><br /><span style=\"white-space: pre-wrap;\">//</span> <span style=\"white-space: pre-wrap;\">  </span>int (*)(int):<br /><span style=\"white-space: pre-wrap;\">//</span></span><br />isalpha<br />isdigit<br />isspace<br />isupper<br />islower"
},
"regex": {
  "regex-type": "regex<br />wregex",
  "char-class-abbrev": ". \\d \\D \\s \\S \\w \\W",
  "regex-anchors": "^ $ \\b \\B",
  "regex-lookahead": "(?=<span style=\"color: gray\"><em>subpattern</em></span>)<br />(?!<span style=\"color: gray\"><em>subpattern</em></span>)",
  "regex-test": "#include &lt;regex&gt;<br /><br />regex rx(\".*ll.*\");<br />bool match = regex_match(\"hello\", rx);",
  "case-insensitive-regex": "#include &lt;regex&gt;<br /><br />regex rx(\"lorem\", icase);<br />bool match = regex_match(\"Lorem\", rx);",
  "regex-modifiers": "",
  "subst": "",
  "match-prematch-postmatch": "",
  "group-capture": ""
},
"dates-time": {
  "date-time-type": "",
  "current-date-time": "",
  "unix-epoch": "",
  "date-time-to-str": "",
  "format-date": "",
  "parse-date": "",
  "date-subtraction": "",
  "add-duration": "",
  "date-parts": "",
  "time-parts": "",
  "build-datetime": ""
},
"fixed-length-arrays": {
  "fixed-len-array-stack": "int a[10];",
  "fixed-len-array-heap": "int* a = new int[10];",
  "free-fixed-len-array-heap": "delete[] a;",
  "fixed-len-array-init-list": "int a[] = {1, 2, 3};",
  "fixed-len-array-size": "int a[10];<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> stack arrays only:</span><br />size_t len = sizeof(a) / sizeof(a[0]);",
  "fixed-len-array-lookup": "int first = a[0];",
  "fixed-len-array-update": "a[0] = 7;",
  "fixed-len-array-out-of-bounds": "<span style=\"color: gray\"><em>No defined behavior</em></span><br /><br /><span style=\"color: gray\"><em>An out-of-bounds lookup may return the value the memory location contains; an out-of-bounds update may cause memory corruption. The system may detect an invalid address and send the process a</em> SIGSEGV.</span>",
  "copy-fixed-len-array": "const size_t LEN(4);<br />int src[LEN] = {3, 2, 4, 1};<br />int dest[LEN];<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> 3rd arg is number of bytes to copy:</span><br />memcpy(dest, src, LEN * sizeof(src[0]));",
  "fixed-len-array-as-func-arg": "void<br />reverse(int* a, size_t len) {<br /><span style=\"white-space: pre-wrap;\">  </span>for (int i = 0; i &lt; len / 2; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>int tmp = a[len - i - 1];<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a[len - i - 1] = a[i];<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a[i] = tmp;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br /><br />const size_t LEN(4);<br />int a[LEN] = {3, 2, 4, 1};<br />reverse(a, LEN);",
  "iterate-over-fixed-len-array": "const size_t LEN(4);<br />int a[LEN] = {3, 2, 4, 1};<br /><br />for (int i = 0; i &lt; LEN; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"value at \" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> i <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \" is \"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"white-space: pre-wrap;\">&lt;&lt;</span> a[i] <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}",
  "sort-fixed-len-array": "#include &lt;cstdlib&gt;<br /><br />int<br />comp(const void* ap, const void* bp) {<br /><span style=\"white-space: pre-wrap;\">  </span>int a = *(int*)ap;<br /><span style=\"white-space: pre-wrap;\">  </span>int b = *(int*)bp;<br /><span style=\"white-space: pre-wrap;\">  </span>return a &lt; b ? -1 : (a == b ? 0 : 1);<br />}<br /><br />const size_t LEN(4);<br />int a[LEN] = {3, 2, 1, 4};<br /><br />qsort(a, LEN, sizeof(a[0]), &amp;comp);"
},
"resizable-arrays": {
  "decl-resizable-array": "#include &lt;vector&gt;<br /><br />vector &lt;int&gt; a;",
  "resizable-array-init-list": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a = {1, 2, 3};<br />vector&lt;int&gt; a2({7, 8, 9});",
  "resizable-array-size": "size_t len = a.size();",
  "resizable-array-capacity": "size_t cap = a.capacity();<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> will not decrease capacity:</span><br />a.reserve(10);",
  "resizable-array-empty-test": "bool is_empty = a.empty();<br />a.clear();",
  "resizable-array-lookup": "int n = a[0];<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> can raise out_of_range:</span><br />int n2 = a.at(0);",
  "resizable-array-update": "a[2] = 4;",
  "resizable-array-out-of-bounds": "<span style=\"color: gray\"><em>using [] with out-of-bounds index has undefined behavior</em></span>",
  "resizable-array-elem-index": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({6, 7, 8, 9});<br /><br />auto iter = find(a.cbegin(), a.cend(), 8);<br />if (iter != a.cend()) {<br /><span style=\"white-space: pre-wrap;\">  </span>size_t pos = *iter;<br />}",
  "slice-resizable-array": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({6, 7, 8, 9});<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> a2 contains {7, 8}:</span><br />vector&lt;int&gt; a2(a.cbegin() + 1,<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span>a.cbegin() + 3);",
  "slice-resizable-array-to-end": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({6, 7, 8, 9});<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> a2 contains {7, 8, 9}:</span><br />vector&lt;int&gt; a2(a.cbegin() + 1, a.cend());",
  "resizable-array-back": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({6, 7, 8});<br /><br />a.push_back(9);<br />int elem = a.pop_back();",
  "resizable-array-front": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({6, 7, 8});<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> slower than manipulating back:</span><br />a.insert(a.cbegin(), 5);<br />int elem = a[0];<br />a.erase(a.cbegin());",
  "concat-resizable-array": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a1({1, 2, 3});<br />vector&lt;int&gt; a2({4, 5, 6});<br /><br />a1.insert(a1.cend(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a2.cbegin(),<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a2.cend());",
  "replicate-resizable-array-elem": "#include &lt;vector&gt;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> array of 10 zeros:</span><br />vector&lt;int&gt; a(10, 0);",
  "copy-resizable-array": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({1, 2, 3});<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> copy constructor:</span><br />vector&lt;int&gt; a2(a);<br />vector&lt;int&gt; a3;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> assignment performs copy:</span><br />a3 = a;",
  "resizable-array-as-func-arg": "<span style=\"color: gray\"><em>use reference or pointer to avoid copying array</em></span>",
  "iterate-over-resizable-array": "#include &lt;vector&gt;<br /><br />int sum(0);<br />vector&lt;int&gt; a({1, 2, 3});<br /><br />for (const auto&amp; n: a) {<br /><span style=\"white-space: pre-wrap;\">  </span>sum += n;<br />}",
  "indexed-array-iteration": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({6, 7, 8});<br /><br />for (auto iter = a.cbegin();<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span>iter != a.cend();<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span>++iter) {<br /><br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"value at \" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> iter - a.cbegin()<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \" is \" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> *iter <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}",
  "reverse-array": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({1, 2, 3});<br />vector&lt;int&gt; a2(a.crbegin(), a.crend());",
  "sort-array": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({3, 2, 4, 1});<br />sort(a.begin(), a.end());",
  "dedupe-array": "#include &lt;set&gt;<br />#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({1, 1, 2, 2, 3});<br />set&lt;int&gt; tmp(a.cbegin(), a.cend());<br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> often unnecessary since sets provide<br /><span style=\"white-space: pre-wrap;\">//</span> many of the same methods as vectors:</span><br />vector&lt;int&gt; a2(tmp.cbegin(), tmp.cend());",
  "membership": "#include &lt;vector&gt;<br /><br />vector&lt;int&gt; a({1, 2, 3});<br />if (find(a.cbegin(), a.cend(), 7) !=<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>a.cend()) {<br /><br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"contains 7\" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}"
},
"tuples": {
  "tuple-ctor": "tuple&lt;string, int, float&gt; tup(\"foo\", 1, 3.7);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> invokes default constructors for elements:</span><br />tuple&lt;string, int, float&gt; tup2;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> element types are inferred:</span><br />auto tup3 = make_tuple(\"foo\", 1, 3.7);",
  "tuple-lookup": "tuple&lt;string, int, float&gt; tup(\"foo\", 1, 3.7);<br /><br />string s = get&lt;0&gt;(tup);<br />int i = get&lt;1&gt;(tup);<br />float x = get&lt;2&gt;(tup);",
  "tuple-decompose": "tuple&lt;string, int, float&gt; tup(\"foo\", 1, 3.7);<br />string s;<br />float x;<br /><br />tie(s, ignore, x) = tup;",
  "tuple-update": "get&lt;0&gt;(tup) = \"bar\";",
  "tuple-len": "tuple_size&lt;decltype(tup)&gt;::value",
  "pair-ctor": "pair &lt;string, int&gt; p2(\"foo\", 7);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> invokes default constructors for elements:</span><br />pair &lt;string, int&gt; p1;<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> element types are inferred:</span><br />auto p3 = make_pair(\"foo\", 7);",
  "pair-lookup": "auto p = make_pair(\"foo\", 7);<br /><br />string s = p.first;<br />int i = p.second;",
  "pair-update": "p.first = \"bar\";<br />p.second = 8;"
},
"dict": {
  "dict-ctor": "#include &lt;map&gt;<br /><br />map&lt;string, int&gt; m;",
  "dict-lookup": "m[\"hello\"] = 5;<br />cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> m[\"hello\"] <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "dict-size": "m.size()",
  "dict-delete": "m.erase(m.find(\"hello\"));",
  "dict-missing-key": "<span style=\"color: gray\"><em>returns element created by default constructor of value type</em></span>",
  "dict-iter": "map&lt;string,int&gt;::iterator mi;<br />for (mi = m.begin(); mi != m.end(); ++mi) {<br /><span style=\"white-space: pre-wrap;\">  </span>printf(\"%s %d\", mi-&gt;first, mi-&gt;second)<br />}"
},
"func": {
  "decl-func": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> parameter names are optional:</span><br />int<br />add(int m, int n);",
  "def-func": "int<br />add(int m, int n) {<br /><span style=\"white-space: pre-wrap;\">  </span>return m + n;<br />}",
  "call-func": "int sum = add(3, 7);",
  "def-static-class-method": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Ops.h:</span><br />class Ops {<br />public:<br /><span style=\"white-space: pre-wrap;\">  </span>static int add(int m, int n);<br />};<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Ops.cpp:</span><br />int Ops::add(int m, int n) {<br /><span style=\"white-space: pre-wrap;\">  </span>return m + n;<br />}",
  "invoke-static-class-method": "int sum = Ops::add(3, 7);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> class name not needed<br /><span style=\"white-space: pre-wrap;\">//</span> inside class namespace:</span><br />int sum = add(3, 7);",
  "overload-func": "int add(int m, int n) {<br /><span style=\"white-space: pre-wrap;\">  </span>return m + n;<br />}<br /><br />float add(float x, float y) {<br /><span style=\"white-space: pre-wrap;\">  </span>return x + y;<br />}",
  "default-arg": "#include &lt;cmath&gt;<br /><br />float<br />logarithm(float x, float base = 10.0) {<br /><span style=\"white-space: pre-wrap;\">  </span>return log(x) / log(base);<br />}",
  "variable-num-arg": "",
  "named-param": "<span style=\"color: gray\"><em>none</em></span>",
  "pass-by-val": "int add1(int n) {<br /><span style=\"white-space: pre-wrap;\">  </span>return ++n;<br />}<br /><br />int i(7);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> set i2 to 8 w/o modifying i:</span><br />int i2 = add1(i);",
  "pass-by-ref": "int add1(int&amp; n) {<br /><span style=\"white-space: pre-wrap;\">  </span>return ++n;<br />}<br /><br />int i(7);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> set i and i2 to 8:</span><br />int i2 = add1(i);",
  "pass-by-addr": "int add1(int* n) {<br /><span style=\"white-space: pre-wrap;\">  </span>return ++*n;<br />}<br /><br />int i(7);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> set i and i2 to 8:</span><br />int i2 = add1(&amp;i);",
  "retval": "<span style=\"color: gray\"><em>argument of</em> return; <em>type must be declared</em></span>",
  "no-retval": "void<br />message(const string&amp; msg) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> msg <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}",
  "recursive-func": "int<br />factorial(int n) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (n &lt;= 1) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>return 1;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>return n * factorial(n - 1);<br />}",
  "anon-func-literal": "auto add = [](int n, int m) {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + m;<br />};",
  "invoke-anonymous-func": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span>on variable holding anon. function:</span><br />int sum = add(3, 7);<br /><br /><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> on lambda expression:</span><br />int sum2 = [](int n, int m) {<br /><span style=\"white-space: pre-wrap;\">  </span>return n + m;<br />}(3, 7);",
  "closure": "",
  "func-private-state": "int<br />counter() {<br /><span style=\"white-space: pre-wrap;\">  </span>static int i = 0;<br /><span style=\"white-space: pre-wrap;\">  </span>return ++i;<br />}",
  "func-as-val": "",
  "overload-op": "Rational Rational::operator+(Rational&amp; o) {<br /><span style=\"white-space: pre-wrap;\">  </span>return Rational(this-&gt;num * o.denom + o.num * this-&gt;denom, this-&gt;denom * o.denom);<br />}"
},
"exec-control": {
  "if": "int signum;<br /><br />if (n &gt; 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 1;<br />}<br />else if (n == 0) {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = 0;<br />}<br />else {<br /><span style=\"white-space: pre-wrap;\">  </span>signum = -1;<br />}",
  "dangling-else": "if (n == 0)<br /><span style=\"white-space: pre-wrap;\">  </span>if (m == 0)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"n and m are zero\" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br /><span style=\"white-space: pre-wrap;\">  </span>else<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"n is zero; m isn't\" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "switch": "const int INVALID_BINARY_DIGIT(-1);<br />int bin_digit;<br /><br />switch(n) {<br />case 0:<br />case 1:<br /><span style=\"white-space: pre-wrap;\">  </span>bin_digit = n;<br /><span style=\"white-space: pre-wrap;\">  </span>break;<br />default:<br /><span style=\"white-space: pre-wrap;\">  </span>bin_digit = INVALID_BINARY_DIGIT;<br /><span style=\"white-space: pre-wrap;\">  </span>break;<br />}",
  "while": "int i(1), fact(1), n(10);<br /><br />while (i &lt; n) {<br /><span style=\"white-space: pre-wrap;\">  </span>fact *= i;<br /><span style=\"white-space: pre-wrap;\">  </span>++i;<br />}",
  "for": "int fact, n(10);<br /><br />for (int i = 1, fact = 1; i &lt;= n; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>fact *= i;<br />}",
  "break": "int data[4] = {3, 2, 0, 1};<br />int i;<br />bool has_zero(false);<br /><br />for (i = 0; i &lt; 4; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (data[i] == 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>has_zero = true;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>break;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "break-nested-loops": "int data[2][2] = <span style=\"white-space: pre-wrap;\">{{</span>3, 2}, {0, 1<span style=\"white-space: pre-wrap;\">}}</span>;<br />int i, j;<br />bool has_zero(false);<br /><br />for (i = 0; i &lt; 2; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>for (j = 0; j &lt; 2; ++j) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>if (data[i][j] == 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>has_zero = true;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>goto end_of_loops;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br />:end_of_loops",
  "continue": "int a[4] = {3, 2, 0, 1};<br /><br />for (int i = 0; i &lt; 4; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (a[i] == 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>continue;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> 1.0 / a[i] <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}",
  "goto": ""
},
"exceptions": {
  "base-exc": "<span style=\"color: gray\"><em>Any type can be thrown.<br /><br />All exceptions thrown by the language or the standard library derive from</em> exception, <em>defined in</em> &lt;exception&gt;.</span>",
  "predefined-exc": "#include &lt;exception&gt;<br />#include &lt;stdexcept&gt;<br />#include &lt;system_error&gt;<br />#include &lt;typeinfo&gt;<br /><br />exception<br /><span style=\"white-space: pre-wrap;\">  </span>logic_error<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>domain_error<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>invalid_argument<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>length_error<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>out_of_range<br /><span style=\"white-space: pre-wrap;\">  </span>runtime_error<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>system_error<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>ios_base::failure<br /><span style=\"white-space: pre-wrap;\">  </span>bad_cast<br /><span style=\"white-space: pre-wrap;\">  </span>bad_exception<br /><span style=\"white-space: pre-wrap;\">  </span>bad_alloc",
  "raise-exc": "#include &lt;cstdlib&gt;<br />#include &lt;stdexcept&gt;<br /><br />void risky() {<br /><span style=\"white-space: pre-wrap;\">  </span>if (rand() &lt; 10) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>throw runtime_error(\"bam!\");<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "handle-exc": "#include &lt;stdexcept&gt;<br /><br />try {<br /><span style=\"white-space: pre-wrap;\">  </span>risky();<br />}<br />catch (const exception &amp;e) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> e.what() <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}",
  "def-exc": "#include &lt;stdexcept&gt;<br /><br />class Bam : public runtime_error {<br />public:<br /><span style=\"white-space: pre-wrap;\">  </span>Bam() : runtime_error(\"bam!\") {}<br />};<br /><br />throw Bam();",
  "re-raise-exc": "#include &lt;stdexcept&gt;<br /><br />try {<br /><span style=\"white-space: pre-wrap;\">  </span>risky();<br />}<br />catch (const exception&amp; e) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"an error occurred<span style=\"white-space: pre-wrap;\">...</span>\" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br /><span style=\"white-space: pre-wrap;\">  </span>throw;<br />}",
  "catch-all-handler": "#include &lt;stdexcept&gt;<br /><br />try {<br /><span style=\"white-space: pre-wrap;\">  </span>risky();<br />}<br />catch (<span style=\"white-space: pre-wrap;\">...</span>) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"an error was ignored\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}",
  "multiple-handlers": "#include &lt;stdexcept&gt;<br /><br />try {<br /><span style=\"white-space: pre-wrap;\">  </span>risky();<br />}<br />catch (const system_error &amp;e) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"system error: \" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> e.name()<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}<br />catch (const exception &amp;e) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;</span>&lt; \"exception: \" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> e.what()<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\"> </span><span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}<br />catch (<span style=\"white-space: pre-wrap;\">...</span>) {<br /><span style=\"white-space: pre-wrap;\">  </span>cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"unknown error\" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}",
  "uncaught-exc": "<span style=\"color: gray\"><em>calls</em> terminate() <em>which by default calls</em> abort()</span>",
  "error-msg": "#include &lt;exception&gt;<br /><br />try {<br /><span style=\"white-space: pre-wrap;\">  </span>risky();<br />}<br />catch (const exception &amp;e) {<br /><span style=\"white-space: pre-wrap;\">  </span>const chae *msg = e.what();<br />}",
  "errno": "#include &lt;system_error&gt;<br /><br />try {<br /><span style=\"white-space: pre-wrap;\">  </span>risky();<br />}<br />catch (const system_error &amp;e {<br /><span style=\"white-space: pre-wrap;\">  </span>int err_code_val = e.code().value();<br />}",
  "finally-clause": "<span style=\"color: gray\"><em>none</em></span>",
  "exc-specification": "<span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> Use noexcept to declare that a function<br /><span style=\"white-space: pre-wrap;\">//</span> does not raise exceptions;<br /><span style=\"white-space: pre-wrap;\">//</span> declaring which exceptions a function<br /><span style=\"white-space: pre-wrap;\">//</span> raises is deprecated in C++11.</span><br />int<br />add(int a, int b) noexcept {<br /><span style=\"white-space: pre-wrap;\">  </span>return a + b;<br />}"
},
"concurrency": {
  "start-thread": "",
  "terminate-current-thread": "",
  "terminate-other-thread": "",
  "list-threads": "",
  "wait-on-thread": "",
  "lock": "",
  "create-msg-queue": "",
  "send-msg": "",
  "receive-msg": ""
},
"file-handles": {
  "std-file-handles": "cin<br />cout<br />cerr<br />clog <span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> buffered cerr by default</span>",
  "read-line-stdin": "string s;<br /><br />cin <span style=\"white-space: pre-wrap;\">&gt;&gt;</span> s;",
  "printf": "cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> \"count: \" <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> 7 <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "read-from-file": "#include &lt;fstream&gt;<br /><br />string line;<br />ifstream f(\"/etc/passwd\");<br /><br />if (f.is_open()) {<br /><span style=\"white-space: pre-wrap;\">  </span>while (!f.eof()) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>getline(f, line);<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> process line</span><br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>f.close();<br /><span style=\"white-space: pre-wrap;\">  </span>if ( 0 != f.fail() ) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> handle error</span><br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}<br />else {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> handle error</span><br />}",
  "write-to-file": "#include &lt;fstream&gt;<br /><br />ofstream f(\"/tmp/test4\");<br />int i;<br /><br />for (i = 0; i &lt; 10; ++i) {<br /><span style=\"white-space: pre-wrap;\">  </span>f <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> i <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;<br />}<br />f.close();<br />if (0 != f.fail()) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\"><span style=\"white-space: pre-wrap;\">//</span> handle error</span><br />}"
},
"file": {
  "file-test": "",
  "file-size": "",
  "readable-writable-executable": "",
  "chmod": "",
  "file-cp-rm-mv": ""
},
"file-fmt": {
  "csv": "",
  "json": "",
  "build-xml": "",
  "parse-xml": "",
  "parse-html": ""
},
"dir": {
  "build-pathname": "",
  "dirname-basename": "#include &lt;libgen.h&gt;<br /><br />string s1 = dirname(\"/etc/hosts\");<br />string s2 = basename(\"/etc/hosts\");",
  "absolute-pathname": "#include &lt;climits&gt;<br />#include &lt;cstdlib&gt;<br /><br />char buf[PATH_MAX];<br />if (realpath(\"..\", buf) == NULL) {<br /><span style=\"white-space: pre-wrap;\">  </span>throw exception();<br />}<br />else {<br /><span style=\"white-space: pre-wrap;\">  </span>string path(buf);<br />}",
  "iterate-dir": "",
  "glob": "",
  "mkdir": "",
  "recursive-cp": "",
  "rmdir": "",
  "rm-rf": "",
  "dir-test": "",
  "unused-dir": "",
  "system-tmp-dir": ""
},
"processes-environment": {
  "signature-of-main": "int main(int argc, char<span style=\"white-space: pre-wrap;\">**</span> argv) {",
  "first-argument<br-/>": "<span style=\"color: gray\"><em>pathname of executable</em></span>",
  "environment-variable": "#include &lt;stdlib.h&gt;<br /><br />char* home = getenv(\"HOME\");<br />setenv(\"EDITOR\", \"emacs\", 1);<br />unsetenv(\"EDITOR\");",
  "iterate-through-environment-variables": ""
},
"lib-namespaces": {
  "std-lib-name": "<span style=\"color: gray\"><em>C++ Standard Library</em></span>",
  "declare-namespace": "namespace foo {<br /><span style=\"white-space: pre-wrap;\">  </span>namespace bar {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>class Baz {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>static const int ANSWER = 42;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>};<br /><span style=\"white-space: pre-wrap;\">  </span>}<br />}",
  "multiple-namespaces-per-file": "<span style=\"color: gray\"><em>yes</em></span>",
  "namespaces-map-to-directories": "<span style=\"color: gray\"><em>no</em></span>",
  "import-namespace": "using namespace foo::bar;<br /><br />cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> Baz::ANSWER <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "import-part-of-namespace": "using namespace foo;<br /><br />cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> bar::Baz::ANSWER <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "import-symbol": "using foo::bar::Baz;<br />cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> Baz::ANSWER <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "import-static-symbol": "<span style=\"color: gray\"><em>none</em></span>",
  "import-position<br-/>": "<span style=\"color: gray\"><em>anywhere a statement is legal</em></span>",
  "using-a-symbol-that-hasn't-been-imported": "cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> foo::bar::Baz::ANSWER <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "app-env": "",
  "multiple-installations": "",
  "pkg-manager": ""
},
"user-defined-types": {
  "typedef": "typedef int customer_id;<br />customer_id cid = 3;",
  "enum": "enum day_of_week { mon, tue, wed, thu, fri, sat, sun };<br />day_of_week d = tue;",
  "struct-definition": "class MedalCount {<br />public:<br /><span style=\"white-space: pre-wrap;\">  </span>const char *country;<br /><span style=\"white-space: pre-wrap;\">  </span>int gold;<br /><span style=\"white-space: pre-wrap;\">  </span>int silver;<br /><span style=\"white-space: pre-wrap;\">  </span>int bronze;<br />};",
  "struct-declaration": "MedalCount spain;",
  "struct-initialization": "MedalCount spain = { \"Spain\", 3, 7, 4 };",
  "struct-member-assignment": "spain.country = \"Spain\";<br />spain.gold = 3;<br />spain.silver = 7;<br />spain.bronze = 4;",
  "struct-member-access": "int spain_total = spain.gold + spain.silver + spain.bronze;"
},
"generic-types": {
  "define-generic-type": "template &lt;class A&gt;<br />class Foo {<br />public:<br /><span style=\"white-space: pre-wrap;\">  </span>A a;<br /><span style=\"white-space: pre-wrap;\">  </span>Foo(A a);<br />};<br /><span style=\"white-space: pre-wrap;\"> </span><br />template &lt;class A&gt;<br />Foo&lt;A&gt;::Foo(A a) : a(a) {<br />}",
  "instantiate-generic-type": "Foo&lt;string&gt; f = Foo&lt;string&gt;(\"foo\");",
  "generic-function": "template &lt;class C&gt;<br />C add(C a, C b) {<br /><span style=\"white-space: pre-wrap;\">  </span>return a + b;<br />}",
  "generic-array": "template &lt;class C&gt;<br />class Foo {<br />public:<br /><span style=\"white-space: pre-wrap;\">  </span>C a[10];<br />};",
  "value-parameter": "template &lt;int N&gt;<br />int add(int i) {<br /><span style=\"white-space: pre-wrap;\">  </span>return N+i;<br />}<br /><span style=\"white-space: pre-wrap;\"> </span><br />cout <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> add&lt;7&gt;(3) <span style=\"white-space: pre-wrap;\">&lt;&lt;</span> endl;",
  "template-parameter": "",
  "template-specialization": "",
  "multiple-type-parameters": "template &lt;class A, class B&gt;<br />class Pair {<br />public:<br /><span style=\"white-space: pre-wrap;\">  </span>A a;<br /><span style=\"white-space: pre-wrap;\">  </span>B b;<br /><span style=\"white-space: pre-wrap;\">  </span>Pair(A a, B b);<br />};<br /><span style=\"white-space: pre-wrap;\"> </span><br />template &lt;class A, class B&gt;<br />Pair&lt;A, B&gt;::Pair(A a, B b) :<br /><span style=\"white-space: pre-wrap;\">  </span>a(a), b(b) { }<br /><span style=\"white-space: pre-wrap;\">  </span><br />Pair&lt;int, string&gt; p =<br /><span style=\"white-space: pre-wrap;\">  </span>Pair&lt;int, string&gt;(7, \"foo\");",
  "generic-type-parameters": "Pair&lt;int, Foo&lt;string&gt; &gt; p =<br /><span style=\"white-space: pre-wrap;\">  </span>Pair&lt;int, Foo&lt;string&gt; &gt;(<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>7, Foo&lt;string&gt;(\"foo\"));",
  "template-parameters": "",
  "variadic-template": ""
},
"objects": {
  "str-equal": "<span style=\"color: gray\"><em>value comparison</em></span>",
  "define-class": "<span style=\"color: gray\"><em>Rational.hpp:</em></span><br />class Rational {<br /><span style=\"white-space: pre-wrap;\"> </span>public:<br /><span style=\"white-space: pre-wrap;\">  </span>int num, denom;<br /><span style=\"white-space: pre-wrap;\">  </span>Rational(int num, int denom);<br /><span style=\"white-space: pre-wrap;\">  </span>virtual ~Rational();<br /><span style=\"white-space: pre-wrap;\">  </span>Rational operator+(Rational&amp; addend);<br /><span style=\"white-space: pre-wrap;\">  </span>static Rational max(Rational&amp; a, Rational&amp; b);<br />};",
  "class-definition-location": "<span style=\"color: gray\"><em>top level, class block, or function block</em></span>",
  "constructor": "Rational::Rational(int n, int d) : num(n), denom(d) {<br /><span style=\"white-space: pre-wrap;\">  </span>if (denom == 0) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>throw \"zero denominator\";<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>int div = gcd(n,d);<br /><span style=\"white-space: pre-wrap;\">  </span>num = num / div;<br /><span style=\"white-space: pre-wrap;\">  </span>denom = denom / div;<br />}",
  "create-object": "Rational r1(7, 3);<br />Rational* r2 = new Rational(8, 5);",
  "destructor": "Rational::~Rational() {};",
  "destroy-object<br-/>": "delete r2;",
  "define-method": "int Rational::height() {<br /><span style=\"white-space: pre-wrap;\">  </span>return (abs(num) &gt; abs(denom)) ? abs(num) : abs(denom);<br />}",
  "invoke-method": "r1.height();<br />r2-&gt;height();",
  "define-class-method": "<span style=\"color: gray\"><em>declare static in class definition</em></span>",
  "invoke-class-method": "",
  "name-of-receiver": "this",
  "access-control": "<span style=\"color: gray\"><em>access keywords define regions:</em></span><br />class Foo {<br /><span style=\"white-space: pre-wrap;\">  </span>int privateInt1;<br /><span style=\"white-space: pre-wrap;\">  </span>int privateInt2;<br />public:<br /><span style=\"white-space: pre-wrap;\">  </span>int publicInt1;<br /><span style=\"white-space: pre-wrap;\">  </span>int publicInt2;<br />protected:<br /><span style=\"white-space: pre-wrap;\">  </span>int protectedInt1;<br /><span style=\"white-space: pre-wrap;\">  </span>int protectedInt2;<br />private:<br /><span style=\"white-space: pre-wrap;\">  </span>int privateInt3;<br /><span style=\"white-space: pre-wrap;\">  </span>int privateInt4;<br />};",
  "anonymous-class": "<span style=\"color: gray\"><em>possible but not useful</em></span>"
},
"inheritance-polymorphism": {
  "dynamic-dispatch": "<span style=\"color: gray\"><em>declare as virtual in base class</em></span>",
  "static-dispatch": "<span style=\"color: gray\"><em>dispatch static by default</em></span>",
  "subclass": "class Integer : public Rational {<br /><span style=\"white-space: pre-wrap;\"> </span>public:<br /><span style=\"white-space: pre-wrap;\">  </span>Integer(int n);<br /><span style=\"white-space: pre-wrap;\">  </span>virtual ~Integer();<br />};",
  "invoking-superclass-constructor": "Integer::Integer(int n) : Rational(n, 1) {<br />}",
  "mark-class-underivable-or-method-unoverrideable": "<span style=\"color: gray\"><em>none</em></span>",
  "root-class<br-/>": "<span style=\"color: gray\"><em>none</em></span>",
  "root-class-methods": "<span style=\"color: gray\"><em>none</em></span>"
},
"reflection": {
  "get-type-class-of-object": "",
  "get-type-class-from-string": "",
  "get-type-class-from-type-identifier": "typeid(Foo)",
  "class-name<br-/>": "typeid(Foo).name()",
  "get-methods": "",
  "has-method": "",
  "invoke-method-object": ""
},
"net-web": {
  "get-local-hostname,-dns-lookup,-reverse-dns-lookup": "",
  "http-get": "",
  "http-post": "",
  "absolute-url": "",
  "parse-url": "",
  "url-encode": "",
  "base64-encode/decode": ""
},
"unit-tests": {
  "test-class": "$ cat &gt; test_foo.cpp<br />#include &lt;cppunit/TestCaller.h&gt;<br />#include &lt;cppunit/TestCase.h&gt;<br />#include &lt;cppunit/TestSuite.h&gt;<br />#include \"test_foo.h\"<br /><br />using namespace CppUnit;<br /><br />void TestFoo::test_01() {<br /><span style=\"white-space: pre-wrap;\">  </span>CPPUNIT_ASSERT_EQUAL(1, 1);<br />}<br /><br />Test* TestFoo::suite() {<br /><span style=\"white-space: pre-wrap;\">  </span>TestSuite* suiteOfTests = new TestSuite(\"Foo\");<br /><span style=\"white-space: pre-wrap;\">  </span>suiteOfTests-&gt;addTest(<br /><span style=\"white-space: pre-wrap;\">  </span>new TestCaller&lt;TestFoo&gt;(<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"test_01\",<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>&amp;TestFoo::test_01));<br /><br /><span style=\"white-space: pre-wrap;\">  </span>return suiteOfTests;<br />}<br /><br />$ cat &gt; test_foo.h<br />#include &lt;cppunit/TestCase.h&gt;<br /><br />class TestFoo: public CppUnit::TestCase {<br />public:<br /><span style=\"white-space: pre-wrap;\">  </span>void test_01();<br /><br /><span style=\"white-space: pre-wrap;\">  </span>static CppUnit::Test* suite();<br />};",
  "run-all-tests": "$ cat &gt; test_runner.cpp<br />#include &lt;cppunit/ui/text/TestRunner.h&gt;<br />#include \"test_foo.h\"<br /><br />int main( int argc, char** argv)<br />{<br /><span style=\"white-space: pre-wrap;\">  </span>CppUnit::TextUi::TestRunner runner;<br /><span style=\"white-space: pre-wrap;\">  </span>runner.addTest(TestFoo::suite());<br /><span style=\"white-space: pre-wrap;\">  </span>runner.run();<br /><span style=\"white-space: pre-wrap;\">  </span>return 0;<br />}<br /><br />$ sudo apt-get install libcppunit-dev<br /><br />$ cat &gt; Makefile<br />test_runner: test_runner.o test_foo.o<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>g++ -o $@ $^ -lcppunit<br /><br />check: test_runner<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>./test_runner<br /><br />$ make check",
  "assert-equal": "#include &lt;cppunit/TestCase.h&gt;<br /><br />CPPUNIT_ASSERT_EQUAL(1, 1);<br />CPPUNIT_ASSERT_EQUAL(\"foo\", \"bar\");<br />CPPUNIT_ASSERT_EQUAL_MESSAGE(\"1 != 1\",<br /><span style=\"white-space: pre-wrap;\">  </span>1, 1);",
  "assert-approx": "",
  "assert-exc": "",
  "setup": "",
  "teardown": ""
},
"debug-profile": {
  "flag-for-stronger-warnings": "$ g++ -Wall foo.cpp",
  "suppress-warnings": "$ g++ -w foo.cpp",
  "treat-warnings-as-errors": "$ g++ -Werror foo.cpp",
  "run-debugger": "$ g++ -g -o foo foo.cpp<br /><br />$ gdb foo<br />(gdb) b main<br />(gdb) run",
  "debugger-cmds": "<span style=\"white-space: pre-wrap;\">&gt;</span> h<br /><span style=\"white-space: pre-wrap;\">&gt;</span> l <span style=\"color: gray\">[FIRST_LINENO, LAST_LINENO]</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> file <span style=\"color: gray\">PATH</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> n<br /><span style=\"white-space: pre-wrap;\">&gt;</span> s<br /><span style=\"white-space: pre-wrap;\">&gt;</span> b <span style=\"color: gray\">[FILE:]LINENO</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> i<br /><span style=\"white-space: pre-wrap;\">&gt;</span> d <span style=\"color: gray\">NUM</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> c<br /><span style=\"white-space: pre-wrap;\">&gt;</span> bt<br /><span style=\"white-space: pre-wrap;\">&gt;</span> up<br /><span style=\"white-space: pre-wrap;\">&gt;</span> do<br /><span style=\"white-space: pre-wrap;\">&gt;</span> p <span style=\"color: gray\">EXPR</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> r <span style=\"color: gray\">[ARG1[, [ARG2 <span style=\"white-space: pre-wrap;\">...</span>]]</span><br /><span style=\"white-space: pre-wrap;\">&gt;</span> q",
  "benchmark-code": "",
  "profile-code": "<span style=\"color: gray\"><em>gprof does not work on Mac OS X:</em></span><br /><br />$ g++ -pg -o foo foo.cpp<br /><br />$ ./foo<br /><br />$ gprof foo",
  "memory-tool": "$ sudo apt-get install valgrind<br /><br />$ g++ -o foo foo.cpp<br /><br />$ valgrind ./foo"
}
}
