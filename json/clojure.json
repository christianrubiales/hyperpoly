{
"version": {
  "version-used": "<span style=\"color: gray\"><em>Clojure 1.6</em></span>",
  "show-version": "<span style=\"color: gray\"><em>displayed by repl on startup</em></span>"
},
"grammar-execution": {
  "compiler": "",
  "standalone-executable": "",
  "interpreter": "<span style=\"color: grey\"><em>specify full path to clojure jar:</em></span><br /><br />java -cp clojure.jar clojure.main foo.clj",
  "shebang": "<span style=\"color: gray\"><em>specify full path to clojure jar:</em></span><br /><br />#!/usr/bin/env java -jar clojure.jar",
  "repl": "$ java -jar /PATH/TO/clojure.jar",
  "cmd-line-program": "",
  "word-separator": "<span style=\"color: gray\"><em>whitespace and commas</em></span>",
  "eol-comment": "(+ 1 1) <span style=\"color: gray\">; adding</span>",
  "multiple-line-comment": ""
},
"var-expr": {
  "id": "<span style=\"color: gray\"><em>case sensitive, cannot start with digit</em></span><br /><br /><span style=\"color: gray\"><em>permitted characters:</em></span><br />A-Z a-z 0-9 * + ! - _ ?<br /><br /><span style=\"color: gray\"><em>these have special meaning or are reserved:</em></span><br />/ . :",
  "quoted-id": "<span style=\"color: gray\"><em>none</em></span><br /><br /><span style=\"color: gray\"><em>none</em></span>",
  "local-var": "(let [x 3 y 4]<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))<br /><br />(let [[x y] [3 4]]<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))<br /><br />(let [x 3 y (* x x)]<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))",
  "global-var": "(def x 3)",
  "rm-var": "(ns-unmap *ns* 'x)",
  "null": "<span style=\"color: gray\">; same value as null in Java:</span><br />nil",
  "null-test": "(nil? x)",
  "id-as-val": "'x<br />(quote x)",
  "id-test": "(symbol? 'x)",
  "identifier-equality-test": "(= 'x 'x)",
  "non-referential-id": ":foo",
  "id-attr": "<span style=\"color: gray\">; value must be instance of clojure.lang.IObj:</span><br /><br />(def x (with-meta [13] {:desc \"unlucky\"}))<br />(get (meta x) :desc)<br /><span style=\"color: gray\">; none</span>"
},
"arithmetic-logic": {
  "true-false": "true false",
  "falsehoods": "false nil",
  "logical-op": "(or (not true) (and true false))",
  "relational-op": "<span style=\"white-space: pre-wrap;\">=</span> not= &lt; &gt; &lt;= &gt;=",
  "min-max": "(min 1 2 3)<br />(max 1 2 3)",
  "num-predicates": "number? integer?<br />rational? float?<br /><span style=\"color: gray\"><em>none</em></span> <span style=\"color: gray\"><em>none</em></span>",
  "arith-op": "+ - * / mod",
  "int-div": "(quot 7 3)<br />(rem 7 3)",
  "int-div-zero": "",
  "float-div": "<span style=\"color: gray\"><em>rational:</em></span><br />(/ 7 3)<br /><br /><span style=\"color: gray\"><em>float:</em></span><br />(/ 7 (* 3 1.0))",
  "float-div-zero": "",
  "power": "<span style=\"color: gray\"><em>returns float:</em></span><br />(Math/pow 2 32)",
  "sqrt": "(Math/sqrt 2)",
  "sqrt-negative-one": "<span style=\"color: gray\"><em>(Math/sqrt -1):</em></span> NaN",
  "transcendental-func": "Math/exp Math/log Math/sin Math/cos Math/tan Math/asin Math/acos Math/atan Math/atan2",
  "float-truncation": "<span style=\"color: gray\"><em>return integers:</em></span><br />int Math/round<br /><span style=\"color: gray\"><em>return floats:</em></span><br />Math/ceil Math/floor",
  "abs-val": "Math/abs Math/signum",
  "int-overflow": "<span style=\"color: gray\">clojure.lang.Numbers.throwIntOverflow <em>exception</em></span>",
  "float-overflow": "<span style=\"color: gray\"><em>not literals:</em></span><br />-Infity NaN Infinity",
  "rational-construction": "(/ 3 7)<br /><br /><span style=\"color: gray\">; literal:</span><br />3/7",
  "rational-decomposition": "(numerator 3/7)<br />(denominator 3/7)",
  "complex-construction": "<span style=\"color: gray\"><em>none</em></span>",
  "complex-decomposition": "<span style=\"color: gray\"><em>none</em></span><br /><span style=\"color: gray\"><em>none</em></span>",
  "random-num": "(def rnd (java.util.Random.))<br />(.nextInt rnd 100)<br />(.nextFloat rnd)<br />(.nextGaussian rnd)",
  "random-seed": "",
  "bit-op": "bit-shift-left bit-shift-right bit-and bit-or bit-xor bit-not",
  "binary-octal-hex-literals": "",
  "radix": ""
},
"str": {
  "str-test": "(string? \"foo\")",
  "str-literal": "\"foo bar\"",
  "newline-in-str-literal": "<span style=\"color: gray\"><em>yes</em></span>",
  "str-literal-esc": "\\b \\t \\n \\f \\r \\\" \\\\ \\<span style=\"color: gray\"><em>ooo</em></span> \\u<span style=\"color: gray\"><em>hhhh</em></span>",
  "str-ctor": "",
  "fmt-str": "(String/format \"%s: %d %.2f\"<br /><span style=\"white-space: pre-wrap;\">  </span>(to-array [\"Foo\" 7 13.457]))",
  "fmt-specifiers": "",
  "compare-str": "(.equals \"foo\" \"bar\")<br />(.compareTo \"foo\" \"bar\")",
  "str-concat": "(str \"foo \" \"bar \" \"baz\")",
  "str-replicate": "(String. (into-array<br /><span style=\"white-space: pre-wrap;\">  </span>(. Character TYPE)<br /><span style=\"white-space: pre-wrap;\">  </span>(repeat 3 \\f)))",
  "translate-case": "(.toLowerCase \"FOO\")",
  "capitalize": "",
  "trim": "(.trim \" foo \")",
  "pad": "",
  "num-to-str": "(str \"Value: \" 8)",
  "str-to-num": "(+ 7 (Integer/parseInt \"12\"))<br /><span style=\"white-space: pre-wrap;\"> </span><br />(+ 73.9 (Float/parseFloat \".037\"))",
  "split": "(seq<br /><span style=\"white-space: pre-wrap;\">  </span>(.split \"foo bar baz\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"[ \\t\\n]+\"))",
  "str-join": "(reduce #(str %1 \" \" %2)<br /><span style=\"white-space: pre-wrap;\">  </span>'(\"foo\" \"bar\" \"baz\"))",
  "str-len": "(.length \"foo\")",
  "index-substr": "(.indexOf \"foo bar\" \"bar\")",
  "extract-substr": "(.substring \"foo bar\" 4 7)",
  "char-literal": "\\a \\newline \\space \\backspace \\tab <span style=\"color: gray\"><em>?</em></span> \\formfeed \\return <span style=\"color: gray\"><em>?</em></span>",
  "char-test": "(char? \\x)",
  "chr-ord": "(char 97)<br />(int \\a)",
  "str-to-char-array": "",
  "lookup-char": "(.charAt \"foo\" 0)"
},
"regex": {
  "regex-literal": "#\"\\b\\d{5}\\b\"",
  "char-class-abbrev": ". \\d \\D \\s \\S \\w \\W",
  "regex-anchors": "^ $ \\A \\b \\B \\G \\z \\Z",
  "regex-test": "(re-find #\"bar\" \"foo bar\")",
  "case-insensitive-regex": "(re-find #\"(?i:lorem)\" \"Lorem\")",
  "subst": "(.replaceFirst \"hello\" \"[^l]l\" \"XX\")<br /><span style=\"white-space: pre-wrap;\"> </span><br />(.replaceAll \"hello hello\"<br /><span style=\"white-space: pre-wrap;\">  </span>\"[^l]l\" \"XX\")",
  "group-capture": "(let [[_ yr mn dy]<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(re-find #\"(\\d{4})-(\\d{2})-(\\d{2})\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>\"2010-06-03\")]<br /><span style=\"white-space: pre-wrap;\">  </span>yr)",
  "scan": "(re-seq #\"\\w+\" \"dolor sit amet\")",
  "backreference": ""
},
"dates-time": {
  "broken-down-datetime-type": "",
  "current-datetime": "(def dt (new java.util.Date))",
  "current-unix-epoch": "(/ (System/currentTimeMillis) 1000.0)",
  "unix-epoch-to-broken-down-datetime": "(def dt (new java.util.Date<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(System/currentTimeMillis)))",
  "broken-down-datetime-to-unix-epoch": "(/ (.getTime (new java.util.Date)) 1000.0)",
  "fmt-datetime": "(def s \"yyyy-MM-dd HH:mm:ss\")<br />(def fmt (new java.text.SimpleDateFormat s))<br /><br />(.format fmt (new java.util.Date))",
  "parse-datetime": "(def s \"yyyy-MM-dd HH:mm:ss\")<br />(def fmt (new java.text.SimpleDateFormat s))<br /><br />(.parse fmt \"2015-05-30 09:14:14\")",
  "datet-parts": "(def cal (new java.util.GregorianCalendar))<br />(.setTime cal dt)<br /><br />(.get cal java.util.Calendar/DAY_OF_MONTH)<br />(+ (.get cal java.util.Calendar/MONTH) 1)<br />(.get cal java.util.Calendar/YEAR)",
  "time-parts": "(def cal (new java.util.GregorianCalendar))<br />(.setTime cal dt)<br /><br />(.get cal java.util.Calendar/HOUR_OF_DAY)<br />(.get cal java.util.Calendar/MINUTE)<br />(.get cal java.util.Calendar/SECOND)",
  "build-datetime": "(let<br /><span style=\"white-space: pre-wrap;\">  </span>[yr 2015 mo 5 dy 31 hr 10 mi 22 ss 0]<br /><span style=\"white-space: pre-wrap;\">  </span>(def cal<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(new java.util.GregorianCalendar<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>yr (- mo 1) dy hr mi ss)))"
},
"lists": {
  "literal<br-/>": "'(1 2 3)<br />(quote (1 2 3))",
  "constructor<br-/>": "(list 1 2 3)",
  "predicate<br-/>": "(list? '(1 2 3))",
  "empty-test": "(empty? ())",
  "evaluating-the-empty-list": "()",
  "cons<br-/>": "(cons 1 '(2 3))",
  "head<br-/>": "first",
  "tail<br-/>": "(rest '(1 2 3))<br />(next '(1 2 3))",
  "head-and-tail-of-empty-list": "()",
  "length<br-/>": "(count '(1 2 3))",
  "equality-test<br-/>": "(= '(1 2 3) '(1 2 3))",
  "nth-element": "(nth '(1 2 3 4) 2)",
  "out-of-bounds-behavior": "<span style=\"color: gray\"><em>raises</em> IndexOutOfBoundsException</span>",
  "element-index": "<span style=\"color: gray\"><em>none</em></span>",
  "concatenate<br-/>": "(concat '(1 2 3) '(4 5 6))",
  "take<br-/>": "(take 2 '(1 2 3 4))",
  "drop<br-/>": "(drop 2 '(1 2 3 4))",
  "last-element<br-/>": "(last '(1 2 3))",
  "all-but-last-element": "(butlast '(1 2 3))",
  "reverse<br-/>": "(reverse '(1 2 3))",
  "sort<br-/>": "(sort &lt; '(3 2 4 1))",
  "dedupe<br-/>": "",
  "membership<br-/>": "",
  "map": "(map #(* % %) '(1 2 3))",
  "filter": "(filter #(&gt; % 2) '(1 2 3))<br /><br /><span style=\"color: gray\">; remove returns complement</span>",
  "reduce": "(reduce - 0 '(1 2 3 4))",
  "right-fold": "<span style=\"color: gray\"><em>none</em></span>",
  "iterate": "(doseq [x '(1 2 3)]<br /><span style=\"white-space: pre-wrap;\">  </span>(println x)<br /><span style=\"white-space: pre-wrap;\">  </span>(println (- x)))",
  "universal-predicate": "(every? #(= 0 (rem % 2)) '(1 2 3 4))",
  "existential-predicate": "(some #(= 0 (rem % 2)) '(1 2 3 4))",
  "list-comprehension": "(for<br /><span style=\"white-space: pre-wrap;\">  </span>[file \"ABCDEFGH\" rank (range 1 9)]<br /><span style=\"white-space: pre-wrap;\">  </span>(format \"%c%d\" file rank))",
  "shuffle<br-/>": "(shuffle '(1 2 3 4))",
  "set-head": "<span style=\"color: gray\"><em>none</em></span>",
  "set-tail": "<span style=\"color: gray\"><em>none</em></span>",
  "manipulate-back": "",
  "flatten": "(flatten '(1 2 (3 (4))))",
  "associative-array-lookup<br-/>": "<span style=\"color: gray\"><em>none, see note</em></span>",
  "flat-associative-array-lookup<br-/>": "<span style=\"color: gray\"><em>none</em></span>",
  "pair-literal<br-/>": "<span style=\"color: gray\"><em>none</em></span>",
  "cons-cell-test": "<span style=\"color: gray\"><em>none</em></span>",
  "translate-elements-recursively": ""
},
"fixed-length-arrays": {
  "fixed-len-array-literal": "[1 2 3]",
  "constructor<br-/>": "(vector 1 2 3)",
  "size<br-/>": "(count [1 2 3])",
  "lookup": "(nth [1 2 3] 0)",
  "update": "(replace {2 4} [1 2 3])",
  "out-of-bounds-behavior": "",
  "array-to-list<br-/>": "(seq [1 2 3])",
  "list-to-array<br-/>": "(vec '(1 2 3))",
  "reverse": "",
  "sort": "",
  "map": "",
  "filter": "",
  "reduce": ""
},
"dictionaries": {
  "dict-literal": "<span style=\"color: gray\">; clojure.lang.PersistentArrayMap:</span><br />{\"t\" 1 \"f\" 0}",
  "dict-ctor": "<span style=\"color: gray\">; immutable:</span><br />(def ih (hash-map \"t\" 1 \"f\" 0))",
  "dict-pred": "(map? ih)",
  "dict-size": "(count ih)",
  "dict-lookup": "(get ih \"t\")<br />(find ih \"t\")<br /><br /><span style=\"color: gray\">; return -1 if not found:</span><br />(get ih \"m\" -1)",
  "dict-update": "(def ih2 (assoc ih \"t\" 2))",
  "dict-missing-key": "<span style=\"color: gray\"><em>returns</em> nil</span>",
  "dict-is-key-present": "(contains? ih \"t\")",
  "dict-dele": "(def ih2 (dissoc ih \"t\"))",
  "dict-merge": "<span style=\"color: gray\">; values in ih2 take precedence:</span><br />(define ih3 (merge ih ih2))",
  "dict-invert": "(require 'clojure.set)<br /><br />(define ih4 (clojure.set/map-invert ih))",
  "dict-iter": "(doseq [p ih]<br /><span style=\"white-space: pre-wrap;\">  </span>(println (first p))<br /><span style=\"white-space: pre-wrap;\">  </span>(println (second p)))",
  "dict-key-val-lists": "(def hkeys (map (fn [p] (first p)) ih))<br />(def hvals (map (fn [p] (second p)) ih))"
},
"user-defined-types": {
  "defstruct": "(defstruct account :id :balance)",
  "struct": "(def a (struct account 3 17.12))",
  "struct-getter<br-/>": "(:id a)",
  "struct-setter<br-/>": "<span style=\"color: gray\"><em>none</em></span>",
  "struct-predicate<br-/>": "<span style=\"color: gray\"><em>none</em></span>"
},
"functions": {
  "define-function<br-/>": "(defn add [x y] (+ x y))",
  "can-function-and-variable-share-name": "<span style=\"color: gray\"><em>no</em></span>",
  "optional-argument": "(defn add ([a] a) ([a b] (+ a b)))<br /><span style=\"color: gray\"><em>no syntax error if called with more than 2 args:</em></span><br />(defn add [a &amp; [b]]<br /><span style=\"white-space: pre-wrap;\">  </span>(if (nil? b) a (+ a b)))",
  "variable-number-of-arguments": "(defn add [a &amp; b]<br /><span style=\"white-space: pre-wrap;\">  </span>(if (nil? b) a (+ a (apply + b))))",
  "default-value": "(defn add<br /><span style=\"white-space: pre-wrap;\">  </span>([a] (add a 0))<br /><span style=\"white-space: pre-wrap;\">  </span>([a b] (+ a b)))",
  "named-parameter": "(defn logarithm [{x :number b :base}] (/ (Math/log x) (Math/log b)))<br />(logarithm {:base 2 :number 8})",
  "return-multiple-values": "(defn sqrts [x] (list (Math/sqrt x) (- (Math/sqrt x))))",
  "assign-multiple-values-to-local-variables": "(let [[r1 r2] (sqrts 3)] r2)",
  "assign-multiple-values-to-global-variables": "<span style=\"color: gray\"><em>none</em></span>",
  "convert-list-to-multiple-values": "<span style=\"color: gray\"><em>multiple values are lists</em></span>",
  "assign-multiple-values-to-list": "<span style=\"color: gray\"><em>multiple values are lists</em></span>",
  "tail-call-optimization": "<span style=\"color: gray\"><em>yes with</em></span> recur",
  "lambda": "#(* % %)<br />(fn [x] (* x x))<br /><br /><span style=\"color: gray\">; shortcut notation with two args:</span><br />#(* %1 %2)",
  "apply": "(#(* % %) 2)<br /><span style=\"white-space: pre-wrap;\"> </span><br />((fn [x] (* x x)) 2)<br /><span style=\"white-space: pre-wrap;\"> </span><br />(apply #(* % %) '(2))"
},
"execution-control": {
  "progn<br-/>": "do <span style=\"color: gray\"><em>none</em></span> <span style=\"color: gray\"><em>none</em></span>",
  "loop": "(loop [i 1]<br /><span style=\"white-space: pre-wrap;\">  </span>(if (&lt;= i 10)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(do (println \"hello\")<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(recur (+ i 1)))))",
  "do": "<span style=\"color: gray\"><em>none</em></span>",
  "dotimes": "(dotimes [_ 10]<br /><span style=\"white-space: pre-wrap;\">  </span>(println \"hello\"))",
  "if<br-/>": "(if (&lt; x 0) (- x) x)",
  "when": "(when (&lt; x y)<br /><span style=\"white-space: pre-wrap;\">  </span>(println \"x is less \")<br /><span style=\"white-space: pre-wrap;\">  </span>(println \"than y\"))",
  "cond": "(cond (&gt; x 0) 1<br /><span style=\"white-space: pre-wrap;\">  </span>(= x 0) 0<br /><span style=\"white-space: pre-wrap;\">  </span>true -1)",
  "lazy-evaluation": "",
  "continuations": ""
},
"exceptions": {
  "error<br-/>": "(throw (Exception. \"failed\"))",
  "handle-error": "(try (throw (Exception. \"failure\"))<br /><span style=\"white-space: pre-wrap;\">  </span>(catch Exception e<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(printf \"error: %s\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(.getMessage e))))",
  "define-exception": "",
  "throw-exception": "(throw (Exception. \"failed\"))",
  "catch-exception": "(try (/ 1 0) (catch ArithmeticException _ (do (println \"division by zero\") nil)))",
  "restart-case": "<span style=\"color: gray\"><em>none</em></span>",
  "invoke-restart": "<span style=\"color: gray\"><em>none</em></span>",
  "finally-clause": "(try (throw (Exception. \"failure\"))<br /><span style=\"white-space: pre-wrap;\">     </span>(finally (println \"clean up\")))"
},
"streams": {
  "std-file-handles": "*in*<br />*out*<br />*err*",
  "eof": "<span style=\"color: gray\">.readLine <em>on a</em> java.io.Reader <em>object returns</em> nil.</span>",
  "read-stdin": "(let [s (read-line)]<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">(comment use s)</span>)",
  "chomp": "<span style=\"color: gray\">read-line <em>discards newline</em></span>",
  "println": "(println \"hello\")",
  "format-stdout": "(printf \"%s %d %.2f\\n\" \"foo\" 7 13.7)",
  "open-file": "<span style=\"color: gray\">; f is java.io.Reader object:</span><br />(let [f (clojure.java.io/reader \"/etc/hosts\")]<br /><span style=\"white-space: pre-wrap;\">  </span>(.readLine f))",
  "open-file-write": "<span style=\"color: gray\">; f is java.io.Writer object:</span><br />(let [f (clojure.java.io/writer \"/tmp/foo\")]<br /><span style=\"white-space: pre-wrap;\">  </span>(.write f \"lorem ipsum\\n\")<br /><span style=\"white-space: pre-wrap;\">  </span>(.close f))",
  "open-file-append": "(let [f (clojure.java.io/writer \"/tmp/foo\"<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>:append true)]<br /><span style=\"white-space: pre-wrap;\">  </span>(.write f \"lorem ipsum\\n\")<br /><span style=\"white-space: pre-wrap;\">  </span>(.close f))",
  "close-file": "(.close f)",
  "close-file-implicitly": "(with-open [f<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(clojure.java.io/reader \"/etc/hosts\")]<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"color: gray\">(comment use f)</span>)",
  "read-line": "(.readLine f)",
  "iterate-file": "(loop [line (.readLine f)]<br /><span style=\"white-space: pre-wrap;\">  </span>(if (not= line nil)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(do (println line)<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>(recur (.readLine f)))))",
  "read-file-array": "(vec (line-seq f))",
  "read-file-str": "(let [s (slurp \"/etc/hosts\")]<br /><span style=\"white-space: pre-wrap;\">  </span>(print s))",
  "write-str": "(.write f s)",
  "write-line": "(.write f (println-str s))",
  "flush-file": "(f .flush)",
  "seek": "<span style=\"color: gray\">; arg is characters from current position;<br />; moving backward not possible:</span><br />(.skip f 1000)<br /><br /><span style=\"color: gray\">; arg is max characters to buffer:</span><br />(.mark f 1000000)<br /><span style=\"color: gray\">; move to position saved when .mark was called:</span><br />(.rest f)",
  "in-memory-stream": "<span style=\"color: gray\">; use *in* to read from string:</span><br />(with-in-str \"lorem ispum\"<br /><span style=\"white-space: pre-wrap;\">  </span>(read-line))<br /><br /><span style=\"color: gray\">; use *out* to write to string:</span><br />(with-out-str<br /><span style=\"white-space: pre-wrap;\">  </span>(println \"lorem ipsum\"))"
},
"emacs-buffers": {
  "list-buffers": "",
  "current-buffer": "",
  "clear-buffer": "",
  "point": "",
  "search-and-set-point": "",
  "insert-at-string-point": "",
  "current-buffer-as-string": "",
  "insert-file-contents-at-point": "",
  "mark": ""
},
"files": {
  "file-test": "(.exists (io/file \"/etc/hosts\"))",
  "file-size": "(.length (io/file \"/etc/hosts\"))",
  "file-readable-writable-executable": "(.canRead (io/file \"/etc/hosts\"))<br />(.canWrite (io/file \"/etc/hosts\"))<br />(.canExecute (io/file \"/etc/hosts\"))",
  "chmod": "",
  "last-modification-time": "<span style=\"color: gray\">; Unix epoch in milliseconds:</span><br />(.lastModified (java.io.File. \"/tmp/foo\"))",
  "cp-rm-mv": "(clojure.java.io/copy<br /><span style=\"white-space: pre-wrap;\">  </span>(java.io.File. \"/tmp/foo\")<br /><span style=\"white-space: pre-wrap;\">  </span>(java.io.File. \"/tmp/bar\"))<br />(clojure.java.io/delete-file \"/tmp/foo\")<br />(.renameTo (java.io.File. \"/tmp/bar\")<br /><span style=\"white-space: pre-wrap;\">  </span>(java.io.File. \"/tmp/foo\"))",
  "symlink": "",
  "tmp-file": "<span style=\"color: gray\">; java.io.File:</span><br />(java.io.File/createTempFile \"foo\" \".txt\")"
},
"directories": {
  "build-pathname": "(require '[clojure.java.io :as io])<br /><br /><span style=\"color: gray\">; returns java.io.File;<br />; convert to string with .getPath:</span><br />(io/file \"/etc\" \"hosts\")",
  "dirname-basename": "(require '[clojure.java.io :as io])<br /><br />(.getParent (io/file \"/etc/hosts\"))<br />(.getName (io/file \"/etc/hosts\"))",
  "abs-pathname": "(.getCanonicalPath (java.io.File. \"..\"))",
  "iterate-dir": "<span style=\"color: gray\">; file-seq returns java.io.File objects for files<br />; in arg directory and any subdirs recursively.</span><br />(filter #(= (.getParent %) \"/etc\")<br /><span style=\"white-space: pre-wrap;\">  </span>(file-seq (clojure.java.io/file \"/etc\")))",
  "mkdir": "(require '[clojure.java.io :as io])<br /><br />(.mkdir (io/file \"/tmp/foo\"))",
  "recursive-cp": "",
  "rmdir": "(clojure.java.io/delete-file \"/tmp/foo.d\")",
  "rm-rf": "",
  "dir-test": "(.isDirectory (io/file \"/etc\"))"
},
"processes-environment": {
  "cmd-line-arg": "*command-line-args*",
  "program-name": "",
  "env-var": "(System/getenv \"HOME\")",
  "user-id-name": "",
  "exit": "",
  "external-cmd": "(.exec (Runtime/getRuntime) \"ls\")",
  "cmd-subst": ""
},
"libraries-namespaces": {
  "complete-example": "$ cat b/a.clj<br />(ns b.a)<br />(def x 3)<br /><br />$ java -cp clojure.jar:. clojure.main<br />=&gt; (require 'b.a)<br />=&gt; b.a/x<br />3",
  "compile-library": "(compile 'a)",
  "load-library<br-/>": "(require 'a)",
  "load-library-in-subdirectory": "(require 'b.a)",
  "hot-patch": "(require 'b.a :reload)",
  "load-error": "<span style=\"color: grya\"><em>raises</em> FileNotFoundException</span>",
  "library-path": "<span style=\"color: gray\"><em>same as path used by java VM</em></span>",
  "library-path-environment-variable": "<span style=\"color: gray\">CLASSPATH</span>",
  "library-path-command-line-option": "$ java -cp /foo/bar:/baz/quux",
  "namespace-declaration": "(ns mconst)",
  "subnamespace-declaration": "<span style=\"color: gray\">; must be in b/a.clj:</span><br />(ns b.a)",
  "namespace-separator": ". <span style=\"color: gray\"><em>and</em></span> /",
  "import-definitions": "",
  "import-all-definitions-in-namespace": "",
  "namespace-shadow-avoidance": "",
  "identifier-shadow-avoidance": "",
  "package-manager-help": "",
  "list-installed-packages": "",
  "search-packages": "",
  "install-package": "",
  "remove-package": ""
},
"objects": {
  "define-class": "<span style=\"color: gray\"><em>use java:</em></span><br />public class Rectangle {<br /><span style=\"white-space: pre-wrap;\">  </span>public float height;<br /><span style=\"white-space: pre-wrap;\">  </span>public float width;<br /><span style=\"white-space: pre-wrap;\">  </span>public Rectangle(float h, float w) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>this.height = h;<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>this.width = w;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>public void setHeight(float h) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>this.height = h;<br /><span style=\"white-space: pre-wrap;\">  </span>}<br /><span style=\"white-space: pre-wrap;\">  </span>public void setWidth(float w) {<br /><span style=\"white-space: pre-wrap;\">  </span><span style=\"white-space: pre-wrap;\">  </span>this.width = w;<br />}",
  "make-instance": "(import 'Rectangle)<br />(def r (Rectangle. 7 3))",
  "read-attribute<br-/>": "(.height r)",
  "write-attribute<br-/>": "(.setHeight r 8)",
  "define-method": "(defmulti area class)<br />(defmethod area Rectangle [r] (* (.height r) (.width r)))",
  "invoke-method<br-/>": "(area r)",
  "universal-superclass": "Object",
  "multiple-inheritance": "<span style=\"color: gray\"><em>only one direct superclass; can implement multiple interfaces</em></span>"
},
"lisp-macros": {
  "backquote-and-comma": "(def op +)<br />(eval <span style=\"white-space: pre-wrap;\">`</span>(,op 1 1))",
  "defmacro": "(defmacro rpn [arg1 arg2 op]<br /><span style=\"white-space: pre-wrap;\">  </span>(list op arg1 arg2))",
  "defmacro-w/-backquote": "(defmacro rpn [arg1 arg2 op] <span style=\"white-space: pre-wrap;\">`</span>(~op ~arg1 ~arg2))",
  "macro-predicate": "<span style=\"color: gray\"><em>none</em></span>",
  "macroexpand": "(macroexpand '(rpn 1 2 +))",
  "splice-quote": "(defmacro add [ &amp; args ] <span style=\"white-space: pre-wrap;\">`</span>(+ ~@args))",
  "recursive-macro": "(defmacro add ([a] <span style=\"white-space: pre-wrap;\">`</span>(+ ~a)) ([a &amp; b] <span style=\"white-space: pre-wrap;\">`</span>(+ ~a (add ~@b))))",
  "hygienic<br-/>": "<span style=\"color: gray\"><em>with</em> # <em>suffix</em></span>",
  "local-values": "(defmacro two-list [x] <span style=\"white-space: pre-wrap;\">`</span>(let [arg# ~x] (list arg# arg#)))"
},
"reflection": {
  "inspect-type<br-/>": "(= (type 1) java.lang.Long)<br />(= (class 1) java.lang.Long)<br />(integer? 1)",
  "instance-of": "instance?",
  "basic-types": "",
  "sequence-data-types": "all collections and strings",
  "docstring": "(doc map)",
  "define-docstring": "(defn add \"add x and y\" [x y]<br /><span style=\"white-space: pre-wrap;\">  </span>(+ x y))",
  "search-doc": "(apropos #\"^add$\")<br />(find-doc #\"add \\S+ and \\S+\")"
},
"java-interop": {
  "new": "(def rnd (new java.util.Random))<br />(def rnd (java.util.Random.))",
  "method": "(. rnd nextFloat)<br />(.nextFloat rnd)<br />(. rnd nextInt 10)<br />(.nextInt rnd 10)",
  "class-method<br-/>": "(Math/sqrt 2)",
  "chain<br-/>": "",
  "import": "(import '(java.util Random))<br />(def rnd (Random.))",
  "to-java-array": "(to-array '(1 2 3))<br />(into-array Integer '(1 2 3))"
}
}
