<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<link rel="icon" type="image/gif" href="/favicon.gif"/>
<link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png" />
<link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png" />
<title>Rust, Swift, Scala - Hyperpolyglot</title>
<style type="text/css" id="internal-style">
@import url(hyperpolyglot.css);
</style>
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<meta http-equiv="content-language" content="en"/>
</head>
<body>
<div id="container-wrap-wrap">
  <div id="container-wrap">
    <div id="container">
      <div id="header">
        <h1><a href="/"><span>Hyperpolyglot</span></a></h1>
      </div>
      <div id="content-wrap">
        <div id="main-content">
<div id="page-title">
                            Rust, Swift, Scala
                        </div>
<div id="page-content">
                        

<p><a href="#grammar-invocation">grammar and invocation</a> | <a href="#var-expr">variables and expressions</a> | <a href="#arithmetic-logic">arithmetic and logic</a> | <a href="#strings">strings</a> | <a href="#dates-time">dates and time</a> | <a href="#fixed-length-arrays">fixed-length arrays</a> | <a href="#resizable-arrays">resizable arrays</a> | <a href="#lists">lists</a> | <a href="#tuples">tuples</a> | <a href="#dictionaries">dictionaries</a> | <a href="#functions">functions</a> | <a href="#execution-control">execution control</a> | <a href="#exceptions">exceptions</a> | <a href="#concurrency">concurrency</a> | <a href="#file-handles">file handles</a> | <a href="#files">files</a> | <a href="#directories">directories</a> | <a href="#processes-environment">processes and environment</a> | <a href="#libraries-namespaces">libraries and namespaces</a> | <a href="#user-defined-types">user-defined types</a> | <a href="#objects">objects</a> | <a href="#inheritance-polymorphism">inheritance and polymorphism</a> | <a href="#unit-tests">unit tests</a> | <a href="#debugging-profiling">debugging and profiling</a> | <a href="#repl">repl</a></p>
<table class="wiki-content-table">
<tr>
<th></th>
<th><a href="#rust">rust</a></th>
<th><a href="#swift">swift</a></th>
<th><a href="#scala">scala</a></th>
</tr>
<tr>
<td><a name="version-used" id="version-used"></a><a href="#version-used-note">version used</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>1.13</em></span></td>
<td><span style="color: gray"><em>2.1</em></span></td>
<td><span style="color: gray"><em>2.11</em></span></td>
</tr>
<tr>
<td><a name="version" id="version"></a><a href="#version-note">show version</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>$ rustc <span style="white-space: pre-wrap;">--</span>version</td>
<td>$ swift <span style="white-space: pre-wrap;">--</span>version</td>
<td>$ scala -version</td>
</tr>
<tr>
<td><a name="implicit-prologue" id="implicit-prologue"></a><a href="#implicit-prologue-note">implicit prologue</a></td>
<td><span style="color: gray"><em>none</em></span></td>
<td>import Foundation</td>
<td><span style="color: gray"><em>none; but these libraries always available:</em><br />
<br />
<span style="white-space: pre-wrap;">  </span>java.lang<br />
<span style="white-space: pre-wrap;">  </span>scala<br />
<br />
<em>as are methods in</em> Predef</span></td>
</tr>
<tr>
<th colspan="4"><a name="grammar-invocation" id="grammar-invocation"></a><a href="#grammar-invocation-note">grammar and invocation</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="interpreter" id="interpreter"></a><a href="#interpreter-note">interpreter</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td>$ echo 'println("hello")' &gt; Hello.scala<br />
<br />
$ scala hello.scala</td>
</tr>
<tr>
<td><a name="compiler" id="compiler"></a><a href="#compiler-note">compiler</a></td>
<td>$ cat hello.rs<br />
fn main() {<br />
<span style="white-space: pre-wrap;">  </span>println!("Hello, world!");<br />
}<br />
<br />
$ rustc hello.rs<br />
<br />
$ ./hello<br />
Hello, world!</td>
<td>$ cat hello.swift<br />
print("Hello, World!")<br />
<br />
$ swift hello.swift<br />
<br />
$ ./hello<br />
Hello, World!</td>
<td>$ cat hello.scala<br />
object Hello {<br />
<span style="white-space: pre-wrap;">  </span>def main(args: Array[String]) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>println("Hello, World!")<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}<br />
<br />
$ scalac Hello.scala<br />
$ scala Hello</td>
</tr>
<tr>
<td><a name="statement-terminator" id="statement-terminator"></a><a href="#statement-terminator-note">statement terminator</a></td>
<td>;<br />
<br />
<span style="color: gray"><em>Newlines are not statement terminators; they are permitted wherever spaces or tabs are permitted to separate tokens.</em></span></td>
<td>; <span style="color: gray"><em>or sometimes newline<br />
<br />
A newline does not terminate a statement when:<br />
<span style="white-space: pre-wrap;">  </span>(1) inside [ ] of an array literal,<br />
<span style="white-space: pre-wrap;">  </span>(2) inside of ( ) parens,<br />
<span style="white-space: pre-wrap;">  </span>(3) after a binary operator,<br />
<span style="white-space: pre-wrap;">  </span>(4) other situations?</em></span></td>
<td>; <span style="color: gray"><em>or sometimes newline</em></span><br />
<br />
<span style="color: gray"><em>A newline does not terminate a statement:<br />
<span style="white-space: pre-wrap;">  </span>(1) inside ( ) or [ ],<br />
<span style="white-space: pre-wrap;">  </span>(2) if the preceding line is not a complete statement,<br />
<span style="white-space: pre-wrap;">  </span>(3) if following token not legal at start of a statement.</em></span></td>
</tr>
<tr>
<td><a name="blocks" id="blocks"></a><a href="#blocks-note">block delimiters</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>{ }</td>
<td>{ }</td>
<td>{ }</td>
</tr>
<tr>
<td><a name="end-of-line-comment" id="end-of-line-comment"></a><a href="#end-of-line-comment-note">end-of-line comment</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="white-space: pre-wrap;">//</span> <span style="color: gray"><em>comment</em></span></td>
<td><span style="white-space: pre-wrap;">//</span> <span style="color: gray"><em>comment</em></span></td>
<td><span style="white-space: pre-wrap;">//</span> <span style="color: gray"><em>comment</em></span></td>
</tr>
<tr>
<td><a name="multiple-line-comment" id="multiple-line-comment"></a><a href="#multiple-line-comment-note">multiple line comment</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>/* <span style="color: gray"><em>comment line</em></span><br />
/* <span style="color: gray"><em>nested comment</em></span> */<br />
*/</td>
<td>/* <span style="color: gray"><em>comment line</em></span><br />
/* <span style="color: gray"><em>nested comment</em></span> */<br />
*/</td>
<td>/* <span style="color: gray"><em>comment line</em></span><br />
/* <span style="color: gray"><em>nested comment</em></span> */<br />
*/</td>
</tr>
<tr>
<th colspan="4"><a name="var-expr" id="var-expr"></a><a href="#var-expr-note">variables and expressions</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="value" id="value"></a><a href="#value-note">write-once variable</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>let pi: f64 = 3.14;</td>
<td>let Pi = 3.14</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> evaluates 1 + p immediately:</span><br />
val n = 1 + p<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> evaluated first time n is accessed:</span><br />
lazy val n = 1 + p</td>
</tr>
<tr>
<td><a name="variable" id="variable"></a><a href="#variable-note">modifiable variable</a></td>
<td>let mut n: i32 = 3;<br />
n += 1;</td>
<td>var n = 3<br />
n += 1</td>
<td>var n = 3<br />
n += 1<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> evaluates 1 + 2 each time n is used:</span><br />
def n = 1 + 2</td>
</tr>
<tr>
<td><a name="assignment" id="assignment"></a><a href="#assignment-note">assignment</a></td>
<td>let mut i: i32 = 0;<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> compiler warns if assignment value not used</span><br />
i = 3;</td>
<td>var i = 0<br />
<br />
i = 3</td>
<td></td>
</tr>
<tr>
<td><a name="parallel-assignment" id="parallel-assignment"></a><a href="#parallel-assignment-note">parallel assignment</a></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> only in variable definition:</span><br />
let (m, n) = (3, 7);</td>
<td>var (m, n) = (3, 7)</td>
<td>val (m, n) = (3, 7)</td>
</tr>
<tr>
<td><a name="swap" id="swap"></a><a href="#swap-note">swap</a></td>
<td>let tmp;<br />
tmp = x;<br />
x = y;<br />
y = tmp;</td>
<td>(x, y) = (y, x)</td>
<td></td>
</tr>
<tr>
<td><a name="compound-assignment" id="compound-assignment"></a><a href="#compound-assignment-note">compound assignment</a></td>
<td><span style="color: gray"><em>arithmetic:</em></span><br />
+= -= *= /= %=<br />
<br />
<span style="color: gray"><em>string</em>:</span><br />
+=</td>
<td><span style="color: gray"><em>arithmetic:</em></span><br />
+= -= *= /= %=<br />
<br />
<span style="color: gray"><em>string:</em></span><br />
+=<br />
<br />
<span style="color: gray"><em>bit:</em></span><br />
<span style="white-space: pre-wrap;">&lt;&lt;= &gt;&gt;= &amp;= |= ^=</span></td>
<td><span style="color: gray"><em>arithmetic:</em></span><br />
+= -= *= /= %=<br />
<br />
<span style="color: gray"><em>string:</em></span><br />
<span style="color: gray"><em>none</em></span><br />
<br />
<span style="color: gray"><em>bit:</em></span><br />
<span style="white-space: pre-wrap;">&lt;&lt;= &gt;&gt;= &amp;= |= ^=</span></td>
</tr>
<tr>
<td><a name="unit" id="unit"></a><a href="#unit-note">unit type and value</a></td>
<td>()<br />
()</td>
<td>Void<br />
()</td>
<td>Unit<br />
()</td>
</tr>
<tr>
<td><a name="conditional-expression" id="conditional-expression"></a><a href="#conditional-expression-note">conditional expression</a></td>
<td>if x &gt; 0 { x } else { -x }</td>
<td>x &gt; 0 ? x : -x</td>
<td>val n = -3<br />
if (n &lt; 0) -n else n</td>
</tr>
<tr>
<td><a name="branch-type-mismatch" id="branch-type-mismatch"></a><a href="#branch-type-mismatch-note">branch type mismatch</a></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> does not compile:</span><br />
if true { "hello" } else { 3 }</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> syntax error:</span><br />
true ? "hello" : 3</td>
<td><span style="color: gray">// expression has type Any:</span><br />
if (true) { "hello" } else { 3 }</td>
</tr>
<tr>
<td><a name="null" id="null"></a><a href="#null-note">null</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Option types only:</span><br />
None</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> option types only:</span><br />
nil</td>
<td>null</td>
</tr>
<tr>
<td><a name="nullable-type" id="nullable-type"></a><a href="#nullable-type-note">nullable type</a></td>
<td>let a: Vec&lt;Option&lt;i32<span style="white-space: pre-wrap;">&gt;&gt;</span> =<br />
<span style="white-space: pre-wrap;">  </span>vec![Some(3_i32), None, Some(-4_i32)];</td>
<td></td>
<td>val a = List(Some(3), null, Some(-4))</td>
</tr>
<tr>
<td><a name="null-test" id="null-test"></a><a href="#null-test-note">null test</a></td>
<td>let a = vec![Some(1_i32), None];<br />
<br />
match a[0] {<br />
<span style="white-space: pre-wrap;">  </span>None =&gt; println!("a[0] is none"),<br />
<span style="white-space: pre-wrap;">  </span>Some(i) =&gt; println!("a[0]: {}", i),<br />
}<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> simple comparison also works:</span><br />
if a[1] == None {<br />
<span style="white-space: pre-wrap;">  </span>println!("a[1] is none");<br />
}</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="coalesce" id="coalesce"></a><a href="#coalesce-note">coalesce</a></td>
<td>let a = vec![Some(1_i32), None];<br />
let i: i32 = a[1].unwrap_or(0_i32);</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="nullif" id="nullif"></a><a href="#nullif-note">nullif</a></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="expr-type-declaration" id="expr-type-declaration"></a><a href="#expr-type-decl-note">expression type declaration</a></td>
<td></td>
<td></td>
<td>1: Double</td>
</tr>
<tr>
<th colspan="4"><a name="arithmetic-logic" id="arithmetic-logic"></a><a href="#arithmetic-logic-note">arithmetic and logic</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="boolean-type" id="boolean-type"></a><a href="#boolean-type-note">boolean type</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>bool</td>
<td>Bool</td>
<td>Boolean</td>
</tr>
<tr>
<td><a name="true-false" id="true-false"></a><a href="#true-false-note">true and false</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>true false</td>
<td>true false</td>
<td>true false</td>
</tr>
<tr>
<td><a name="falsehoods" id="falsehoods"></a><a href="#falsehoods-note">falsehoods</a></td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td><a name="logical-op" id="logical-op"></a><a href="#logical-op-note">logical operators</a></td>
<td><span style="white-space: pre-wrap;">&amp;&amp; || !</span><br />
<br />
<span style="color: gray"><em><span style="white-space: pre-wrap;">&amp;&amp; and ||</span> are short-circuit operators.</em></span></td>
<td><span style="white-space: pre-wrap;">&amp;&amp; || !</span></td>
<td>&amp;&amp; <span style="white-space: pre-wrap;">||</span> !</td>
</tr>
<tr>
<td><a name="relational-op" id="relational-op"></a><a href="#relational-op-note">relational operators</a></td>
<td>== != &lt; &gt; &lt;= &gt;=</td>
<td>== != &lt; &gt; &lt;= &gt;=</td>
<td>== != &lt; &gt; &lt;= &gt;=</td>
</tr>
<tr>
<td><a name="min-max" id="min-max"></a><a href="#min-max-note">min and max</a></td>
<td></td>
<td></td>
<td>math.min 1 2<br />
math.max 1 2</td>
</tr>
<tr>
<td><a name="int-type" id="int-type"></a><a href="#int-type-note">integer type</a></td>
<td>i8<br />
i16<br />
i32<br />
i64</td>
<td>Int8<br />
Int16<br />
Int32 (Int)<br />
Int64</td>
<td><span style="color: gray"><em>type of integer literals:</em></span><br />
Int<br />
<span style="color: gray"><em>other modular types:</em></span><br />
Byte Short Long<br />
<span style="color: gray"><em>arbitrary precision type:</em></span><br />
BigInt</td>
</tr>
<tr>
<td><a name="unsigned-int-type" id="unsigned-int-type"></a><a href="#unsigned-int-type-note">unsigned integer type</a></td>
<td>u8<br />
u16<br />
u32<br />
u64</td>
<td>UInt8<br />
UInt16<br />
UInt32<br />
UInt64 (UInt)</td>
<td></td>
</tr>
<tr>
<td><a name="int-literal" id="int-literal"></a><a href="#int-literal-note">integer literal</a></td>
<td>-4<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> specify size:</span><br />
-4_i32</td>
<td></td>
<td>-4</td>
</tr>
<tr>
<td><a name="float-type" id="float-type"></a><a href="#float-type-note">float type</a></td>
<td>f32<br />
f64</td>
<td>Float<br />
Double</td>
<td><span style="color: gray"><em>type of float literals:</em></span><br />
Double<br />
<span style="color: gray"><em>other types:</em></span><br />
Float</td>
</tr>
<tr>
<td><a name="arith-op" id="arith-op"></a><a href="#arith-op-note">arithmetic operators</a></td>
<td>+ - * / %</td>
<td>+ - * / %</td>
<td>+ - * / %</td>
</tr>
<tr>
<td><a name="add-int-float" id="add-int-float"></a><a href="#add-int-float-note">add integer and float</a></td>
<td>let n: i32 = 3;<br />
let x = n as f64;<br />
let y = x + 0.5;</td>
<td></td>
<td>3 + 7.0</td>
</tr>
<tr>
<td><a name="int-div" id="int-div"></a><a href="#int-div-note">integer division</a><br />
<span style="color: gray"><em>and remainder</em></span></td>
<td>7 / 3<br />
7 % 3</td>
<td>7 / 3<br />
7 % 3</td>
<td>7 / 3<br />
7 % 3</td>
</tr>
<tr>
<td><a name="int-div-zero" id="int-div-zero"></a><a href="#int-div-zero-note">integer division by zero</a></td>
<td><span style="color: gray"><em>runtime error</em></span></td>
<td><span style="color: gray"><em>process sent a</em> SIGILL <em>signal</em></span></td>
<td>java.lang.ArithmeticException</td>
</tr>
<tr>
<td><a name="float-div" id="float-div"></a><a href="#float-div-note">float division</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>7_f64 / 3_f64</td>
<td>Double(7) / 3</td>
<td>(7: Double) / 3</td>
</tr>
<tr>
<td><a name="float-div-zero" id="float-div-zero"></a><a href="#float-div-zero-note">float division by zero</a></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> these are float values but not literals:</span><br />
inf, Nan, or -inf</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> these are float values but not literals:</span><br />
+Inf, NaN, <span style="color: gray"><em>or</em></span> -Inf</td>
<td><span style="color: gray"><em>evaluates to</em> Infinity, NaN, <em>or</em> -Infinity, <em>values which do not have literals</em></span></td>
</tr>
<tr>
<td><a name="power" id="power"></a><a href="#power-note">power</a></td>
<td>let n = 2_i64.pow(32_u32);<br />
let x1 = 3.14_f64.powi(32_i32);<br />
let x2 = 3.14_f64.powf(3.5_f64);</td>
<td>pow(2.0, 32.0)</td>
<td>math.pow(2, 32)</td>
</tr>
<tr>
<td><a name="sqrt" id="sqrt"></a><a href="#sqrt-note">sqrt</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>let x = 2_f64.sqrt();</td>
<td>sqrt(2.0)</td>
<td>math.sqrt(2)</td>
</tr>
<tr>
<td><a name="sqrt-negative-one" id="sqrt-negative-one"></a><a href="#sqrt-negative-one-note">sqrt -1</a></td>
<td>let x = (-1_f64).sqrt();<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> No negative literals and unary negation has lower<br />
<span style="white-space: pre-wrap;">//</span> precedence that a method, so this is -1:</span><br />
let y = -1_f64.sqrt();</td>
<td><span style="color: gray">// NaN:</span><br />
sqrt(-1)</td>
<td><span style="color: gray">math.sqrt(-1) <em>evaluates to</em> NaN, <em>a value which has no literal</em></span></td>
</tr>
<tr>
<td><a name="transcendental-func" id="transcendental-func"></a><a href="#transcendental-func-note">transcendental functions</a></td>
<td>let x = 0.5_f64;<br />
<br />
x.exp() x.ln() x.log2() x.log10()<br />
x.sin() x.cos() x.tan()<br />
x.asin() x.acos() x.atan()<br />
x.atan2(3.1_f64)</td>
<td>exp log log2 log10<br />
sin cos tan<br />
asin acos atan<br />
atan2</td>
<td>math.exp math.log<br />
math.sin math.cos math.tan<br />
math.asin math.acos math.atan math.atan2</td>
</tr>
<tr>
<td><a name="transcendental-const" id="transcendental-const"></a><a href="#transcendental-const-note">transcendental constants</a></td>
<td>std::f64::consts::PI<br />
std::f64::consts::E</td>
<td></td>
<td>math.Pi<br />
math.E</td>
</tr>
<tr>
<td><a name="float-truncation" id="float-truncation"></a><a href="#float-truncation-note">float truncation</a></td>
<td>3.77_f64.trunc()<br />
3.77_f64.round()<br />
3.77_f64.floor()<br />
3.77_f64.ceil()</td>
<td>Int(3.77)<br />
Int(round(3.77))<br />
Int(floor(3.77))<br />
Int(ceil(3.77))</td>
<td><span style="color: gray"><em>??</em></span><br />
3.14.round<br />
3.14.floor <span style="color: gray"><em>returns Double</em></span><br />
3.14.ceil <span style="color: gray"><em>returns Double</em></span></td>
</tr>
<tr>
<td><a name="abs-val" id="abs-val"></a><a href="#abs-val-note">absolute value</a><br />
<span style="color: gray"><em>and signum</em></span></td>
<td>-7_i32.abs()<br />
-7.1_f64.abs()<br />
-7_i32.signum()<br />
-7.1_f64.signum()</td>
<td>abs(-7)<br />
fabs(-7.77)</td>
<td>math.abs(-7)<br />
math.signum(-7)</td>
</tr>
<tr>
<td><a name="int-overflow" id="int-overflow"></a><a href="#int-overflow-note">integer overflow</a></td>
<td><span style="color: gray"><em>panic</em></span></td>
<td></td>
<td><span style="color: gray"><em>modular arithmetic for all types except</em></span> BigInt</td>
</tr>
<tr>
<td><a name="float-overflow" id="float-overflow"></a><a href="#float-overflow-note">float overflow</a></td>
<td><span style="color: gray"><em>evaluates to</em> std::f32::INFINITY <em>or</em> std::f64::INFINITY</span></td>
<td></td>
<td><span style="color: gray"><em>evaluates to</em> Infinity, <em>a value which has no literal</em></span></td>
</tr>
<tr>
<td><a name="arbitrary-len-int" id="arbitrary-len-int"></a><a href="#arbitrary-len-int-note">arbitrary length integer</a></td>
<td></td>
<td></td>
<td>val n = BigInt(7)<br />
val m = BigInt(12)</td>
</tr>
<tr>
<td><a name="arbitrary-len-int-op" id="arbitrary-len-int-op"></a><a href="#arbitrary-len-int-op-note">arbitrary length integer operators</a></td>
<td></td>
<td></td>
<td>n + m<br />
n - m<br />
n * m<br />
n / m<br />
n % m<br />
<br />
n == m<br />
n &lt; m<br />
n &lt; m<br />
n &lt;= m<br />
n &gt;= m</td>
</tr>
<tr>
<td><a name="random-num" id="random-num"></a><a href="#random-num-note">random number</a><br />
<span style="color: gray"><em>uniform int, uniform float, normal float</em></span></td>
<td>use std::rand;<br />
<br />
let n = rand::random::&lt;uint&gt;() % 100u;<br />
let x = rand::random::&lt;f64&gt;();<br />
<span style="color: gray"><em>??</em></span></td>
<td>let i = rand()<br />
<span style="color: gray"><em>??</em></span></td>
<td>import scala.util.Random<br />
<br />
val rnd = Random<br />
<br />
rnd.nextInt(100)<br />
rnd.nextDouble<br />
rnd.nextGaussian</td>
</tr>
<tr>
<td><a name="random-seed" id="random-seed"></a><a href="#random-seed-note">random seed</a><br />
<span style="color: gray"><em>set, get, restore</em></span></td>
<td></td>
<td>srand(17)</td>
<td>import scala.util.Random<br />
<br />
val rnd = Random<br />
<br />
rnd.setSeed(17)<br />
<span style="color: gray"><em>none</em></span><br />
<span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="bit-op" id="bit-op"></a><a href="#bit-op-note">bit operators</a></td>
<td><span style="white-space: pre-wrap;">&lt;&lt; &gt;&gt; &amp; | ^ !</span></td>
<td><span style="white-space: pre-wrap;">&lt;&lt; &gt;&gt; &amp; | ^ ~</span></td>
<td>1<span style="white-space: pre-wrap;"> &lt;&lt; </span> 4<br />
1 <span style="white-space: pre-wrap;"> &gt;&gt; </span> 4<br />
1 &amp; 3<br />
1 | 3<br />
1 ^ 3<br />
~ 1</td>
</tr>
<tr>
<td><a name="binary-octal-hex-literals" id="binary-octal-hex-literals"></a><a href="#binary-octal-hex-literals-note">binary, octal, and hex literals</a></td>
<td>0b101010<br />
0o52<br />
0x21</td>
<td></td>
<td><span style="color: gray"><em>none</em></span><br />
052<br />
0x2a</td>
</tr>
<tr>
<td><a name="radix" id="radix"></a><a href="#radix-note">radix</a></td>
<td></td>
<td></td>
<td>Integer.toString(42, 7)<br />
Integer.parseInt("60", 7)</td>
</tr>
<tr>
<th colspan="4"><a name="strings" id="strings"></a><a href="#strings-note">strings</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="str-type" id="str-type"></a><a href="#str-type-note">string type</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>String<br />
<br />
<span style="color: gray"><em>string reference:</em></span><br />
&amp;str</td>
<td>String</td>
<td>java.lang.String</td>
</tr>
<tr>
<td><a name="str-literal" id="str-literal"></a><a href="#str-literal-note">string literal</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>let s: &amp;str = "don't say \"no\"";<br />
let s2: String = "don't say \"no\"".to_string();</td>
<td>"hello"</td>
<td>"Hello, World!"<br />
<br />
"""Hello, World!"""</td>
</tr>
<tr>
<td><a name="newline-in-str-literal" id="newline-in-str-literal"></a><a href="#newline-in-str-literal-note">newline in literal</a></td>
<td>let s: &amp;str = "first line<br />
second line";<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> foobar:</span><br />
let s2: &amp;str = "foo\<br />
<span style="white-space: pre-wrap;">  </span>bar";</td>
<td><span style="color: gray"><em>no</em></span></td>
<td><span style="color: gray"><em>in triple quote literal only</em></span></td>
</tr>
<tr>
<td><a name="str-esc" id="str-esc"></a><a href="#str-esc-note">literal escapes</a></td>
<td>\0 \\ \t \n \r \" \\<br />
\x<span style="color: gray"><em>hh</em></span> \u<span style="color: gray"><em>hhhh</em></span> \U<span style="color: gray"><em>hhhhhhhh</em></span></td>
<td>\0 \\ \t \n \r \" \'<br />
\x<span style="color: gray"><em>hh</em></span> \u<span style="color: gray"><em>hhhh</em></span> \U<span style="color: gray"><em>hhhhhhhh</em></span></td>
<td>\b \f \n \r \t \" \'<br />
\u<span style="color: gray"><em>hhhh</em></span> \<span style="color: gray"><em>o</em></span> \<span style="color: gray"><em>oo</em></span> \<span style="color: gray"><em>ooo</em></span></td>
</tr>
<tr>
<td><a name="format-str" id="format-str"></a><a href="#format-str-note">format string</a></td>
<td>let s = format!("foo {} {} {}", "bar", 7, 3.14_f32);</td>
<td>let n = 3, m = 5<br />
let msg = "\(n) + \(m) is \(n + m)"</td>
<td>"foo %s %d %.2f".format("bar", 7, 3.1415)<br />
<br />
val n = 3<br />
val m = 5<br />
val msg = s"$n + $m is ${n + m}"</td>
</tr>
<tr>
<td><a name="str-concat" id="str-concat"></a><a href="#str-concat-note">concatenate</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>let s1: String = "hello".to_string();<br />
let s2: &amp;str = " world";<br />
let s: String = s1 + s2;</td>
<td>"hello" + " world"</td>
<td>"Hello" + ", " + "World!"</td>
</tr>
<tr>
<td><a name="str-replicate" id="str-replicate"></a><a href="#str-replicate-note">replicate</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td>let ch: Character = "-"<br />
let hbar = String(count: 80, repeatedValue: ch)</td>
<td>val hbar = "-" * 80</td>
</tr>
<tr>
<td><a name="translate-case" id="translate-case"></a><a href="#translate-case-note">translate case</a><br />
<span style="color: gray"><em>to upper, to lower</em></span></td>
<td>s.to_uppercase()<br />
s.to_lowercase()</td>
<td>let s = "hello"<br />
let s2 = s.uppercaseString<br />
<br />
let s3 = "HELLO"<br />
let s4 = s3.lowercaseString</td>
<td>"hello".toUpperCase<br />
"HELLO".toLowerCase</td>
</tr>
<tr>
<td><a name="capitalize" id="capitalize"></a><a href="#capitalize-note">capitalize</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>"hello".capitalize</td>
</tr>
<tr>
<td><a name="trim" id="trim"></a><a href="#trim-note">trim</a><br />
<span style="color: gray"><em>both sides, left, right</em></span></td>
<td></td>
<td></td>
<td>" hello ".trim</td>
</tr>
<tr>
<td><a name="pad" id="pad"></a><a href="#pad-note">pad</a><br />
<span style="color: gray"><em>on left, on right</em></span></td>
<td></td>
<td></td>
<td><span style="color: gray"><em>??</em></span><br />
"hello".padTo(10, " ").mkString</td>
</tr>
<tr>
<td><a name="num-to-str" id="num-to-str"></a><a href="#num-to-str-note">number to string</a></td>
<td></td>
<td>let n = String(17)<br />
let x = String(17.3)</td>
<td>"two: " + 2.toString<br />
"pi: " + 3.14.toString</td>
</tr>
<tr>
<td><a name="str-to-num" id="str-to-num"></a><a href="#str-to-num-note">string to number</a></td>
<td>let n = "12".parse::&lt;i32&gt;().unwrap();<br />
let x = ".037".parse::&lt;f64&gt;().unwrap();<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> parse() returns an Option type.<br />
<span style="white-space: pre-wrap;">//</span> unrwap() panics if parse() returns None.</span></td>
<td>"17".toInt()<br />
<br />
<span style="color: gray">// evaluates to nil:</span><br />
"17foo".toInt()<br />
<br />
<span style="color: gray">// convert to float?</span></td>
<td>7 + "12".toInt<br />
73.9 + ".037".toFloat<br />
<span style="color: gray"><em>raises</em> NumberFormatException <em>if string doesn't completely parse</em></span></td>
</tr>
<tr>
<td><a name="join" id="join"></a><a href="#join-note">join</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List("do", "re", "mi").mkString(" ")</td>
</tr>
<tr>
<td><a name="split" id="split"></a><a href="#split-note">split</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>"do re mi".split(" ")</td>
</tr>
<tr>
<td><a name="char-type" id="char-type"></a><a href="#char-type-note">character type</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td>Character</td>
<td>Char</td>
</tr>
<tr>
<td><a name="char-literal" id="char-literal"></a><a href="#char-literal-note">character literal</a></td>
<td></td>
<td></td>
<td>'h'</td>
</tr>
<tr>
<td><a name="str-len" id="str-len"></a><a href="#str-len-note">length</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td>countElements("hello")</td>
<td>"hello".length</td>
</tr>
<tr>
<td><a name="index-substr" id="index-substr"></a><a href="#index-substr-note">index of substring</a></td>
<td></td>
<td></td>
<td>"hello".indexOf("hell")</td>
</tr>
<tr>
<td><a name="substr" id="substr"></a><a href="#substr-note">extract substring</a></td>
<td></td>
<td></td>
<td>"hello".substring(0, 4)</td>
</tr>
<tr>
<td><a name="extract-char" id="extract-char"></a><a href="#extract-char-note">extract character</a></td>
<td></td>
<td></td>
<td>"hello"(0)</td>
</tr>
<tr>
<td><a name="chr-ord" id="chr-ord"></a><a href="#chr-ord-note">chr and ord</a></td>
<td></td>
<td></td>
<td>'a'.toInt<br />
97.toChar</td>
</tr>
<tr>
<th colspan="4"><a name="dates-time" id="dates-time"></a><a href="#dates-time-note">dates and time</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="dates-time-types" id="dates-time-types"></a><a href="#dates-time-types-note">date and time types</a></td>
<td>extern crate chrono;<br />
<br />
chrono::DateTime</td>
<td></td>
<td>java.util.Date</td>
</tr>
<tr>
<td><a name="current-date-time" id="current-date-time"></a><a href="#current-date-time-note">current date and time</a></td>
<td>extern crate chrono;<br />
<br />
let dt = Local::now();<br />
let dt_utc = UTC::now();</td>
<td></td>
<td>import java.util.Date<br />
<br />
val dt = new Date()</td>
</tr>
<tr>
<td><a name="current-unix-epoch" id="current-unix-epoch"></a><a href="#current-unix-epoch-note">current unix epoch</a></td>
<td>extern crate chrono;<br />
<br />
let dt = UTC::now();<br />
let t = dt.timestamp();</td>
<td></td>
<td>dt.getTime / 1000</td>
</tr>
<tr>
<td>to unix epoch, from unix epoch</td>
<td>extern crate chrono;<br />
<br />
let t = dt.timestamp();<br />
let dt2 = chrono::NaiveDateTime::from_timestamp(t, 0);</td>
<td></td>
<td>dt.getTime / 1000<br />
<br />
val dt2 = new Date(1451600610 * 1000)</td>
</tr>
<tr>
<td>format date</td>
<td>dt.format("%Y-%m-%d %H:%M:%S")</td>
<td></td>
<td>import java.text.SimpleDateFormat<br />
<br />
val fmt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")<br />
val s = fmt.format(dt)</td>
</tr>
<tr>
<td>parse date</td>
<td></td>
<td></td>
<td>import java.text.SimpleDateFormat<br />
<br />
val fmt = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")<br />
val dt = fmt.parse("2011-05-03 17:00:00")</td>
</tr>
<tr>
<td>date subtraction</td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> difference in milliseconds as Long:</span><br />
dt2.getTime - dt.getTime</td>
</tr>
<tr>
<td>add duration</td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> add one day:</span><br />
val dt2 = new Date(dt.getTime + 86400 * 1000)</td>
</tr>
<tr>
<td>date parts</td>
<td></td>
<td></td>
<td>import java.util.Date<br />
import java.util.Calendar<br />
import java.util.GregorianCalendar<br />
<br />
al cal = new GregorianCalendar<br />
cal.setTime(new Date)<br />
<br />
cal.get(Calendar.YEAR)<br />
cal.get(Calendar.MONTH) + 1<br />
cal.get(Calendar.DAY_OF_MONTH)</td>
</tr>
<tr>
<td>time parts</td>
<td></td>
<td></td>
<td>import java.util.Date<br />
import java.util.Calendar<br />
import java.util.GregorianCalendar<br />
<br />
al cal = new GregorianCalendar<br />
cal.setTime(new Date)<br />
<br />
cal.get(Calendar.HOUR_OF_DAY)<br />
cal.get(Calendar.MINUTE)<br />
cal.get(Calendar.SECOND)</td>
</tr>
<tr>
<td>build broken-down datetime</td>
<td></td>
<td></td>
<td>import java.util.GregorianCalendar<br />
<br />
val cal = new GregorianCalendar(2015, 12, 31, 23, 59, 59)<br />
val dt = cal.getTime</td>
</tr>
<tr>
<th colspan="4"><a name="fixed-length-arrays" id="fixed-length-arrays"></a><a href="#fixed-length-arrays-note">fixed-length arrays</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="array-literal" id="array-literal"></a><a href="#array-literal-note">literal</a></td>
<td>let nums = [1i32, 2i32, 3i32];</td>
<td></td>
<td>val a = Array(1, 2, 3)</td>
</tr>
<tr>
<td><a name="array-size" id="array-size"></a><a href="#array-size-note">size</a></td>
<td></td>
<td></td>
<td>a.size</td>
</tr>
<tr>
<td><a name="array-lookup" id="array-lookup"></a><a href="#array-lookup-note">lookup</a></td>
<td>nums[0]</td>
<td></td>
<td>val n = a(0)</td>
</tr>
<tr>
<td><a name="array-update" id="array-update"></a><a href="#array-update-note">update</a></td>
<td>let mut nums = [1i32, 2i32, 3i32];<br />
<br />
a[2] = 4;</td>
<td></td>
<td>a(2) = 4</td>
</tr>
<tr>
<td><a name="array-out-of-bounds" id="array-out-of-bounds"></a><a href="#array-out-of-bounds-notes">out-of-bounds</a></td>
<td><span style="color: gray"><em>compilation error</em></span></td>
<td></td>
<td><span style="color: gray"><em>raises</em></span> java.lang.ArrayIndexOutOfBounds</td>
</tr>
<tr>
<th colspan="4"><a name="resizable-arrays" id="resizable-arrays"></a><a href="#resizable-arrays-note">resizable arrays</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="declare-array" id="declare-array"></a><a href="#declare-array-note">declare</a></td>
<td>let mut a = Vec::new();<br />
let mut a2: Vec&lt;i32&gt; = Vec::new();</td>
<td>let a: Array&lt;Int&gt; = []<br />
let a2: Int[] = []</td>
<td></td>
</tr>
<tr>
<td><a name="array-literal" id="array-literal"></a><a href="#array-literal-note">literal</a></td>
<td>let mut a = vec![1, 2, 3];</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> array is mutable; variable is not:</span><br />
let a = [1, 2, 3]</td>
<td>import scala.collection.mutable.ArrayBuffer<br />
<br />
val a = ArrayBuffer(1, 2, 3)</td>
</tr>
<tr>
<td><a name="array-size" id="array-size"></a><a href="#array-size-note">size</a></td>
<td>a.len()</td>
<td>a.count</td>
<td>a.length</td>
</tr>
<tr>
<td><a name="array-lookup" id="array-lookup"></a><a href="#array-lookup-note">lookup</a></td>
<td>a[0]</td>
<td>a[0]</td>
<td>a(0)</td>
</tr>
<tr>
<td><a name="array-update" id="array-update"></a><a href="#array-update-note">update</a></td>
<td>a[0] = 4;</td>
<td>a[0] = 4</td>
<td>a(0) = 4</td>
</tr>
<tr>
<td><a name="array-out-of-bounds" id="array-out-of-bounds"></a><a href="#array-out-of-bounds-notes">out-of-bounds</a></td>
<td>let mut a = vec![1, 2, 3];<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> thread panics:</span><br />
let n = a[7];<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> returns None:</span><br />
let n = a.get(7);</td>
<td><span style="color: gray"><em>raises</em> SIGILL</span></td>
<td><span style="color: gray"><em>raises</em> java.lang.ArrayIndexOutOfBoundsException</span></td>
</tr>
<tr>
<td><a name="array-element-index" id="array-element-index"></a><a href="#array-element-index-note">element index</a></td>
<td></td>
<td></td>
<td>a.indexOf(3)</td>
</tr>
<tr>
<td><a name="slice-array" id="slice-array"></a><a href="#slice-array-note">slice</a></td>
<td></td>
<td>var a = ["a", "b", "c", "d", "e"]<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> ["c", "d"]:</span><br />
a[2<span style="white-space: pre-wrap;">...</span>3]<br />
a[2..4]</td>
<td>val a = ArrayBuffer("a", "b", "c", "d", "e")<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> ArrayBuffer("c", "d"):</span><br />
a.slice(2, 4)</td>
</tr>
<tr>
<td><a name="slice-array-to-end" id="slice-array-to-end"></a><a href="#slice-array-to-end-note">slice to end</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> ArrayBuffer("c", "d", "e"):</span><br />
a.drop(2)</td>
</tr>
<tr>
<td><a name="array-back" id="array-back"></a><a href="#array-back-note">manipulate back</a></td>
<td>let mut a: Vec&lt;i32&gt; = vec![1, 2, 3];<br />
a.push(4);<br />
let n = a.pop();</td>
<td>let a = [1, 2, 3]<br />
a.append(4)<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> sets num to 4:</span><br />
let num = a.removeLast()</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> two ways to append:</span><br />
a.append(4)<br />
a += 4<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> inspect last item:</span><br />
val x = a.last<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> pop last item:</span><br />
val y = a.remove(a.length - 1)</td>
</tr>
<tr>
<td><a name="array-front" id="array-front"></a><a href="#array-front-note">manipulate front</a></td>
<td></td>
<td>let a = [1, 2, 3]<br />
a.insert(0, atIndex: 0)<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> sets num to 0:</span><br />
let num = a.removeAtIndex(0)</td>
<td>val a = ArrayBuffer(7, 8, 9)<br />
<br />
a.insert(0, 6)<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> inspect first element:</span><br />
val x = a.first<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> pop first element:</span><br />
val y = a.remove(0)</td>
</tr>
<tr>
<td><a name="concatenate-array" id="concatenate-array"></a><a href="#concatenate-array-note">concatenate</a></td>
<td></td>
<td>let a = [1, 2, 3]<br />
a += [4, 5, 6]<br />
<br />
let a3 = [1, 2, 3] + [4, 5, 6]</td>
<td>val a1 = ArrayBuffer(1, 2, 3)<br />
val a2 = ArrayBuffer(4, 5, 6)<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> new ArrayBuffer:</span><br />
val a2 = a1 ++ a2<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> add elements to a1:</span><br />
a1 ++= a2</td>
</tr>
<tr>
<td><a name="copy-array" id="copy-array"></a><a href="#copy-array-note">copy</a></td>
<td>let a: Vec&lt;i32&gt; = vec![1, 2, 3];<br />
let mut a2 = a.clone();<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> a[0] does not change:</span><br />
a2[0] = 4;</td>
<td>let a = [1, 2, 3]<br />
<br />
let a2 = a<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> also modifies a[0]:</span><br />
a2[0] = 4<br />
<br />
a3 = Array(a)<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> a[0] remains 4:</span><br />
a3[0] = 5</td>
<td>val a = ArrayBuffer(1, 2, 3)<br />
val a2 = ArrayBuffer[Int]()<br />
a2 ++= a</td>
</tr>
<tr>
<td><a name="iterate-over-array" id="iterate-over-array"></a><a href="#iterate-over-array-note">iterate over elements</a></td>
<td>let a: Vec&lt;i32&gt; = vec![1, 2, 3];<br />
for i in a {<br />
<span style="white-space: pre-wrap;">  </span>println!("i: {}", i);<br />
}</td>
<td></td>
<td>for (n &lt;- a)<br />
<span style="white-space: pre-wrap;">  </span>println(n)</td>
</tr>
<tr>
<td><a name="iterate-indices-elem" id="iterate-indices-elem"></a><a href="#iterate-indices-elem-note">iterate over indices and elements</a></td>
<td></td>
<td></td>
<td>for ((n, i) &lt;- a.zipWithIndex) {<br />
<span style="white-space: pre-wrap;">  </span>println(s"item: $n is at: $i")<br />
}</td>
</tr>
<tr>
<td><a name="reverse-array" id="reverse-array"></a><a href="#reverse-array-note">reverse</a></td>
<td>let mut a: Vec&lt;i32&gt; = vec![1, 2, 3];<br />
a.reverse();</td>
<td>let a = [1, 2, 3]<br />
let a2 = a.reverse()</td>
<td>val a2 = a.reverse</td>
</tr>
<tr>
<td><a name="sort-array" id="sort-array"></a><a href="#sort-array-note">sort</a></td>
<td>let mut a: Vec&lt;i32&gt; = vec![3, 1, 4, 2];<br />
a.sort();</td>
<td>let a = [1, 3, 2, 4]<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> modifies a in-place and returns it:</span><br />
sort(a)</td>
<td>val a = ArrayBuffer(3, 1, 4, 2)<br />
val a2 = a.sortWith(_ &lt; _)</td>
</tr>
<tr>
<td><a name="array-dedupe" id="array-dedupe"></a><a href="#array-dedupe-note">dedupe</a></td>
<td></td>
<td></td>
<td>ArrayBuffer(1, 2, 3, 3).distinct<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> scala.collection.immutable.Set[Int]:</span><br />
val set = a.toSet</td>
</tr>
<tr>
<td><a name="array-membership" id="array-membership"></a><a href="#array-membership-note">membership</a></td>
<td>if a.contains(&amp;7) {<br />
<span style="white-space: pre-wrap;">  </span>println!("contains 7");<br />
}</td>
<td></td>
<td>ArrayBuffer(1, 2, 3).contains(7)</td>
</tr>
<tr>
<td><a name="array-intersection" id="array-intersection"></a><a href="#array-intersection-note">intersection</a></td>
<td></td>
<td></td>
<td>val a1 = ArrayBuffer(1, 2)<br />
val a2 = ArrayBuffer(2, 3, 4)<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> multiset intersection:</span><br />
a1.intersect(a2)</td>
</tr>
<tr>
<td><a name="array-union" id="array-union"></a><a href="#array-union-note">union</a></td>
<td></td>
<td></td>
<td>val a1 = ArrayBuffer(1, 2)<br />
val a2 = ArrayBuffer(2, 3, 4)<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> multiset union:</span><br />
a1.union(a2)</td>
</tr>
<tr>
<td><a name="array-relative-complement" id="array-relative-complement"></a><a href="#array-relative-complement-note">relative complement</a></td>
<td></td>
<td></td>
<td>val a1 = ArrayBuffer(1, 2)<br />
val a2 = ArrayBuffer(2, 3, 4)<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> multiset difference:</span><br />
a1.diff(a2)</td>
</tr>
<tr>
<td><a name="map" id="map"></a><a href="#map-note">map</a></td>
<td></td>
<td></td>
<td>a.map(x =&gt; x * x)</td>
</tr>
<tr>
<td><a name="filter" id="filter"></a><a href="#filter-note">filter</a></td>
<td></td>
<td></td>
<td>a.filter(_ &gt; 2)</td>
</tr>
<tr>
<td><a name="array-fold-left" id="array-fold-left"></a><a href="#array-fold-left-note">fold left</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> -6:</span><br />
ArrayBuffer(1, 2, 3).foldLeft(0)(_ - _)</td>
</tr>
<tr>
<td><a name="array-fold-right" id="array-fold-right"></a><a href="#array-fold-right-note">fold right</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> -2:</span><br />
ArrayBuffer(1, 2, 3).foldRight(0)(_ - _)</td>
</tr>
<tr>
<td><a name="array-shuffle" id="array-shuffle"></a><a href="#array-shuffle-note">shuffle</a></td>
<td></td>
<td></td>
<td>val rand = scala.util.Random<br />
val a = rand.shuffle(ArrayBuffer(1, 2, 3, 4))</td>
</tr>
<tr>
<td><a name="array-flatten" id="array-flatten"></a><a href="#array-flatten-note">flatten</a></td>
<td></td>
<td></td>
<td>val a = ArrayBuffer(ArrayBuffer(1, 2), ArrayBuffer(3, 4))<br />
val a2 = a.flatten</td>
</tr>
<tr>
<td><a name="array-zip" id="array-zip"></a><a href="#array-zip-note">zip</a></td>
<td></td>
<td></td>
<td>ArrayBuffer(1, 2, 3).zip(ArrayBuffer("a", "b", "c"))</td>
</tr>
<tr>
<th colspan="4"><a name="lists" id="lists"></a><a href="#lists-note">lists</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="list-literal" id="list-literal"></a><a href="#list-literal-note">literal</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> none; use constructor:</span><br />
List(1, 2, 3)</td>
</tr>
<tr>
<td><a name="empty-list" id="empty-list"></a><a href="#empty-list-note">empty list</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>Nil<br />
List()</td>
</tr>
<tr>
<td><a name="empty-list-test" id="empty-list-test"></a><a href="#empty-list-test-note">empty list test</a></td>
<td></td>
<td></td>
<td>val list = List(1, 2, 3)<br />
<br />
list == Nil<br />
list.isEmpty</td>
</tr>
<tr>
<td><a name="cons" id="cons"></a><a href="#cons-note">cons</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>1 :: List(2, 3)</td>
</tr>
<tr>
<td><a name="head" id="head"></a><a href="#head-note">head</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).head</td>
</tr>
<tr>
<td><a name="tail" id="tail"></a><a href="#tail-note">tail</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).tail</td>
</tr>
<tr>
<td><a name="head-tail-empty-list" id="head-tail-empty-list"></a><a href="#head-tail-empty-list-note">head and tail of empty list</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> NoSuchElementException:</span><br />
Nil.head<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> UnsupportedOperationException:</span><br />
Nil.tail</td>
</tr>
<tr>
<td><a name="list-length" id="list-length"></a><a href="#list-length-note">length</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).length</td>
</tr>
<tr>
<td><a name="nth-elem-of-list" id="nth-elem-of-list"></a><a href="#nth-elem-of-list-note">nth element</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3)(0)</td>
</tr>
<tr>
<td><a name="list-elem-index" id="list-elem-index"></a><a href="#list-elem-index-note">element index</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> evaluates to 1:</span><br />
List(7, 8, 9).indexOf(8)<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> evaluates to -1:</span><br />
List(7, 8, 9).indexOf(10)</td>
</tr>
<tr>
<td><a name="update-list" id="update-list"></a><a href="#update-list-note">update</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> evaluates to List(1, 4, 3):</span><br />
List(1, 2, 3).updated(1, 4)</td>
</tr>
<tr>
<td><a name="concat-list" id="concat-list"></a><a href="#concat-list-note">concatenate</a><br />
<span style="color: gray"><em>two lists, list of lists</em></span></td>
<td></td>
<td></td>
<td>List(1, 2) ::: List(3, 4)<br />
List(1, 2) ++ List(3, 4)<br />
<br />
List(List(1, 2), List(3, 4)).flatten</td>
</tr>
<tr>
<td><a name="list-last" id="list-last"></a><a href="#list-last-note">last</a><br />
<span style="color: gray"><em>and butlast</em></span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).last<br />
List(1, 2, 3).init</td>
</tr>
<tr>
<td><a name="list-take" id="list-take"></a><a href="#list-take-note">take</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).take(2)</td>
</tr>
<tr>
<td><a name="list-drop" id="list-drop"></a><a href="#list-drop-note">drop</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).drop(2)</td>
</tr>
<tr>
<td><a name="iterate-over-list" id="iterate-over-list"></a><a href="#iterate-over-list-note">iterate</a></td>
<td></td>
<td></td>
<td>List(1, 2, 3).foreach(i =&gt; println(i))<br />
<br />
for (i &lt;- List.range(1, 11).reverse)<br />
<span style="white-space: pre-wrap;">  </span>println(i)</td>
</tr>
<tr>
<td><a name="reverse-list" id="reverse-list"></a><a href="#reverse-list-note">reverse</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).reverse</td>
</tr>
<tr>
<td><a name="sort-list" id="sort-list"></a><a href="#sort-list-note">sort</a></td>
<td></td>
<td></td>
<td>List(1, 3, 2, 4).sortWith((x, y) =&gt; x &lt; y)<br />
List(1, 3, 2, 4).sortWith(_ &lt; _)<br />
List(1, 3, 2, 4).sortWith((x, y) =&gt; x &gt; y)<br />
List(1, 3, 2, 4).sortWith(_ &gt; _)</td>
</tr>
<tr>
<td><a name="map-list" id="map-list"></a><a href="#map-list-note">map</a></td>
<td></td>
<td></td>
<td>List(1, 2, 3).map(x =&gt; 2 * x)<br />
List(1, 2, 3).map(2 * _)</td>
</tr>
<tr>
<td><a name="filter-list" id="filter-list"></a><a href="#filter-list-note">filter</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).filter(x =&gt; x &gt; 2)</td>
</tr>
<tr>
<td><a name="fold-list-left" id="fold-list-left"></a><a href="#fold-list-left-note">fold from left</a></td>
<td></td>
<td></td>
<td>List(1, 2, 3).foldLeft(0)(_ + _)<br />
List(1, 2, 3).foldLeft(0)((x, y) =&gt; x + y)</td>
</tr>
<tr>
<td><a name="fold-list-right" id="fold-list-right"></a><a href="#fold-list-right-note">fold from right</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).foldRight(0)(_ - _)</td>
</tr>
<tr>
<td><a name="list-member" id="list-member"></a><a href="#list-member-note">membership</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).contains(3)</td>
</tr>
<tr>
<td><a name="universal-test-list" id="universal-test-list"></a><a href="#universal-test-list-note">universal test</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).forall(_ &gt; 2)</td>
</tr>
<tr>
<td><a name="existential-test-list" id="existential-test-list"></a><a href="#existential-test-list-note">existential test</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>List(1, 2, 3).exists(_ &gt; 2)</td>
</tr>
<tr>
<td><a name="zip-list" id="zip-list"></a><a href="#zip-list-note">zip lists</a></td>
<td></td>
<td></td>
<td>List(1, 2, 3).zip(List("a", "b", "c"))</td>
</tr>
<tr>
<th colspan="4"><a name="tuples" id="tuples"></a><a href="#tuples-note">tuples</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="tuple-literal" id="tuple-literal"></a><a href="#tuple-literal-note">literal</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(1, "hello", true)</td>
<td>(1, "hello", true)</td>
<td>(1, "hello", true)</td>
</tr>
<tr>
<td><a name="tuple-type" id="tuple-type"></a><a href="#tuple-type-note">type</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>let tup: (i32, &amp;str, bool) = (1, "hello", true);</td>
<td>let tup: (Int, String, Bool) = (1, "hello", true)</td>
<td>val tup: (Int, String, Boolean) = (7, "foo", true)</td>
</tr>
<tr>
<td><a name="tuple-lookup" id="tuple-lookup"></a><a href="#tuple-lookup-note">lookup</a></td>
<td>let tup = (1, "hello", true);<br />
let n: i32 = tup.0</td>
<td>let tup = (1, "hello", true)<br />
let n: Int = tup.0</td>
<td>val tup = (1, "hello", true)<br />
val n: Int = tup._1</td>
</tr>
<tr>
<td><a name="deconstruct-tuple" id="deconstruct-tuple"></a><a href="#deconstruct-tuple-note">deconstruct</a></td>
<td>let tup = (1, "hello", true);<br />
let (n, s, b) = tup;<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> use underscores for unneeded elements:</span><br />
let (n, _, _) = tup;</td>
<td>let tup = (1, "hello", true)<br />
let (n, s, b) = tup<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> use underscores for unneeded elements:</span><br />
let (n, _, _) = tup</td>
<td>val tup = (1, "hello", true)<br />
tup match {<br />
<span style="white-space: pre-wrap;">  </span>case (_, s, _) =&gt; println(s)<br />
<span style="white-space: pre-wrap;">  </span>case _ =&gt; throw new Exception("bad tuple")<br />
}</td>
</tr>
<tr>
<th colspan="4"><a name="dictionaries" id="dictionaries"></a><a href="#dictionaries-note">dictionaries</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="declare-dict" id="declare-dict"></a><a href="#declare-dict-note">declare</a></td>
<td>let mut dict = std::collections::HashMap::new();</td>
<td>let dict = Dictionary&lt;String, Int&gt;()</td>
<td>import scala.collection.mutable<br />
<br />
val dict = mutable.Map.empty[String, Int]</td>
</tr>
<tr>
<td><a name="dict-literal" id="dict-literal"></a><a href="#dict-literal-note">literal</a></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> no dict literal</span><br />
let mut dict = std::collections::HashMap::new();<br />
dict.insert("t", 1);<br />
dict.insert("f", 0);</td>
<td>let dict = ["t": 1, "f": 0]</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> scala.collection.immutable.Map[String,Int]:</span><br />
val dict = Map("t" -&gt; 1, "f" -&gt; 0)</td>
</tr>
<tr>
<td><a name="dict-size" id="dict-size"></a><a href="#dict-size-note">size</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>dict.len()</td>
<td>dict.count</td>
<td>dict.size</td>
</tr>
<tr>
<td><a name="dict-lookup" id="dict-lookup"></a><a href="#dict-lookup-note">lookup</a></td>
<td></td>
<td>dict["t"]</td>
<td>dict("f")<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> returns Option[Int]:</span><br />
dict.get("f")</td>
</tr>
<tr>
<td><a name="dict-update" id="dict-update"></a><a href="#dict-update-note">update</a></td>
<td></td>
<td>dict["t"] = 2</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> mutable.Map only:</span><br />
dict("t") = 2</td>
</tr>
<tr>
<td><a name="dict-out-of-bounds" id="dict-out-of-bounds"></a><a href="#dict-out-of-bounds-note">out-of-bounds behavior</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td><span style="color: gray"><em>returns</em></span> nil</td>
<td><span style="color: gray"><em>raises</em> java.util.NoSuchElementException</span></td>
</tr>
<tr>
<td><a name="dict-is-key-present" id="dict-is-key-present"></a><a href="#dict-is-key-present-note">is key present</a></td>
<td></td>
<td>if dict["y"] {<br />
<span style="white-space: pre-wrap;">  </span>println("key found")<br />
} else {<br />
<span style="white-space: pre-wrap;">  </span>println("no such key")<br />
}</td>
<td>dict.exists(kv =&gt; kv._1 == "t")</td>
</tr>
<tr>
<td><a name="dict-delete" id="dict-delete"></a><a href="#dict-delete-note">delete</a></td>
<td></td>
<td>dict.removeValueForKey("t")</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> mutable.Map only:</span><br />
dict.delete("t")</td>
</tr>
<tr>
<td><a name="dict-iterate" id="dict-iterate"></a><a href="#dict-iterate-note">iterate</a></td>
<td></td>
<td>for (k, v) in dict {<br />
<span style="white-space: pre-wrap;">  </span>println("\(k): \(v)")<br />
}</td>
<td>for (kv &lt;- dict) {<br />
<span style="white-space: pre-wrap;">  </span>println(kv._1)<br />
<span style="white-space: pre-wrap;">  </span>println(kv._2)<br />
}</td>
</tr>
<tr>
<td><a name="dict-key-val" id="dict-key-val"></a><a href="#dict-key-val-note">keys and values as arrays</a></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> dict.keys and dict.values are iterable:</span><br />
Array(dict.keys)<br />
Array(dict.values)</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Iterable[String]:</span><br />
dict.keys<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Array[String]:</span><br />
dict.keys.toArray<br />
dict.values<br />
dict.values.toArray</td>
</tr>
<tr>
<th colspan="4"><a name="functions" id="functions"></a><a href="#functions-note">functions</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="def-func" id="def-func"></a><a href="#def-func-note">define function</a></td>
<td>fn add(x: f64, y: f64) -&gt; f64 {<br />
<span style="white-space: pre-wrap;">  </span>x + y<br />
}</td>
<td>func add(n: Int, m: Int) -&gt; Int {<br />
<span style="white-space: pre-wrap;">  </span>return n + m<br />
}</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> argument types must be declared:</span><br />
def average(a: Double, b: Double)<br />
<span style="white-space: pre-wrap;">  </span>= (a + b) / 2.0<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> return value type must be declared if<br />
<span style="white-space: pre-wrap;">//</span> function is recursive:</span><br />
def factorial(n: Int): Int =<br />
<span style="white-space: pre-wrap;">  </span>if (n &lt; 1)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>1<br />
<span style="white-space: pre-wrap;">  </span>else<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>n * factorial(n - 1)</td>
</tr>
<tr>
<td><a name="invoke-func" id="invoke-func"></a><a href="#invoke-func-note">invoke function</a></td>
<td>add(3.7, 2.8)</td>
<td>add(3, 7)</td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> 3.0:</span><br />
average(1, 2 + 3)<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> 4.5:</span><br />
average(1, 2) + 3<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> parens can be omitted when a function<br />
<span style="white-space: pre-wrap;">//</span> takes no arguments; by convention parens<br />
<span style="white-space: pre-wrap;">//</span> are omitted when the function has no<br />
<span style="white-space: pre-wrap;">//</span> side effects</span></td>
</tr>
<tr>
<td>define function with block body</td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> braces must be used if body<br />
<span style="white-space: pre-wrap;">//</span> not an expression:</span><br />
def print_numbers() = {<br />
<span style="white-space: pre-wrap;">  </span>println("one")<br />
<span style="white-space: pre-wrap;">  </span>println("two")<br />
}</td>
</tr>
<tr>
<td><a name="nest-func" id="nest-func"></a><a href="#nest-func-note">nest function</a></td>
<td>fn add_one(x: f64) -&gt; f64 {<br />
<br />
<span style="white-space: pre-wrap;">  </span>fn add(x1: f64, y1: f64) -&gt; f64 {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>x1 + y1<br />
<span style="white-space: pre-wrap;">  </span>}<br />
<br />
<span style="white-space: pre-wrap;">  </span>add(x, 1.0)<br />
}</td>
<td>func add_one(n: Int) -&gt; Int {<br />
<span style="white-space: pre-wrap;">  </span>func add(a: Int, b: Int) -&gt; Int {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>return a + b<br />
<span style="white-space: pre-wrap;">  </span>}<br />
<span style="white-space: pre-wrap;">  </span>return add(1, n)<br />
}</td>
<td></td>
</tr>
<tr>
<td><a href="#named-parameter">named parameter</a></td>
<td></td>
<td>func my_log(#exp: Double, #base: Double) -&gt; Double {<br />
<span style="white-space: pre-wrap;">  </span>return log(exp) / log(base)<br />
}<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> expose different parameter names:</span><br />
func my_log(exp e: Double, base b: Double) -&gt; Double {<br />
<span style="white-space: pre-wrap;">  </span>return log(e) / log(b)<br />
}<br />
<br />
my_log(exp: 8, base: 2)</td>
<td>def subtract(m: Int, s: Int) = m - s<br />
<br />
subtract(s = 3, m = 7)</td>
</tr>
<tr>
<td><a href="#default-value">named parameter default value</a></td>
<td></td>
<td>func incr(n: Int, amount: Int = 1) -&gt; Int {<br />
<span style="white-space: pre-wrap;">  </span>return n + amount<br />
}<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> 4:</span><br />
incr(3)<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> 5:</span><br />
incr(3, amount: 2)</td>
<td>def logarithm(x: Double,<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>base: Double = math.exp(1)) =<br />
<span style="white-space: pre-wrap;">  </span>math.log(x) / math.log(base)<br />
<br />
logarithm(2.718)<br />
logarithm(10, base = 2)</td>
</tr>
<tr>
<td><a name="variable-num-arg" id="variable-num-arg"></a><a href="#variable-num-arg-note">variable number of arguments</a></td>
<td></td>
<td>func concat(strings: String<span style="white-space: pre-wrap;">...</span>) -&gt; String {<br />
<span style="white-space: pre-wrap;">  </span>var retval = ""<br />
<span style="white-space: pre-wrap;">  </span>for string in strings {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>retval += string<br />
<span style="white-space: pre-wrap;">  </span>}<br />
<span style="white-space: pre-wrap;">  </span>return retval<br />
}</td>
<td></td>
</tr>
<tr>
<td>overload function</td>
<td></td>
<td>func add(a: String, b: String) -&gt; String {<br />
<span style="white-space: pre-wrap;">  </span>return a + b<br />
}</td>
<td></td>
</tr>
<tr>
<td><a name="retval" id="retval"></a><a href="#retval-note">return value</a></td>
<td><span style="color: gray">return <em>arg; otherwise last expression evaluated and not followed by semicolon; otherwise unit ()</em></span></td>
<td><span style="color: gray">return <em>arg</em></span></td>
<td><span style="color: gray"><em>if function body is preceded by</em> = // the return value is the// return <em>arg or last expression evaluated.</em></span><br />
<br />
<span style="color: gray"><em>If function body not preceded by</em> = <em>the return value is</em> Unit.</span></td>
</tr>
<tr>
<td><a name="multiple-retval" id="multiple-retval"></a><a href="#multiple-retval-note">multiple return values</a></td>
<td></td>
<td>func divmod(dividend: Int, divisor: Int) -&gt; (Int, Int) {<br />
<span style="white-space: pre-wrap;">  </span>return (dividend / divisor, dividend % divisor)<br />
}</td>
<td></td>
</tr>
<tr>
<td><a href="#recursive-function">recursive function</a></td>
<td></td>
<td></td>
<td>def range(a:Int, b:Int): List[Int] =<br />
<span style="white-space: pre-wrap;">  </span>if (a &gt; b)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>List()<br />
<span style="white-space: pre-wrap;">  </span>else<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>a :: range(a + 1, b)</td>
</tr>
<tr>
<td><a href="#anonymous-func">anonymous function</a></td>
<td></td>
<td>let add_one = {(n: Int) -&gt; Int in n + 1}</td>
<td>(x: Double, y: Double) =&gt; (x + y) / 2.0</td>
</tr>
<tr>
<td><a name="invoke-anonymous-func" id="invoke-anonymous-func"></a><a href="#invoke-anonymous-func-note">invoke anonymous function</a></td>
<td></td>
<td>add_one(2)</td>
<td></td>
</tr>
<tr>
<td><a name="func-as-val" id="func-as-val"></a><a href="#func-as-val-note">function as value</a></td>
<td></td>
<td>func add(n: Int, m: Int) -&gt; Int {<br />
<span style="white-space: pre-wrap;">  </span>return n + m<br />
}<br />
<br />
let f = add</td>
<td></td>
</tr>
<tr>
<td><a href="#infix-prefix">infix operator in prefix position</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a href="#function-infix">function in infix position</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><em>unary methods can be used as binary operators</em></span></td>
</tr>
<tr>
<td><a href="#currying">currying</a></td>
<td></td>
<td></td>
<td>def plus(x: Int)(y: Int) = x + y<br />
plus(3)(7)<br />
def plus2 = plus(2)<br />
plus2(7)</td>
</tr>
<tr>
<td><a href="#lazy-evaluation">lazy evaluation</a></td>
<td></td>
<td></td>
<td>def arg1(x: =&gt; Int, y: =&gt; Int): Int = x<br />
<br />
arg1(7, 1 / 0)</td>
</tr>
<tr>
<th colspan="4"><a name="execution-control" id="execution-control"></a><a href="#execution-control-note">execution control</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="if" id="if"></a><a href="#if-note">if</a></td>
<td>let signum: i32;<br />
<br />
if i &gt; 0 {<br />
<span style="white-space: pre-wrap;">  </span>signum = 1<br />
} else if i == 0 {<br />
<span style="white-space: pre-wrap;">  </span>signum = 0<br />
} else {<br />
<span style="white-space: pre-wrap;">  </span>signum = -1<br />
}</td>
<td>var signum: Int<br />
<br />
if i &gt; 0 {<br />
<span style="white-space: pre-wrap;">  </span>signum = 1<br />
} else if i == 0 {<br />
<span style="white-space: pre-wrap;">  </span>signum = 0<br />
} else {<br />
<span style="white-space: pre-wrap;">  </span>signum = -1<br />
}</td>
<td>if (x &gt; 0)<br />
<span style="white-space: pre-wrap;">  </span>println("pos")<br />
else if (x &lt; 0)<br />
<span style="white-space: pre-wrap;">  </span>println("neg")<br />
else<br />
<span style="white-space: pre-wrap;">  </span>println("zero")</td>
</tr>
<tr>
<td><a name="while" id="while"></a><a href="#while-note">while</a></td>
<td>let mut i: i32 = 0;<br />
<br />
while i &lt; 10 {<br />
<span style="white-space: pre-wrap;">  </span>i += 1<br />
}</td>
<td>var i = 0<br />
<br />
while i &lt; 10 {<br />
<span style="white-space: pre-wrap;">  </span>i += 1<br />
}</td>
<td>var i = 0<br />
while (i&lt;10) {<br />
<span style="white-space: pre-wrap;">  </span>printf("%d\n", i)<br />
<span style="white-space: pre-wrap;">  </span>i = i+1<br />
}</td>
</tr>
<tr>
<td><a name="for" id="for"></a><a href="#for-note">for</a></td>
<td>let mut n: i32 = 1;<br />
<br />
for i in range(1i, 11i) {<br />
<span style="white-space: pre-wrap;">  </span>n *= i;<br />
}</td>
<td>var n = 1<br />
<br />
for var i = 1; i &lt;= 10; i++ {<br />
<span style="white-space: pre-wrap;">  </span>n *= i<br />
}</td>
<td>for (i &lt;- 1 to 10)<br />
<span style="white-space: pre-wrap;">  </span>println(i)</td>
</tr>
<tr>
<td><a name="infinite-loop" id="infinite-loop"></a><a href="#infinite-loop-note">infinite loop</a></td>
<td>loop {<br />
<br />
}</td>
<td></td>
<td>while (true) {<br />
<br />
}</td>
</tr>
<tr>
<td><a name="break-continue" id="break-continue"></a><a href="#break-continue-note">break and continue</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>break continue</td>
<td></td>
<td>import scala.util.control.Breaks.break<br />
<br />
for (i &lt;- 1 to 10)<br />
<span style="white-space: pre-wrap;">  </span>if (i &gt; 5)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>break<br />
<span style="white-space: pre-wrap;">  </span>else<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>println(i)<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> there is no continue statement</span></td>
</tr>
<tr>
<th colspan="4"><a name="exceptions" id="exceptions"></a><a href="#exceptions-note">exceptions</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a href="#raise-error">raise error</a></td>
<td>panic!("bam!");</td>
<td></td>
<td>throw new Exception("bam!")</td>
</tr>
<tr>
<td><a href="#handle-error">handle error</a></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> does not catch all panics:</span><br />
let result = std::panic::catch_unwind(<span style="white-space: pre-wrap;">||</span> {<br />
<span style="white-space: pre-wrap;">  </span>panic!("bam!");<br />
});<br />
<br />
if result.is_ok() {<br />
<span style="white-space: pre-wrap;">  </span>println!("no panic");<br />
}</td>
<td></td>
<td>import java.lang._<br />
<span style="white-space: pre-wrap;"> </span><br />
val x = try {<br />
<span style="white-space: pre-wrap;">  </span>1 / 0<br />
}<br />
catch {<br />
<span style="white-space: pre-wrap;">  </span>case e: ArithmeticException =&gt; 0<br />
}</td>
</tr>
<tr>
<td><a href="#standard-exceptions">standard exceptions</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><em>defined in</em> java.lang:</span><br />
<br />
Throwable<br />
<span style="white-space: pre-wrap;">  </span>Error<br />
<span style="white-space: pre-wrap;">  </span>Exception<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>IOException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>EOFException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>FileNotFoundException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>MalformedURLException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>UnknownHostException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>ClassNotFoundException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>CloneNotSupportedException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>RuntimeException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>ArithmeticException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>ClassCastException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>IllegalArgumentException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>IllegalStateException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>IndexOutOfBoundsException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>NoSuchElementException<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>NullPointerException<br />
<br />
<span style="color: gray">Error, RuntimeException, <em>and subclasses theoreof are normally unrecoverable</em></span></td>
</tr>
<tr>
<td><a href="#assert">assert</a></td>
<td>assert!(1 == 0);</td>
<td></td>
<td>assert(1 == 0)</td>
</tr>
<tr>
<th colspan="4"><a name="concurrency" id="concurrency"></a><a href="#concurrency-note">concurrency</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<th colspan="4"><a name="file-handles" id="file-handles"></a><a href="#file-handles-note">file handles</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td>standard file handles</td>
<td>use std::io;<br />
<br />
io::stdin<br />
io::stdout<br />
io::stderr</td>
<td>let stdin =<br />
<span style="white-space: pre-wrap;">  </span>NSFileHandle.fileHandleWithStandardInput()<br />
let stdout =<br />
<span style="white-space: pre-wrap;">  </span>NSFileHandle.fileHandleWithStandardOutput()<br />
let stderr<br />
<span style="white-space: pre-wrap;">  </span>NSFileHandle.fileHandleWithStandardError()</td>
<td>System.in<br />
System.out<br />
System.err</td>
</tr>
<tr>
<td>read line from stdin</td>
<td>use std::io;<br />
<br />
let s = io::stdin().read_line().ok().expect("Failed to read line");</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>import scala.io.StdIn.readLine<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> newline is removed:</span><br />
val s = readLine()</td>
</tr>
<tr>
<td><a href="#write-line-stdout">write line to stdout</a></td>
<td>println!("Hello, World!");<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> argument of println! must be a literal.<br />
<span style="white-space: pre-wrap;">//</span> To print a variable:</span><br />
let s = "Hello, World!";<br />
println!("{}", s);</td>
<td>print("Hello, World!")</td>
<td>println("lorem ipsum")</td>
</tr>
<tr>
<td>write formatted string to stdout</td>
<td></td>
<td>let s = "Spain"<br />
let i = 17<br />
let x = 3.1415<br />
let fmtx = NSString(format: "%.2f", x)<br />
<br />
print("\(s) \(i) \(fmtx)")</td>
<td>printf("%s %d %.2f", "Spain", 17, 3.1415)</td>
</tr>
<tr>
<td>open file for reading</td>
<td></td>
<td>import scala.io.Source<br />
<br />
val path = "/etc/hosts"<br />
val f = Source.fromFile(path)</td>
<td>import scala.io.Source<br />
<br />
val path = "/etc/hosts"<br />
val f = Source.fromFile(path)</td>
</tr>
<tr>
<td>open file for writing</td>
<td></td>
<td>let path = "/tmp/test"<br />
NSFileManager().copyItemAtPath(<br />
<span style="white-space: pre-wrap;">  </span>"/dev/null",<br />
<span style="white-space: pre-wrap;">  </span>toPath: path,<br />
<span style="white-space: pre-wrap;">  </span>error: nil)<br />
let f = NSFileHandle(<br />
<span style="white-space: pre-wrap;">  </span>forWritingAtPath: path)</td>
<td></td>
</tr>
<tr>
<td>open file for appending</td>
<td></td>
<td>let f = NSFileHandle(<br />
<span style="white-space: pre-wrap;">  </span>forWritingAtPath: "/tmp/err.log")<br />
f.seekToEndOfFile()</td>
<td></td>
</tr>
<tr>
<td>close file</td>
<td></td>
<td>f.closeFile()</td>
<td>import scala.io.Source<br />
<br />
f.close</td>
</tr>
<tr>
<td><a name="close-file-implicitly" id="close-file-implicitly"></a><a href="#close-file-implicitly-note">close file implicitly</a></td>
<td></td>
<td>class Defer {<br />
<span style="white-space: pre-wrap;">  </span>var fun: ()-&gt;()<br />
<span style="white-space: pre-wrap;">  </span>init(fun: ()-&gt;()) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>self.fun = fun<br />
<span style="white-space: pre-wrap;">  </span>}<br />
<span style="white-space: pre-wrap;">  </span>deinit {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>fun()<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}<br />
var defer = Defer({()-&gt;() in f.closeFile()})</td>
<td></td>
</tr>
<tr>
<td><a href="#read-line">read line</a></td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
<td>import scala.io.Source<br />
val src = Source.fromFile("/etc/passwd")<br />
for (line &lt;- src.getLines)<br />
<span style="white-space: pre-wrap;">  </span>print(line)</td>
</tr>
<tr>
<td>iterate over file by line</td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
<td></td>
</tr>
<tr>
<td>read file into array of strings</td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
<td></td>
</tr>
<tr>
<td>read file into string</td>
<td></td>
<td>let data = f.readDataToEndOfFile()<br />
let s = NSString(<br />
<span style="white-space: pre-wrap;">  </span>data: data,<br />
<span style="white-space: pre-wrap;">  </span>encoding: NSUTF8StringEncoding)</td>
<td></td>
</tr>
<tr>
<td>write string</td>
<td></td>
<td>f.writeData("Hello, World!".dataUsingEncoding(<br />
<span style="white-space: pre-wrap;">  </span>NSUTF8StringEncoding))</td>
<td></td>
</tr>
<tr>
<td><a href="#write-file">write line</a></td>
<td></td>
<td>f.writeData("Hello, World!\n".dataUsingEncoding(<br />
<span style="white-space: pre-wrap;">  </span>NSUTF8StringEncoding))</td>
<td>val out = new java.io.FileWriter("/tmp/test-scala")<br />
out.write("hello out\n")<br />
out.close</td>
</tr>
<tr>
<td>flush file handle</td>
<td></td>
<td>f.synchronizeFile()</td>
<td></td>
</tr>
<tr>
<td>get and set filehandle position</td>
<td></td>
<td>let pos = f.offsetInFile<br />
f.seekToFileOffset(0)</td>
<td></td>
</tr>
<tr>
<th colspan="4"><a name="files" id="files"></a><a href="#files-note">files</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td>file test, regular file test</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val f = new File("/etc/hosts")<br />
f.exists<br />
f.isFile</td>
</tr>
<tr>
<td>file size</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val f = new File("/etc/hosts")<br />
f.length</td>
</tr>
<tr>
<td>is file readable, writable, executable</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val f = new File("/etc/hosts")<br />
f.canRead<br />
f.canWrite<br />
f.canExecute</td>
</tr>
<tr>
<td>set file permissions</td>
<td></td>
<td></td>
<td>mport java.io.File<br />
<br />
val f = new File("/tmp/foo")<br />
<br />
<span style="color: gray">// sets owner perms; to turn perms off<br />
// set arg to false:</span><br />
f.setReadable(true)<br />
f.setWritable(true)<br />
f.setExecutable(true)<br />
<br />
<span style="color: gray">// if 2nd arg is false, perms are<br />
// for owner, group, and other:</span><br />
f.setReadable(true, false)<br />
f.setWritable(true, false)<br />
f.setExecutable(true, false)</td>
</tr>
<tr>
<td>copy file, remove file, rename file</td>
<td></td>
<td></td>
<td>import java.nio.file.Files<br />
import java.nio.file.Paths<br />
<br />
val path = Paths.get("/tmp/foo")<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> possible java.nio.file.FileAlreadyExistsException:</span><br />
Files.copy(path, Paths.get("/tmp/bar"))<br />
<br />
Files.deleteIfExists(path)<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> possible java.nio.file.NoSuchFileException:</span><br />
Files.delete(path)<br />
<br />
Files.move(Paths.get("/tmp/bar", path)</td>
</tr>
<tr>
<td>create symlink, symlink test, readlink</td>
<td></td>
<td></td>
<td>import java.nio.file.Files<br />
import java.nio.file.Paths<br />
<br />
val target = Paths.get("/etc/hosts")<br />
val path = Paths.get("/tmp/hosts")<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Possible java.nio.file.FileAlreadyExistsException:</span><br />
Files.createSymbolicLink(path, target)<br />
Files.isSymbolicLink(path)<br />
Files.readSymbolicLink(path)</td>
</tr>
<tr>
<td>generate unused file name</td>
<td></td>
<td></td>
<td>import java.nio.file.Files<br />
<br />
val path = Files.createTempFile("foo", ".txt")</td>
</tr>
<tr>
<th colspan="4"><a name="directories" id="directories"></a><a href="#directories-note">directories</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td>build pathname</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val root = File.listRoots()(0)<br />
val hosts = new File(new File(root, "etc"), "hosts")<br />
val path = hosts.getPath</td>
</tr>
<tr>
<td>dirname and basename</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val f = new File("/etc/hosts")<br />
val dirn = f.getParent<br />
val basen = f.getName</td>
</tr>
<tr>
<td>iterate over directory by file</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val dir = new File("/etc")<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Array[String]:</span><br />
dir.list<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Array[java.io.File]:</span><br />
dir.listFiles</td>
</tr>
<tr>
<td>make directory</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val dir = new File("/tmp/foo/dir")<br />
dir.mkdirs</td>
</tr>
<tr>
<td>remove empty directory</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val dir = new File("/tmp/foodir")<br />
dir.delete</td>
</tr>
<tr>
<td>remove directory and contents</td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> libraryDependencies += "commons-io" % "commons-io" % "2.4"</span><br />
import org.apache.commons.io.FileUtils<br />
import java.io.File<br />
<br />
FileUtils.deleteDirectory(new File("/tmp/foo"))</td>
</tr>
<tr>
<td>directory test</td>
<td></td>
<td></td>
<td>import java.io.File<br />
<br />
val f = new File("/etc")<br />
f.isDirectory</td>
</tr>
<tr>
<td>temporary directory</td>
<td></td>
<td></td>
<td>import java.nio.file.Files<br />
<br />
val dir = Files.createTempDirectory(null)<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> path as string:</span><br />
dir.toString<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> arrange for directory to be deleted:</span><br />
dir.toFile.deleteOnExit</td>
</tr>
<tr>
<th colspan="4"><a name="processes-environment" id="processes-environment"></a><a href="#processes-environment-note">processes and environment</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a href="#command-line-arg">command line arguments</a></td>
<td></td>
<td></td>
<td>object Test {<br />
<span style="white-space: pre-wrap;">  </span>def main(args: Array[String]) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>for (arg &lt;- args)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>println(arg)<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}</td>
</tr>
<tr>
<td><a name="program-name" id="program-name"></a><a href="#program-name-note">program name</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td><span style="color: gray"><em>A scala program is run as</em><br />
<br />
<span style="white-space: pre-wrap;">  </span>scala CLASS [ARG …]<br />
<br />
<em>The VM then searches</em> CLASSPATH <em>for</em> CLASS. CLASS <em>is the nearest analog to the program name and can be determined statically.</em></span></td>
</tr>
<tr>
<td><a name="getopt" id="getopt"></a><a href="#getopt-note">getopt</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> built.sbt:<br />
<span style="white-space: pre-wrap;">//</span><br />
<span style="white-space: pre-wrap;">//</span><span style="white-space: pre-wrap;">   </span>libraryDependencies += "com.github.scopt" %% "scopt" % "3.3.0"</span><br />
<br />
case class Config(<br />
<span style="white-space: pre-wrap;">  </span>foo: Int = 0,<br />
<span style="white-space: pre-wrap;">  </span>bar: String = ""<br />
)<br />
<br />
val parser = new scopt.OptionParser[Config]("scopt") {<br />
<span style="white-space: pre-wrap;">  </span>opt[Int]('f', "foo") action { (x, c) =&gt;<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>c.copy(foo = x) } text("foo is integer")<br />
<span style="white-space: pre-wrap;">  </span>opt[String]('b', "bar") action{ (x, c) =&gt;<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>c.copy(bar = x) } text("bar is string")<br />
}<br />
<br />
parser.parse(args, Config()) match {<br />
<span style="white-space: pre-wrap;">  </span>case Some(config) =&gt;<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>println(config.foo)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>println(config.bar)<br />
<span style="white-space: pre-wrap;">  </span>case None =&gt;<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> bad args; usage was displayed</span><br />
}</td>
</tr>
<tr>
<td><a name="env-var" id="env-var"></a><a href="#env-var-note">get and set environment variable</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> java.util.NoSuchElementException if not defined:</span><br />
sys.env("HOME")<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> returns Option[String]:</span><br />
sys.env.get("HOME")<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Environment variables are read only, but new values can be<br />
<span style="white-space: pre-wrap;">//</span> set when creating child processes.</span></td>
</tr>
<tr>
<td><a name="pid" id="pid"></a><a href="#pid-note">get pid, parent pid</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> no portable technique</span></td>
</tr>
<tr>
<td><a name="user-id-name" id="user-id-name"></a><a href="#user-id-name-note">get user id and name</a></td>
<td></td>
<td></td>
<td>System.getProperty("user.name")<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> no property for uid</span></td>
</tr>
<tr>
<td><a name="exit" id="exit"></a><a href="#exit-note">exit</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>System.exit(1)</td>
</tr>
<tr>
<td><a name="signal-handler" id="signal-handler"></a><a href="#signal-handler-note">set signal handler</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>import sun.misc._<br />
<br />
Signal.handle(new Signal("INT"), new SignalHandler() {<br />
<span style="white-space: pre-wrap;">  </span>val start = System.nanoTime()<br />
<span style="white-space: pre-wrap;">  </span>def handle(sig: Signal) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>val end = System.nanoTime()<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>println(s"\n${(end - start) / 1e9f} seconds")<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>System.exit(0)<br />
<span style="white-space: pre-wrap;">  </span>}<br />
})</td>
</tr>
<tr>
<td><a name="external-cmd" id="external-cmd"></a><a href="#external-cmd-note">external command</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>import scala.sys.process._<br />
<br />
val exitCode = "ls /tmp".!</td>
</tr>
<tr>
<td><a name="escaped-external-cmd" id="escaped-external-cmd"></a><a href="#escaped-external-cmd-note">escaped external command</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>import scala.sys.process._<br />
import java.io.File<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> if args contain spaces, use List():</span><br />
val exitCode = List("touch", "/tmp/some file").!<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> there are operators for shell <span style="white-space: pre-wrap;">&amp;&amp;, ||, and |</span>:</span><br />
(( "ls /tmp" #<span style="white-space: pre-wrap;">&amp;&amp;</span> "ls /etc") #| "grep ssh").!<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> redirection example:</span><br />
("ls" #&gt; new File("/tmp/ls.out")).!</td>
</tr>
<tr>
<td><a name="backticks" id="backticks"></a><a href="#backticks-note">backticks</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>import scala.sys.process._<br />
<br />
val s = "ls".<span style="white-space: pre-wrap;">!!</span></td>
</tr>
<tr>
<th colspan="4"><a name="libraries-namespaces" id="libraries-namespaces"></a><a href="#libraries-namespaces-note">libraries and namespaces</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td>define namespace</td>
<td></td>
<td></td>
<td>package foo {<br />
<span style="white-space: pre-wrap;">  </span>class A<br />
<span style="white-space: pre-wrap;">  </span>class B<br />
}<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Alternate syntax; must be first statement in file;<br />
<span style="white-space: pre-wrap;">//</span> declares entire file to be in namespace</span><br />
package foo</td>
</tr>
<tr>
<td>define child namespace</td>
<td></td>
<td></td>
<td>package foo.bar {<br />
<span style="white-space: pre-wrap;">  </span>class A<br />
}<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Alternate nested syntax:</span><br />
package foo {<br />
<span style="white-space: pre-wrap;">  </span>package bar {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>class A<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Alternate syntax; must be first statement in file:</span><br />
package foo.bar</td>
</tr>
<tr>
<td>reference identifier in another file</td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> no import needed if identifier is fully qualified:</span><br />
val a = new foo.bar.A</td>
</tr>
<tr>
<td>import definitions</td>
<td></td>
<td></td>
<td>import foo.A<br />
<br />
val a = new A<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> imports A and B:</span><br />
import foo.{A, B}<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> Import statements can appear after or inside class definitions,<br />
<span style="white-space: pre-wrap;">//</span> or inside methods.</span></td>
</tr>
<tr>
<td>import all definitions in namespace</td>
<td></td>
<td></td>
<td>import foo._<br />
<br />
val a = new A<br />
val b = new B</td>
</tr>
<tr>
<td>import namespace</td>
<td></td>
<td></td>
<td>import foo.bar<br />
<br />
val a = new bar.A<br />
val b = new bar.B</td>
</tr>
<tr>
<td>shadow avoidance</td>
<td></td>
<td></td>
<td>import foo.bar.{A =&gt; LetterA}<br />
<br />
val a = new LetterA</td>
</tr>
<tr>
<td>library path environment variable</td>
<td></td>
<td></td>
<td>$ cat src/foo/bar/A.scala<br />
package foo.bar<br />
<br />
object A {<br />
<span style="white-space: pre-wrap;">  </span>def main(args: Array[String]) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>println("Hello, World!")<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}<br />
<br />
$ scalac src/foo/bar/A.scala<br />
<br />
$ dir=$(pwd)<br />
<br />
$ cd /<br />
<br />
$ CLASSPATH=$dir scala foo.bar.A<br />
<br />
<span style="color: gray"><em>The default CLASSPATH is the current directory. Directories are separated by colons : on Unix and semicolons ; on Windows. Jar files can also be put in the CLASSPATH.</em></span></td>
</tr>
<tr>
<td>create package</td>
<td></td>
<td></td>
<td>$ cat src/foo/bar/A.scala<br />
package foo.bar<br />
<br />
object A {<br />
<span style="white-space: pre-wrap;">  </span>def main(args: Array[String]) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>println("Hello, World!")<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}<br />
<br />
$ mkdir target<br />
<br />
$ scalac -d target src/foo/bar/A.scala<br />
<br />
$ find target -name '*.class' | xargs jar cf App.jar<br />
<br />
$ CLASSPATH=App.jar scala foo.bar.A</td>
</tr>
<tr>
<td>inspect package</td>
<td></td>
<td></td>
<td>$ jar tf App.jar</td>
</tr>
<tr>
<td>install package</td>
<td>$ cat Cargo.toml<br />
[package]<br />
name = "main"<br />
version = "0.1.0"<br />
authors = ["Bob <span style="white-space: pre-wrap;">&lt;bob@foo.com&gt;</span>"]<br />
[dependencies]<br />
chrono = "0.2.25"<br />
<br />
$ cat src/main.rs<br />
extern crate chrono;<br />
fn main() {<br />
<span style="white-space: pre-wrap;">  </span>let t = chrono::UTC::now();<br />
<span style="white-space: pre-wrap;">  </span>println!("t: {}", t.format("%Y-%m-%d"));<br />
}<br />
<br />
$ cargo build</td>
<td></td>
<td>$ cat build.sbt<br />
libraryDependencies += "commons-io" % "commons-io" % "2.4"<br />
<br />
$ sbt package</td>
</tr>
<tr>
<td>list installed packages</td>
<td></td>
<td></td>
<td>$ find ~/.ivy2/cache -name '*.jar'</td>
</tr>
<tr>
<th colspan="4"><a name="user-defined-types" id="user-defined-types"></a><a href="#user-defined-types-note">user-defined types</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a name="type-synonym" id="type-synonym"></a></td>
<td></td>
<td>typealias CustomerId = Int<br />
var customer_id: CustomerId = 3</td>
<td>type Name = String</td>
</tr>
<tr>
<td><a name="sum-type" id="sum-type"></a><a href="#sum-type-note">sum type</a></td>
<td>enum DayOfWeek {<br />
<span style="white-space: pre-wrap;">  </span>Mon, Tue, Wed, Thu, Fri, Sat, Sun<br />
}<br />
<br />
let dow: DayOfWeek = Mon;</td>
<td>enum DayOfWeek {<br />
<span style="white-space: pre-wrap;">  </span>case Mon, Tue, Wed, Thu, Fri, Sat, Sun<br />
}<br />
let dow = DayOfWeek.Tue</td>
<td>abstract class Color<br />
<br />
case object Red extends Color<br />
case object Blue extends Color<br />
case object Green extends Color<br />
<br />
val col = Red<br />
<br />
<span style="color: gray"><span style="white-space: pre-wrap;">//</span> this won't compile:</span><br />
col &lt; Green</td>
</tr>
<tr>
<td>tuple product type with one field</td>
<td></td>
<td></td>
<td>class SpecialInt(x: Int)<br />
<br />
val n = new SpecialInt(7)</td>
</tr>
<tr>
<td>tuple product type with two fields</td>
<td></td>
<td></td>
<td>class IntPair(a: Int, b: Int)<br />
<br />
val p = new IntPair(7, 11)</td>
</tr>
<tr>
<td>record product type</td>
<td></td>
<td>struct MedalCount {<br />
<span style="white-space: pre-wrap;">  </span>var country: String<br />
<span style="white-space: pre-wrap;">  </span>var gold: Int,<br />
<span style="white-space: pre-wrap;">  </span>silver: Int,<br />
<span style="white-space: pre-wrap;">  </span>bronze: Int<br />
}</td>
<td>case class Customer(<br />
<span style="white-space: pre-wrap;">  </span>id: Int,<br />
<span style="white-space: pre-wrap;">  </span>name: String,<br />
<span style="white-space: pre-wrap;">  </span>address: String<br />
)</td>
</tr>
<tr>
<td>record product type literal</td>
<td></td>
<td>var spain = MedalCount(<br />
<span style="white-space: pre-wrap;">  </span>country: "Spain",<br />
<span style="white-space: pre-wrap;">  </span>gold: 3,<br />
<span style="white-space: pre-wrap;">  </span>silver: 2,<br />
<span style="white-space: pre-wrap;">  </span>bronze: 1<br />
)</td>
<td>Customer(7,"John","Topeka, KS")<br />
<br />
Customer(id=7, name="John", address="Topeka, KS")</td>
</tr>
<tr>
<td><a href="#struct-member-access">product type member access</a></td>
<td></td>
<td>let france_total = france.gold + france.silver + france.bronze</td>
<td></td>
</tr>
<tr>
<td><a href="#struct-member-assignment">product type member assignment</a></td>
<td></td>
<td>var france: MedalCount<br />
france.country = "France"<br />
france.gold = 7<br />
france.silver = 6<br />
france.bronze = 5</td>
<td></td>
</tr>
<tr>
<td><a name="generic-type" id="generic-type"></a><a href="#generic-type-note">generic type</a></td>
<td></td>
<td></td>
<td>class Twosome[A, B](a: A, b: B)<br />
<br />
val p = new Twosome("pi", 3.14)</td>
</tr>
<tr>
<td><a href="#recursive-type">recursive type</a></td>
<td></td>
<td></td>
<td>abstract class BinaryTree<br />
case class Tree(left: BinaryTree, right: BinaryTree) extends BinaryTree<br />
case class Leaf(x: Int) extends BinaryTree</td>
</tr>
<tr>
<td>pattern match sum type</td>
<td>let msg = match col {<br />
<span style="white-space: pre-wrap;">  </span>Red =&gt; "red",<br />
<span style="white-space: pre-wrap;">  </span>Blue =&gt; "blue",<br />
<span style="white-space: pre-wrap;">  </span>Green =&gt; "green",<br />
};</td>
<td></td>
<td>val c:Color = Red;<br />
c match { case Red =&gt; "red"; case Green =&gt; "green"; case Blue =&gt; "blue" }</td>
</tr>
<tr>
<td>pattern match product type</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#match-guard">pattern match guard</a></td>
<td></td>
<td></td>
<td>match { case i: Int if i &lt; 0 =&gt; - i; case i: Int =&gt; i }</td>
</tr>
<tr>
<td><a href="#match-catchall">pattern match catchall</a></td>
<td>let msg = match col {<br />
<span style="white-space: pre-wrap;">  </span>Red =&gt; "red",<br />
<span style="white-space: pre-wrap;">  </span>_ =&gt; "not red",<br />
};</td>
<td></td>
<td>val c : Color = Green<br />
c match { case Red =&gt; "red"; case _ =&gt; "not red" }</td>
</tr>
<tr>
<th colspan="4"><a name="objects" id="objects"></a><a href="#objects-note">objects</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td>define class</td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Constructor takes optional param of type Int.<br />
<span style="white-space: pre-wrap;">//</span><br />
<span style="white-space: pre-wrap;">//</span> Precede param name by val or var<br />
<span style="white-space: pre-wrap;">//</span> to implicitly define an instance variable</span><br />
class Counter(n: Int = 0) {<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Executes when object is created.<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">//</span><br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">//</span> java.lang.IllegalArgumentException if false.</span><br />
<span style="white-space: pre-wrap;">  </span>require(n &gt;= 0)<br />
<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Instance variables public by default</span><br />
<span style="white-space: pre-wrap;">  </span>private var _n = n<br />
<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Getter:</span><br />
<span style="white-space: pre-wrap;">  </span>def value = _n<br />
<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Setter:</span><br />
<span style="white-space: pre-wrap;">  </span>def value_=(n: Int) { _n = n }<br />
<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Object-mutating method:</span><br />
<span style="white-space: pre-wrap;">  </span>def incr { _n += 1 }<br />
}</td>
</tr>
<tr>
<td>create object</td>
<td></td>
<td></td>
<td>val c = new Counter<br />
val c2 = new Counter(1)</td>
</tr>
<tr>
<td>invoke method</td>
<td></td>
<td></td>
<td>c.incr()<br />
c.value = c.value + 1</td>
</tr>
<tr>
<td>define class variable and method</td>
<td></td>
<td></td>
<td><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Define singleton object outside of class body:</span><br />
object Counter {<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Class variables can be declared private; Counter constructor<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">//</span> and instance methods stil have access:</span><br />
<span style="white-space: pre-wrap;">  </span>var instances = 0<br />
<br />
<span style="white-space: pre-wrap;">  </span>def incrInstances { instances += 1 }<br />
}</td>
</tr>
<tr>
<td>invoke class method</td>
<td></td>
<td></td>
<td>Counter.incrInstances</td>
</tr>
<tr>
<th colspan="4"><a name="inheritance-polymorphism" id="inheritance-polymorphism"></a><a href="#inheritance-polymorphism-note">inheritance and polymorphism</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td>subclass</td>
<td></td>
<td></td>
<td>class Base {<br />
<span style="white-space: pre-wrap;">  </span>println("instantiating Base")<br />
<span style="white-space: pre-wrap;">  </span><br />
<span style="white-space: pre-wrap;">  </span>def name = { "Base" }<br />
}<br />
<br />
class Derived extends Base {<br />
<span style="white-space: pre-wrap;">  </span>println("instantiating Derived after Base")<br />
<span style="white-space: pre-wrap;">  </span><br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> Compilation error if override omitted or<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">//</span> if method with same name not defined in base class.</span><br />
<span style="white-space: pre-wrap;">  </span>override def name = { "Derived" }<br />
}</td>
</tr>
<tr>
<td>abstract base class</td>
<td></td>
<td></td>
<td>abstract class Base {<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray"><span style="white-space: pre-wrap;">//</span> compilation error if derived class does not define name:</span><br />
<span style="white-space: pre-wrap;">  </span>def name: String<br />
}</td>
</tr>
<tr>
<td>mixin</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="4"><a name="unit-tests" id="unit-tests"></a><a href="#unit-tests-note">unit test</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td>test class</td>
<td></td>
<td></td>
<td>import org.scalatest.FunSuite<br />
<br />
class FooSuite extends FunSuite {<br />
<span style="white-space: pre-wrap;">  </span>test("a simple test") {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>assert(0 == 0, "zero not equal to itself")<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}</td>
</tr>
<tr>
<td>run all tests, run test suite</td>
<td></td>
<td></td>
<td>$ cat build.sbt<br />
libraryDependencies +=<br />
<span style="white-space: pre-wrap;">  </span>"org.scalatest" %% "scalatest" % "3.0.0-SNAP13"<br />
<br />
$ sbt test<br />
<br />
$ sbt<br />
<span style="white-space: pre-wrap;">&gt;</span> testOnly FooSuite</td>
</tr>
<tr>
<td>exception assertion</td>
<td></td>
<td></td>
<td>intercept[IndexOutOfBoundsException] {<br />
<span style="white-space: pre-wrap;">  </span>"val a = List(1, 2, 3)<br />
<span style="white-space: pre-wrap;">  </span>"val n = a(4)<br />
}</td>
</tr>
<tr>
<td>setup</td>
<td></td>
<td></td>
<td>import org.scalatest.FunSuite<br />
import org.scalatest.BeforeAndAfter<br />
<br />
class FooSuite extends FunSuite with BeforeAndAfter {<br />
<span style="white-space: pre-wrap;">  </span>before {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>print("before called\n")<br />
<span style="white-space: pre-wrap;">  </span>}<br />
<br />
<span style="white-space: pre-wrap;">  </span>test("zero equals self") {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>assert(0 == 0)<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}</td>
</tr>
<tr>
<td>teardown</td>
<td></td>
<td></td>
<td>import org.scalatest.FunSuite<br />
import org.scalatest.BeforeAndAfter<br />
<br />
class FooSuite extends FunSuite with BeforeAndAfter {<br />
<span style="white-space: pre-wrap;">  </span>test("zero equals self") {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>assert(0 == 0)<br />
<span style="white-space: pre-wrap;">  </span>}<br />
<br />
<span style="white-space: pre-wrap;">  </span>after {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>print("after called\n");<br />
<span style="white-space: pre-wrap;">  </span>}<br />
}</td>
</tr>
<tr>
<th colspan="4"><a name="debugging-profiling" id="debugging-profiling"></a><a href="#debugging-profiling-note">debugging and profiling</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td>lint</td>
<td></td>
<td></td>
<td>$ brew install scalastyle<br />
$ scalastyle Hello.scala</td>
</tr>
<tr>
<td>run debugger</td>
<td></td>
<td></td>
<td><span style="color: gray"><em>Scala IDE for Eclipse has a debugger</em></span></td>
</tr>
<tr>
<td>profile code</td>
<td></td>
<td></td>
<td><span style="color: gray"><em>Runs app under a sampling profiler. Profiling info is written to stdout. HotSpot VM only.</em></span><br />
$ JAVA_OPTS=-Xprof scala SomeApp</td>
</tr>
<tr>
<td>memory tool</td>
<td></td>
<td></td>
<td>$ JAVA_OPTS=-XX:+PrintGCDetails scala SomeApp</td>
</tr>
<tr>
<th colspan="4"><a name="repl" id="repl"></a><a href="#repl-note">repl</a></th>
</tr>
<tr>
<th></th>
<th>rust</th>
<th>swift</th>
<th>scala</th>
</tr>
<tr>
<td><a href="#invoke-repl">invoke repl</a></td>
<td></td>
<td>$ swift</td>
<td>$ scala</td>
</tr>
<tr>
<td><a href="#repl-previous-values">previous values</a></td>
<td></td>
<td>$R0, $R1, …</td>
<td>res0, res1, …</td>
</tr>
<tr>
<td><a href="#help">help</a></td>
<td></td>
<td>:help</td>
<td>:help</td>
</tr>
<tr>
<td><a href="#quit">quit</a></td>
<td></td>
<td>:quit</td>
<td>:quit</td>
</tr>
<tr>
<td><a href="#inspect-type">inspect type</a></td>
<td></td>
<td></td>
<td><span style="color: gray"><em>repl displays the type of any expression entered</em></span></td>
</tr>
<tr>
<th></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">________________________________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">_________________________________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">_________________________________________________________________</span></span></th>
</tr>
</table>
<p><a name="version-used-note" id="version-used-note"></a></p>
<h2 id="toc0"><span><a href="#version-used">version used</a></span></h2>
<p>The version used for examples in this sheet.</p>
<p><a name="version-note" id="version-note"></a></p>
<h2 id="toc1"><span><a href="#version">show version</a></span></h2>
<p>How to get the installed version.</p>
<p><a name="implicit-prologue-note" id="implicit-prologue-note"></a></p>
<h2 id="toc2"><span><a href="#implicit-prologue">implicit prologue</a></span></h2>
<p>Boilerplate which is assumed to be present by examples in this sheet.</p>
<p><a name="grammar-invocation-note" id="grammar-invocation-note"></a></p>
<h1 id="toc3"><span><a href="#grammar-invocation">Grammar and Invocation</a></span></h1>
<p><a name="interpreter-note" id="interpreter-note"></a></p>
<h2 id="toc4"><span><a href="#interpreter">interpreter</a></span></h2>
<p>How to run the interpreter on a file of source code.</p>
<p><strong>scala:</strong></p>
<p>Scala can be run "Perl style" like this:</p>
<div class="code">
<pre>
<code>scala foo.scala</code>
</pre></div>
<p>or "Java style" like this:</p>
<div class="code">
<pre>
<code>scala Foo</code>
</pre></div>
<p>When the code is run "Java style", the code to be executed must be in the <em>main</em> method of an object with the same name as the file. When the code is run "Perl style" the statements o be executed should be at the top level outside of any object, class, or method.</p>
<p>To use scala as a shebang, it is necessary to terminate the shell script portion of the script with !#</p>
<div class="code">
<pre>
<code>#!/bin/sh
exec scala $0 $@
!#
println("hello world")</code>
</pre></div>
<p><a name="compiler-note" id="compiler-note"></a></p>
<h2 id="toc5"><span><a href="#compiler">compiler</a></span></h2>
<p>How to run the compiler.</p>
<p><a name="statement-terminator-note" id="statement-terminator-note"></a></p>
<h2 id="toc6"><span><a href="#statement-terminator">statement terminator</a></span></h2>
<p><strong>scala:</strong></p>
<p>Scala infers the existence of a semicolon at the end of a newline terminated line if none of the following conditions hold:</p>
<ul>
<li>the line ends with a infix operator, including a period</li>
<li>the following line begins with a word that is not legal at the start of a statement</li>
<li>the line ends inside parens or square brackets, neither of which can contain multiple statements</li>
</ul>
<p><a name="blocks-note" id="blocks-note"></a></p>
<h2 id="toc7"><span><a href="#blocks">block delimiters</a></span></h2>
<p>How blocks of statements are delimited.</p>
<p><a name="end-of-line-comment-note" id="end-of-line-comment-note"></a></p>
<h2 id="toc8"><span><a href="#end-of-line-comment">end-of-line comment</a></span></h2>
<p>The syntax for a comment which goes to the end of the line.</p>
<p><a name="multiple-line-comment-note" id="multiple-line-comment-note"></a></p>
<h2 id="toc9"><span><a href="#multiple-line-comment">multiple line comment</a></span></h2>
<p>The syntax for a comment which beginning and ending delimiters which can span multiple lines.</p>
<p><a name="var-expr-note" id="var-expr-note"></a></p>
<h1 id="toc10"><span><a href="#var-expr">Variables and Expressions</a></span></h1>
<p><a name="let-in-note" id="let-in-note"></a></p>
<h2 id="toc11"><span><a href="#let-in">let ... in ...</a></span></h2>
<p>How to define local variables.</p>
<p><strong>scala:</strong></p>
<p>Blocks can be used in Scala exclusively to define scope. Furthermore blocks are expressions and evaluate to their last statement.</p>
<p><a name="arithmetic-logic-note" id="arithmetic-logic-note"></a></p>
<h1 id="toc12"><span><a href="#arithmetic-logic">Arithmetic and Logic</a></span></h1>
<p><a name="int-type-note" id="int-type-note"></a></p>
<h2 id="toc13"><span><a href="#int-type">integer types</a></span></h2>
<p>The most commonly used numeric types.</p>
<p><strong>scala:</strong></p>
<p>Arithmetic operators can be used on values of type <em>Char</em>, which then behaves as a 16 bit unsigned integer. Integer literals are of type <em>Int</em> unless suffixed with <em>L</em>:</p>
<div class="code">
<pre>
<code>scala&gt; 9223372036854775807L
res24: Long = 9223372036854775807

scala&gt; 9223372036854775807 
&lt;console&gt;:1: error: integer number too large</code>
</pre></div>
<p><a name="int-overflow-note" id="int-overflow-note"></a></p>
<h2 id="toc14"><span><a href="#int-overflow">integer overflow</a></span></h2>
<p>What happens when expression evaluates to an integer that is larger than what can be stored.</p>
<p><strong>scala:</strong></p>
<p>The largest integers are available in the constants <em>Int.MaxValue</em> and <em>Long.MaxValue</em>.</p>
<p><a name="random-num-note" id="random-num-note"></a></p>
<h2 id="toc15"><span><a href="#random-num">random number</a></span></h2>
<p>How to generate a uniformly distributed random integer; how to generate a uniformly distributed float; how to generate a normally distributed float.</p>
<p><strong>scala:</strong></p>
<p>One can also use <tt>java.util.Random</tt>, which does not have to be imported.</p>
<p><a name="random-seed-note" id="random-seed-note"></a></p>
<h2 id="toc16"><span><a href="#random-seed">random seed</a></span></h2>
<p>How to set a random seed. How to get and restore the state of a random number generator.</p>
<p><strong>scala:</strong></p>
<p>It looks like Scala 2.10 has modified the <tt>Random</tt> constructor so that it will accept an <tt>Int</tt> or <tt>Long</tt> as a seed argument.</p>
<p><a name="strings-note" id="strings-note"></a></p>
<h1 id="toc17"><span><a href="#strings">Strings</a></span></h1>
<p><a name="str-type-note" id="str-type-note"></a></p>
<h2 id="toc18"><span><a href="#str-type">string type</a></span></h2>
<p>The types for strings and characters.</p>
<p><a name="str-literal-note" id="str-literal-note"></a></p>
<h2 id="toc19"><span><a href="#str-literal">string literal</a></span></h2>
<p>The syntax for a string literal.</p>
<p><a name="newline-in-str-literal-note" id="newline-in-str-literal-note"></a></p>
<h2 id="toc20"><span><a href="#newline-in-str-literal">newline in literal</a></span></h2>
<p><a name="str-esc-note" id="str-esc-note"></a></p>
<h2 id="toc21"><span><a href="#str-esc">literal escapes</a></span></h2>
<p><strong>scala:</strong></p>
<p>Unicode escapes might not work when scala is installed on a Mac because the encoding is set by default to MacRoman:</p>
<div class="code">
<pre>
<code>scala&gt; System.getProperty("file.encoding")
res0: java.lang.String = MacRoman</code>
</pre></div>
<p>This can be fixed by passing the following flag to <em>java</em> in the <em>scala</em> shell script:</p>
<div class="code">
<pre>
<code>-Dfile.encoding=UTF-8</code>
</pre></div>
<p><a name="format-str-note" id="format-str-note"></a></p>
<h2 id="toc22"><span><a href="#format-str">format string</a></span></h2>
<p><a name="str-concat-note" id="str-concat-note"></a></p>
<h2 id="toc23"><span><a href="#str-concat">concatenate</a></span></h2>
<p>How to concatenate strings.</p>
<p><a name="str-replicate-note" id="str-replicate-note"></a></p>
<h2 id="toc24"><span><a href="#str-replicate">replicate</a></span></h2>
<p><a name="translate-case-note" id="translate-case-note"></a></p>
<h2 id="toc25"><span><a href="#translate-case">translate case</a></span></h2>
<p>How to convert a string to uppercase; how to convert a string to lowercase; how to capitalize the first character.</p>
<p><a name="capitalize-note" id="capitalize-note"></a></p>
<h2 id="toc26"><span><a href="#capitalize">capitalize</a></span></h2>
<p><a name="trim-note" id="trim-note"></a></p>
<h2 id="toc27"><span><a href="#trim">trim</a></span></h2>
<p><a name="pad-note" id="pad-note"></a></p>
<h2 id="toc28"><span><a href="#pad">pad</a></span></h2>
<p><a name="num-to-str-note" id="num-to-str-note"></a></p>
<h2 id="toc29"><span><a href="#num-to-str">number to string</a></span></h2>
<p><a name="str-to-num-note" id="str-to-num-note"></a></p>
<h2 id="toc30"><span><a href="#str-to-num">string to number</a></span></h2>
<p>How to parse numeric types from string; how to convert numeric types to strings.</p>
<p><strong>scala:</strong></p>
<p>The + operator will convert a numeric type to a string if the other operand is a string. Hence the following works:</p>
<div class="code">
<pre>
<code>"value: " + 8</code>
</pre></div>
<p><a name="join-note" id="join-note"></a></p>
<h2 id="toc31"><span><a href="#join">join</a></span></h2>
<p><a name="split-note" id="split-note"></a></p>
<h2 id="toc32"><span><a href="#split">split</a></span></h2>
<p><a name="char-type-note" id="char-type-note"></a></p>
<h2 id="toc33"><span><a href="#char-type">character type</a></span></h2>
<p><a name="char-literal-note" id="char-literal-note"></a></p>
<h2 id="toc34"><span><a href="#char-literal">character literal</a></span></h2>
<p><a name="str-len-note" id="str-len-note"></a></p>
<h2 id="toc35"><span><a href="#str-len">length</a></span></h2>
<p>How to get the length of a string.</p>
<p><a name="index-substr-note" id="index-substr-note"></a></p>
<h2 id="toc36"><span><a href="#index-substr">index of substring</a></span></h2>
<p>How to get the index of a substring.</p>
<p><a name="substr-note" id="substr-note"></a></p>
<h2 id="toc37"><span><a href="#substr">extract substring</a></span></h2>
<p>How to extract a substring.</p>
<p><a name="extract-char-note" id="extract-char-note"></a></p>
<h2 id="toc38"><span><a href="#extract-char">extract character</a></span></h2>
<p>How to get the character at a specified index of a string.</p>
<p>The syntax for a character literal.</p>
<p><a name="chr-ord-note" id="chr-ord-note"></a></p>
<h2 id="toc39"><span><a href="#chr-ord">chr and ord</a></span></h2>
<p>How to convert a character to its ASCII code or Unicode point; how to convert an ASCII code or Unicode point to a character.</p>
<p><a name="dates-time-note" id="dates-time-note"></a></p>
<h1 id="toc40"><span><a href="#dates-time">Dates and Time</a></span></h1>
<p><a name="fixed-length-arrays-note" id="fixed-length-arrays-note"></a></p>
<h1 id="toc41"><span><a href="#fixed-length-arrays">Fixed-Length Arrays</a></span></h1>
<p><a name="resizable-arrays-note" id="resizable-arrays-note"></a></p>
<h1 id="toc42"><span><a href="#resizable-arrays">Resizable Arrays</a></span></h1>
<p><a name="lists-note" id="lists-note"></a></p>
<h1 id="toc43"><span><a href="#lists">Lists</a></span></h1>
<p><a name="list-literal-note" id="list-literal-note"></a></p>
<h2 id="toc44"><span>list literal</span></h2>
<p><a name="list-element" id="list-element"></a></p>
<h2 id="toc45"><span>list element element</span></h2>
<p><a name="list-head" id="list-head"></a></p>
<h2 id="toc46"><span>list head</span></h2>
<p><a name="list-tail" id="list-tail"></a></p>
<h2 id="toc47"><span>list-tail</span></h2>
<p>Supports <em>List.tl</em> (with a warning) to be compatible with OCaml.</p>
<p><a name="tuples-note" id="tuples-note"></a></p>
<h1 id="toc48"><span><a href="#tuples">Tuples</a></span></h1>
<p><a name="tuple-literal-note" id="tuple-literal-note"></a></p>
<h2 id="toc49"><span><a href="#tuple-literal">literal</a></span></h2>
<p>The syntax for a tuple literal.</p>
<p><a name="tuple-type-note" id="tuple-type-note"></a></p>
<h2 id="toc50"><span><a href="#tuple-type">type</a></span></h2>
<p>How to declare a variable with a tuple type.</p>
<p><a name="tuple-lookup-note" id="tuple-lookup-note"></a></p>
<h2 id="toc51"><span><a href="#tuple-lookup">lookup</a></span></h2>
<p>How to lookup an element in a tuple.</p>
<p><a name="deconstruct-tuple-note" id="deconstruct-tuple-note"></a></p>
<h2 id="toc52"><span><a href="#deconstruct-tuple">deconstruct</a></span></h2>
<p>How to extract all the elements in a tuple.</p>
<p><a name="dictionaries-note" id="dictionaries-note"></a></p>
<h1 id="toc53"><span><a href="#dictionaries">Dictionaries</a></span></h1>
<p><a name="functions-note" id="functions-note"></a></p>
<h1 id="toc54"><span><a href="#functions">Functions</a></span></h1>
<p><a name="function" id="function"></a></p>
<h2 id="toc55"><span>function</span></h2>
<p>How to define a function.</p>
<p><strong>scala</strong></p>
<p>Recursive functions must have their return type declared because the Scala compiler cannot infer it.</p>
<p><a name="lambda" id="lambda"></a></p>
<h2 id="toc56"><span>lambda</span></h2>
<p>How to define an anonymous function.</p>
<p><a name="piecewise-defined-function" id="piecewise-defined-function"></a></p>
<h2 id="toc57"><span>piecewise defined function</span></h2>
<p>How to define a function with multiple equations and matching on the arguments.</p>
<p><a name="recursive-function" id="recursive-function"></a></p>
<h2 id="toc58"><span>recursive function</span></h2>
<p>How to define a recursive function.</p>
<p><a name="mutually-recursive-functions" id="mutually-recursive-functions"></a></p>
<h2 id="toc59"><span>mutually recursive functions</span></h2>
<p>How to define two functions which call each other. Mutual recursion can be eliminated by inlining the second function inside the first function. The first function is then recursive and can be defined independently of the second function.</p>
<p><a name="named-parameter" id="named-parameter"></a></p>
<h2 id="toc60"><span>named parameter</span></h2>
<p>How to define and invoke a function with named parameters.</p>
<p><a name="default-value" id="default-value"></a></p>
<h2 id="toc61"><span>named parameter default value</span></h2>
<p>How to make named parameters optional by providing a default value in the definition.</p>
<p><a name="infix-prefix" id="infix-prefix"></a></p>
<h2 id="toc62"><span>infix operator in prefix position</span></h2>
<p>How to invoke an infix operator in prefix position.</p>
<p><a name="function-infix" id="function-infix"></a></p>
<h2 id="toc63"><span>function in infix position</span></h2>
<p>How to invoke a function in infix position.</p>
<p><a name="currying" id="currying"></a></p>
<h2 id="toc64"><span>currying</span></h2>
<p>How to create a curried function by providing values for some of the arguments of a function.</p>
<p><strong>scala:</strong></p>
<p>Functions can only be curried if they are defined with special syntax. Functions defined with this syntax must be invoked with a pair of parens for each argument.</p>
<p><a name="function-composition" id="function-composition"></a></p>
<h2 id="toc65"><span>function composition operator</span></h2>
<p>An operator which takes two functions as arguments and returns a function constructed from them by composition.</p>
<p><a name="lazy-evaluation" id="lazy-evaluation"></a></p>
<h2 id="toc66"><span>lazy evaluation</span></h2>
<p>How to evaluate the arguments to a function in a lazy manner.</p>
<p>Lazy evaluation is also called <em>call-by-name</em>.</p>
<p><strong>scala:</strong></p>
<p>Functions can be defined to evaluate their arguments lazily by putting a <tt>=&gt;</tt> operator between the colon and the type of the parameter in the function signature.</p>
<p>We can define <tt>arg1</tt> so that the first argument is strict and the second argument is lazy:</p>
<div class="code">
<pre>
<code>def arg1(x: Int, y: =&gt; Int): Int = x

arg1(7, 1 / 0)</code>
</pre></div>
<p><a name="strict-evaluation" id="strict-evaluation"></a></p>
<h2 id="toc67"><span>strict evaluation</span></h2>
<p>How to evaluate arguments before they are passed to a function.</p>
<p>Strict evaluation is also called <em>call by-value</em>.</p>
<p><a name="execution-control-note" id="execution-control-note"></a></p>
<h1 id="toc68"><span><a href="#execution-control">Execution Control</a></span></h1>
<p><a name="if-note" id="if-note"></a></p>
<h2 id="toc69"><span><a href="#if">if</a></span></h2>
<p>The <tt>if</tt> statement.</p>
<p><a name="while-note" id="while-note"></a></p>
<h2 id="toc70"><span><a href="#while">while</a></span></h2>
<p>The <tt>while</tt> loop.</p>
<p><a name="for-note" id="for-note"></a></p>
<h2 id="toc71"><span><a href="#for">for</a></span></h2>
<p><a name="infinite-loop-note" id="infinite-loop-note"></a></p>
<h2 id="toc72"><span><a href="#infinite-loop">infinite loop</a></span></h2>
<p>An infinite loop.</p>
<p><a name="break-continue-note" id="break-continue-note"></a></p>
<h2 id="toc73"><span><a href="#break-continue">break and continue</a></span></h2>
<p>Statements for exiting a loop or ending an iteration of a loop.</p>
<p><a name="exceptions-note" id="exceptions-note"></a></p>
<h1 id="toc74"><span><a href="#exceptions">Exceptions</a></span></h1>
<p><a name="raise-error" id="raise-error"></a></p>
<h2 id="toc75"><span>raise error</span></h2>
<p>How to raise an error.</p>
<p><a name="handle-error" id="handle-error"></a></p>
<h2 id="toc76"><span>handle error</span></h2>
<p>How to handle an error.</p>
<p><a name="concurrency-note" id="concurrency-note"></a></p>
<h1 id="toc77"><span><a href="#concurrency">Concurrency</a></span></h1>
<p><a name="file-handles-note" id="file-handles-note"></a></p>
<h1 id="toc78"><span><a href="#file-handles">Filehandles</a></span></h1>
<p><a name="files-note" id="files-note"></a></p>
<h1 id="toc79"><span><a href="#files">Files</a></span></h1>
<p><a name="directories-note" id="directories-note"></a></p>
<h1 id="toc80"><span><a href="#directories">Directories</a></span></h1>
<p><a name="processes-environment-note" id="processes-environment-note"></a></p>
<h1 id="toc81"><span><a href="#processes-environment">Processes and Environment</a></span></h1>
<p><a name="libraries-namespaces-note" id="libraries-namespaces-note"></a></p>
<h1 id="toc82"><span><a href="#libraries-namespaces">Libraries and Namespaces</a></span></h1>
<p><a name="namespace-example" id="namespace-example"></a></p>
<h2 id="toc83"><span>namespace example</span></h2>
<p><a name="namespaces" id="namespaces"></a></p>
<h2 id="toc84"><span>namespaces</span></h2>
<p><a name="file-name" id="file-name"></a></p>
<h2 id="toc85"><span>file name restrictions</span></h2>
<p><a name="import" id="import"></a></p>
<h2 id="toc86"><span>import</span></h2>
<p><a name="namespace-creation" id="namespace-creation"></a></p>
<h2 id="toc87"><span>namespace creation</span></h2>
<p><a name="namespace-alias" id="namespace-alias"></a></p>
<h2 id="toc88"><span>namespace alias</span></h2>
<p><a name="namespace-separator" id="namespace-separator"></a></p>
<h2 id="toc89"><span>namespace separator</span></h2>
<p><a name="subnamespace" id="subnamespace"></a></p>
<h2 id="toc90"><span>subnamespace</span></h2>
<p><a name="inspect-namespace" id="inspect-namespace"></a></p>
<h2 id="toc91"><span>inspect namespace</span></h2>
<p><a name="user-defined-types-note" id="user-defined-types-note"></a></p>
<h1 id="toc92"><span><a href="#user-defined-types">User-Defined Types</a></span></h1>
<p><a name="type-synonym-note" id="type-synonym-note"></a></p>
<h2 id="toc93"><span><a href="#type-synonym">type synonym</a></span></h2>
<p><a name="sum-type-note" id="sum-type-note"></a></p>
<h2 id="toc94"><span><a href="#sum-type">sum type</a></span></h2>
<p><a name="generic-type-note" id="generic-type-note"></a></p>
<h2 id="toc95"><span><a href="#generic-type">generic type</a></span></h2>
<p><a name="recursive-type-note" id="recursive-type-note"></a></p>
<h2 id="toc96"><span><a href="#recursive-type">recursive type</a></span></h2>
<p><a name="objects-note" id="objects-note"></a></p>
<h1 id="toc97"><span><a href="#objects">Objects</a></span></h1>
<p><a name="inheritance-polymorphism-note" id="inheritance-polymorphism-note"></a></p>
<h1 id="toc98"><span><a href="#inheritance-polymorphism">Inheritance and Polymorphism</a></span></h1>
<p><a name="repl-note" id="repl-note"></a></p>
<h1 id="toc99"><span><a href="#repl">REPL</a></span></h1>
<p><a name="invoke-repl" id="invoke-repl"></a></p>
<h2 id="toc100"><span>repl</span></h2>
<p><a name="repl-limitations" id="repl-limitations"></a></p>
<h2 id="toc101"><span>repl limitations</span></h2>
<p><a name="repl-last-value" id="repl-last-value"></a></p>
<h2 id="toc102"><span>repl last value</span></h2>
<p><a name="help" id="help"></a></p>
<h2 id="toc103"><span>help</span></h2>
<p><a name="inspect-type" id="inspect-type"></a></p>
<h2 id="toc104"><span>inspect type</span></h2>
<p><a name="load-source" id="load-source"></a></p>
<h2 id="toc105"><span>load source file</span></h2>
<p><a name="search-path" id="search-path"></a></p>
<h2 id="toc106"><span>search path</span></h2>
<p><a name="search-path-command-line" id="search-path-command-line"></a></p>
<h2 id="toc107"><span>set search path on command line</span></h2>
<p><a name="rust" id="rust"></a></p>
<h1 id="toc108"><span><a href="#top">Rust</a></span></h1>
<p><a href="http://doc.rust-lang.org/0.12.0/reference.html">The Rust Reference</a><br />
<a href="http://doc.rust-lang.org/std/index.html">The Rust Standard Library</a></p>
<p><a name="scala" id="scala"></a></p>
<h1 id="toc109"><span><a href="#top">Scala</a></span></h1>
<p><a href="http://www.scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf">The Scala Language Specification: Version 2.9 (pdf)</a><br />
<a href="http://www.scala-lang.org/documentation/api.html">Scala API Docs</a></p>
<p><a name="swift" id="swift"></a></p>
<h1 id="toc110"><span><a href="#top">Swift</a></span></h1>
<p>As of June 2014, to use Swift one must download and install a beta version of Xcode 6, then:</p>
<div class="code">
<pre>
<code>$ sudo xcode-select -s /Applications/Xcode6-Beta.app/Contents/Developer/

$ xcrun swift</code>
</pre></div>

                    </div>
        </div>
      </div>
      <div id="license-area" class="license-area">
        <a href="https://github.com/clarkgrubb/hyperpolyglot/issues">issue tracker</a> |
        content of this page licensed under
        <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">
        creative commons attribution-sharealike 3.0</a>
        <br>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17129977-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
