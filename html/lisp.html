<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<link rel="icon" type="image/gif" href="/favicon.gif"/>
<link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png" />
<link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png" />
<title>Lisp: Common Lisp, Racket, Clojure, Emacs Lisp - Hyperpolyglot</title>
<style type="text/css" id="internal-style">
@import url(hyperpolyglot.css);
</style>
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<meta http-equiv="content-language" content="en"/>
</head>
<body>
<div id="container-wrap-wrap">
  <div id="container-wrap">
    <div id="container">
      <div id="header">
        <h1><a href="/"><span>Hyperpolyglot</span></a></h1>
      </div>
      <div id="content-wrap">
        <div id="main-content">
<div id="page-title">
                            Lisp: Common Lisp, Racket, Clojure, Emacs Lisp
                        </div>
<div id="page-content">
                        

<p>c<a name="top" id="top"></a><em>a side-by-side reference sheet</em></p>
<p><a href="#grammar-execution">grammar and execution</a> | <a href="#var-expr">variables and expressions</a> | <a href="#arithmetic-logic">arithmetic and logic</a> | <a href="#strings">strings</a> | <a href="#regexes">regular expressions</a> | <a href="#dates-time">dates and time</a> | <a href="#lists">lists</a> | <a href="#fixed-length-arrays">fixed-length arrays</a> | <a href="#dictionaries">dictionaries</a> | <a href="#user-defined-types">user-defined types</a> | <a href="#functions">functions</a> | <a href="#execution-control">execution control</a> | <a href="#exceptions">exceptions</a> | <a href="#streams">streams</a> | <a href="#emacs-buffers">emacs buffers</a> | <a href="#files">files</a> | <a href="#directories">directories</a> | <a href="#processes-environment">processes and environment</a> | <a href="#libraries-namespaces">libraries and namespaces</a> | <a href="#objects">objects</a> | <a href="#lisp-macros">lisp macros</a> | <a href="#reflection">reflection</a> | <a href="#java-interop">java interop</a></p>
<table class="wiki-content-table">
<tr>
<th></th>
<th><a href="#common-lisp">common lisp</a></th>
<th><a href="#racket">racket</a></th>
<th><a href="#clojure">clojure</a></th>
<th><a href="#emacs-lisp">emacs lisp</a></th>
</tr>
<tr>
<td><a name="version-used" id="version-used"></a><a href="#version-used-note">version used</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>SBCL 1.2</em></span></td>
<td><span style="color: gray"><em>Racket 6.1</em></span></td>
<td><span style="color: gray"><em>Clojure 1.6</em></span></td>
<td><span style="color: gray"><em>Emacs 24.5</em></span></td>
</tr>
<tr>
<td><a name="show-version" id="show-version"></a><a href="#show-version-note">show version</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>$ sbcl <span style="white-space: pre-wrap;">--</span>version</td>
<td>$ racket <span style="white-space: pre-wrap;">--</span>version</td>
<td><span style="color: gray"><em>displayed by repl on startup</em></span></td>
<td>$ emacs <span style="white-space: pre-wrap;">--</span>version</td>
</tr>
<tr>
<th colspan="5"><a name="grammar-execution" id="grammar-execution"></a><a href="#grammar-execution-note">grammar and execution</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="compiler" id="compiler"></a><a href="#compiler-note">compiler</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td>$ raco make <span style="color: gray"><em>module</em></span>.rkt</td>
<td></td>
<td>M-x byte-compile-file</td>
</tr>
<tr>
<td><a name="standalone-executable" id="standalone-executable"></a><a href="#standalone-executable-note">standalone executable</a></td>
<td>(sb-ext:save-lisp-and-die<br />
<span style="white-space: pre-wrap;">  </span>"<span style="color: gray"><em>executable</em></span>"<br />
<span style="white-space: pre-wrap;">  </span>:executable t<br />
<span style="white-space: pre-wrap;">  </span>:toplevel '<span style="color: gray"><em>function</em></span>)</td>
<td>$ mzc —exe <span style="color: gray"><em>executable</em></span> <span style="color: gray"><em>file</em></span></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="interpreter" id="interpreter"></a><a href="#interpreter-note">interpreter</a><br />
<span style="white-space: pre-wrap;">  </span></td>
<td>$ sbcl <span style="white-space: pre-wrap;">--</span>script foo.lisp</td>
<td>$ racket -r foo.racket</td>
<td><span style="color: grey"><em>specify full path to clojure jar:</em></span><br />
<br />
java -cp clojure.jar clojure.main foo.clj</td>
<td></td>
</tr>
<tr>
<td><a name="shebang" id="shebang"></a><a href="#shebang-note">shebang</a></td>
<td>#!/usr/bin/env sbcl <span style="white-space: pre-wrap;">--</span>script</td>
<td>#!/usr/bin/env racket <span style="white-space: pre-wrap;">--</span>script</td>
<td><span style="color: gray"><em>specify full path to clojure jar:</em></span><br />
<br />
#!/usr/bin/env java -jar clojure.jar</td>
<td>#!/usr/bin/env emacs <span style="white-space: pre-wrap;">--</span>script</td>
</tr>
<tr>
<td><a name="repl" id="repl"></a><a href="#repl-note">repl</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>$ sbcl</td>
<td>$ racket</td>
<td>$ java -jar /PATH/TO/clojure.jar</td>
<td>M-x ielm</td>
</tr>
<tr>
<td><a name="cmd-line-program" id="cmd-line-program"></a><a href="#cmd-line-program-note">command line program</a></td>
<td></td>
<td>$ racket -e '(+ 1 1)'</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="word-separator" id="word-separator"></a><a href="#word-separator-note">word separator</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>whitespace</em></span></td>
<td><span style="color: gray"><em>whitespace</em></span></td>
<td><span style="color: gray"><em>whitespace and commas</em></span></td>
<td><span style="color: gray"><em>whitespace</em></span></td>
</tr>
<tr>
<td><a name="eol-comment" id="eol-comment"></a><a href="#eol-comment-note">end-of-line comment</a></td>
<td>(+ 1 1) <span style="color: gray">; adding</span></td>
<td>(+ 1 1) <span style="color: gray">; adding</span></td>
<td>(+ 1 1) <span style="color: gray">; adding</span></td>
<td>(+ 1 1) <span style="color: gray">; adding</span></td>
</tr>
<tr>
<td><a name="multiple-line-comment" id="multiple-line-comment"></a><a href="#multiple-line-comment-note">multiple line comment</a></td>
<td>(+ 1 #| adding |# 1)</td>
<td>(+ 1 #| adding |# 1)</td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="var-expr" id="var-expr"></a><a href="#var-expr-note">variables and expressions</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="id" id="id"></a><a href="#id-note">identifier</a></td>
<td><span style="color: gray"><em>case insensitive, cannot start with digit</em></span><br />
<br />
<span style="color: gray"><em>excluded characters:</em></span><br />
SP ( ) " , ' <span style="white-space: pre-wrap;">`</span> : ; # | \<br />
<br />
<span style="color: gray"><em>reserved for user macros:</em></span><br />
? ! [ ] { }</td>
<td><span style="color: gray"><em>case sensitive, cannot start with digit</em></span><br />
<br />
<span style="color: gray"><em>excluded characters:</em></span><br />
SP ( ) [ ] { } " , ' <span style="white-space: pre-wrap;">`</span> ; # | \</td>
<td><span style="color: gray"><em>case sensitive, cannot start with digit</em></span><br />
<br />
<span style="color: gray"><em>permitted characters:</em></span><br />
A-Z a-z 0-9 * + ! - _ ?<br />
<br />
<span style="color: gray"><em>these have special meaning or are reserved:</em></span><br />
/ . :</td>
<td><span style="color: gray"><em>case sensitive, cannot start with digit</em></span><br />
<br />
<span style="color: gray"><em>excluded characters:</em></span><br />
SP ( ) " , ' <span style="white-space: pre-wrap;">`</span> ; # | \ _ [ ]</td>
</tr>
<tr>
<td><a name="quoted-id" id="quoted-id"></a><a href="#quoted-id-note">quoted identifier</a><br />
<span style="color: gray"><em>and escaped identifier</em></span></td>
<td>(setq |white space symbol| 3)<br />
<br />
(setq white\ space\ symbol 3)</td>
<td>(define |white space symbol| 3)<br />
<br />
(define white\ space\ symbol 3)</td>
<td><span style="color: gray"><em>none</em></span><br />
<br />
<span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span><br />
<br />
(setq white\ space\ symbol 3)</td>
</tr>
<tr>
<td><a name="local-var" id="local-var"></a><a href="#local-var-note">local variable</a></td>
<td><span style="color: gray">; parallel assignment:</span><br />
(let ((x 3) (y 4))<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))<br />
<br />
<span style="color: gray">; sequential assignment:</span><br />
(let* ((x 3) (y (* x x)))<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))</td>
<td><span style="color: gray">; parallel assignment:</span><br />
(let ((x 3) (y 4))<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))<br />
<br />
<span style="color: gray">; sequential assignment:</span><br />
(let* ((x 3) (y (* x x)))<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))</td>
<td>(let [x 3 y 4]<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))<br />
<br />
(let [[x y] [3 4]]<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))<br />
<br />
(let [x 3 y (* x x)]<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))</td>
<td><span style="color: gray">; parallel assignment:</span><br />
(lexical-let ((x 3) (y 4))<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))<br />
<br />
(lexical-let* ((x 3) (y (* x x)))<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))</td>
</tr>
<tr>
<td><a name="global-var" id="global-var"></a><a href="#global-var-note">global variable</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(defparameter *x* 3)<br />
<br />
<span style="color: gray">; doesn't change x if already set:</span><br />
(defvar *x* 3)</td>
<td>(define x 3)<br />
<br />
<span style="color: gray">; y is not global:</span><br />
(define (double z)<br />
<span style="white-space: pre-wrap;">  </span>(define y 2)<br />
<span style="white-space: pre-wrap;">  </span>(* y z))</td>
<td>(def x 3)</td>
<td>(set 'x 3)<br />
(setq x 3)</td>
</tr>
<tr>
<td><a name="rm-var" id="rm-var"></a><a href="#rm-var-note">remove variable</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(makunbound 'x)</td>
<td>(namespace-undefine-variable! 'x)</td>
<td>(ns-unmap *ns* 'x)</td>
<td>(makunbound 'x)</td>
</tr>
<tr>
<td><a name="null" id="null"></a><a href="#null-note">null</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>nil '()</td>
<td>null '()</td>
<td><span style="color: gray">; same value as null in Java:</span><br />
nil</td>
<td>nil '()</td>
</tr>
<tr>
<td><a name="null-test" id="null-test"></a><a href="#null-test-note">null test</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(null x)</td>
<td>(null? x)</td>
<td>(nil? x)</td>
<td>(null x)</td>
</tr>
<tr>
<td><a name="id-as-val" id="id-as-val"></a><a href="#id-as-val-note">identifier as value</a></td>
<td>'x<br />
(quote x)</td>
<td>'x<br />
(quote x)</td>
<td>'x<br />
(quote x)</td>
<td>'x<br />
(quote x)</td>
</tr>
<tr>
<td><a name="id-test" id="id-test"></a><a href="#id-test-note">identifier test</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(symbolp 'x)</td>
<td>(symbol? 'x)</td>
<td>(symbol? 'x)</td>
<td>(symbolp 'x)</td>
</tr>
<tr>
<td>identifier equality test</td>
<td>(eq 'x 'x)</td>
<td>(eq? 'x 'x)</td>
<td>(= 'x 'x)</td>
<td>(eq 'x 'x)</td>
</tr>
<tr>
<td><a name="non-referential-id" id="non-referential-id"></a><a href="#non-referential-id-note">non-referential identifier</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>:foo</td>
<td>#:foo</td>
<td>:foo</td>
<td>:foo</td>
</tr>
<tr>
<td><a name="id-attr" id="id-attr"></a><a href="#id-attr-note">identifier attributes</a><br />
<span style="color: gray"><em>set, get, remove</em></span></td>
<td>(set 'x 13)<br />
<br />
(setf (get 'x :desc) "unlucky")<br />
(get 'x :desc)<br />
(remprop 'x :desc)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray">; value must be instance of clojure.lang.IObj:</span><br />
<br />
(def x (with-meta [13] {:desc "unlucky"}))<br />
(get (meta x) :desc)<br />
<span style="color: gray">; none</span></td>
<td>(set 'x 13)<br />
<br />
(setf (get 'x :desc) "unlucky")<br />
(get 'x :desc)<br />
(remprop 'x :desc)</td>
</tr>
<tr>
<th colspan="5"><a name="arithmetic-logic" id="arithmetic-logic"></a><a href="#arithmetic-logic-note">arithmetic and logic</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="true-false" id="true-false"></a><a href="#true-false-note">true and false</a></td>
<td>t nil</td>
<td>#t #f<br />
true false</td>
<td>true false</td>
<td>t nil</td>
</tr>
<tr>
<td><a name="falsehoods" id="falsehoods"></a><a href="#falsehoods-note">falsehoods</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>nil ()</td>
<td>#f false</td>
<td>false nil</td>
<td>nil ()</td>
</tr>
<tr>
<td><a name="logical-op" id="logical-op"></a><a href="#logical-op-note">logical operators</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(or (not t) (and t nil))</td>
<td>(or (not #t) (and #t #f))</td>
<td>(or (not true) (and true false))</td>
<td>(or (not t) (and t nil))</td>
</tr>
<tr>
<td><a name="relational-op" id="relational-op"></a><a href="#relational-op-note">relational operators</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="white-space: pre-wrap;">=</span> /= &lt; &gt; &lt;= &gt;=</td>
<td><span style="white-space: pre-wrap;">=</span> <span style="color: gray"><em>none</em></span> &lt; &gt; &lt;= &gt;=</td>
<td><span style="white-space: pre-wrap;">=</span> not= &lt; &gt; &lt;= &gt;=</td>
<td><span style="white-space: pre-wrap;">=</span> /= &lt; &gt; &lt;= &gt;=</td>
</tr>
<tr>
<td><a name="min-max" id="min-max"></a><a href="#min-max-note">min and max</a></td>
<td>(min 1 2 3)<br />
(max 1 2 3)</td>
<td>(min 1 2 3)<br />
(max 1 2 3)</td>
<td>(min 1 2 3)<br />
(max 1 2 3)</td>
<td>(min 1 2 3)<br />
(max 1 2 3)</td>
</tr>
<tr>
<td><a name="num-predicates" id="num-predicates"></a><a href="#num-predicates-note">numeric predicates</a></td>
<td>numberp integerp<br />
rationalp floatp<br />
realp complexp</td>
<td>number? integer?<br />
rational? inexact?<br />
real? complex?</td>
<td>number? integer?<br />
rational? float?<br />
<span style="color: gray"><em>none</em></span> <span style="color: gray"><em>none</em></span></td>
<td>numberp integerp<br />
<span style="color: gray"><em>none</em></span> floatp<br />
<span style="color: gray"><em>none</em></span> <span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="arith-op" id="arith-op"></a><a href="#arith-op-note">arithmetic operators</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>+ - * / mod</td>
<td>+ - * / modulo</td>
<td>+ - * / mod</td>
<td>+ - * / %</td>
</tr>
<tr>
<td><a name="int-div" id="int-div"></a><a href="#int-div-note">integer division</a><br />
<span style="color: gray"><em>and remainder</em></span></td>
<td>(truncate 7 3)<br />
(rem 7 3)</td>
<td>(quotient 7 3)<br />
(remainder 7 3)</td>
<td>(quot 7 3)<br />
(rem 7 3)</td>
<td>(/ 7 3)<br />
(% 7 3)</td>
</tr>
<tr>
<td><a name="int-div-zero" id="int-div-zero"></a><a href="#int-div-zero-note">integer division by zero</a></td>
<td><span style="color: gray">division-by-zero <em>error</em></span></td>
<td><span style="color: gray">division by zero <em>error</em></span></td>
<td></td>
<td><span style="color: gray">arith-error</span></td>
</tr>
<tr>
<td><a name="float-div" id="float-div"></a><a href="#float-div-note">float division</a></td>
<td><span style="color: gray"><em>rational:</em></span><br />
(/ 7 3)<br />
<br />
<span style="color: gray"><em>float:</em></span><br />
(/ 7 (* 3 1.0))</td>
<td><span style="color: gray"><em>rational:</em></span><br />
(/ 7 3)<br />
<br />
<span style="color: gray"><em>float:</em></span><br />
(/ 7 (float 3))</td>
<td><span style="color: gray"><em>rational:</em></span><br />
(/ 7 3)<br />
<br />
<span style="color: gray"><em>float:</em></span><br />
(/ 7 (* 3 1.0))</td>
<td><span style="color: gray"><em>integer quotient:</em></span><br />
(/ 7 3)<br />
<br />
<span style="color: gray"><em>float:</em></span><br />
(/ 7 (* 3 1.0))</td>
</tr>
<tr>
<td><a name="float-div-zero" id="float-div-zero"></a><a href="#float-div-zero-note">float division by zero</a></td>
<td><span style="color: gray">division-by-zero <em>error</em></span></td>
<td></td>
<td></td>
<td>-1.0e+INF, -0.0e+NaN, <span style="color: gray"><em>or</em></span> 1.0e+INF</td>
</tr>
<tr>
<td><a name="power" id="power"></a><a href="#power-note">power</a></td>
<td>(expt 2 32)</td>
<td>(expt 2 32)</td>
<td><span style="color: gray"><em>returns float:</em></span><br />
(Math/pow 2 32)</td>
<td>(expt 2 32)</td>
</tr>
<tr>
<td><a name="sqrt" id="sqrt"></a><a href="#sqrt-note">sqrt</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(sqrt 2)</td>
<td>(sqrt 2)</td>
<td>(Math/sqrt 2)</td>
<td>(sqrt 2)</td>
</tr>
<tr>
<td><a name="sqrt-negative-one" id="sqrt-negative-one"></a><a href="#sqrt-negative-one">sqrt -1</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>#c(0.0 1.0)</td>
<td>0+1i</td>
<td><span style="color: gray"><em>(Math/sqrt -1):</em></span> NaN</td>
<td>-0.0e+NaN</td>
</tr>
<tr>
<td><a name="transcendental-func" id="transcendental-func"></a><a href="#transcendental-func-note">transcendental functions</a></td>
<td>exp log sin cos tan asin acos atan atan</td>
<td>exp log sin cos tan asin acos atan atan</td>
<td>Math/exp Math/log Math/sin Math/cos Math/tan Math/asin Math/acos Math/atan Math/atan2</td>
<td>exp log sin cos tan asin acos atan atan</td>
</tr>
<tr>
<td><a name="float-truncation" id="float-truncation"></a><a href="#float-truncation-note">float truncation</a></td>
<td><span style="color: gray"><em>return two values, first is integer:</em></span><br />
truncate round ceiling floor</td>
<td><span style="color: gray"><em>return floats:</em></span><br />
truncate round ceiling floor</td>
<td><span style="color: gray"><em>return integers:</em></span><br />
int Math/round<br />
<span style="color: gray"><em>return floats:</em></span><br />
Math/ceil Math/floor</td>
<td>truncate round ceiling floor<br />
fround fceiling ffloor<br />
<span style="color: gray">truncate <em>returns integer</em></span></td>
</tr>
<tr>
<td><a name="abs-val" id="abs-val"></a><a href="#abs-val-note">absolute value</a><br />
<span style="color: gray"><em>and signum</em></span></td>
<td>abs signum</td>
<td>abs<br />
<span style="color: gray"><em>racket:</em></span> sgn</td>
<td>Math/abs Math/signum</td>
<td>abs signum</td>
</tr>
<tr>
<td><a name="int-overflow" id="int-overflow"></a><a href="#int-overflow-note">integer overflow</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>none; arbitrary-precision integers</em></span></td>
<td><span style="color: gray"><em>none; arbitrary-precision integers</em></span></td>
<td><span style="color: gray">clojure.lang.Numbers.throwIntOverflow <em>exception</em></span></td>
<td></td>
</tr>
<tr>
<td><a name="float-overflow" id="float-overflow"></a><a href="#float-overflow-note">float overflow</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray">floating-point-overflow <em>error</em></span></td>
<td></td>
<td><span style="color: gray"><em>not literals:</em></span><br />
-Infity NaN Infinity</td>
<td></td>
</tr>
<tr>
<td><a name="rational-construction" id="rational-construction"></a><a href="#rational-construction-note">rational construction</a></td>
<td>(/ 3 7)<br />
<br />
<span style="color: gray">; literal:</span><br />
3/7</td>
<td>(/ 3 7)<br />
<br />
<span style="color: gray">; literal:</span><br />
3/7<br />
<br />
<span style="color: gray">; also rational:</span><br />
2.718<br />
(exp 1)</td>
<td>(/ 3 7)<br />
<br />
<span style="color: gray">; literal:</span><br />
3/7</td>
<td></td>
</tr>
<tr>
<td><a name="rational-decomposition" id="rational-decomposition"></a><a href="#rational-decomposition-note">rational decomposition</a></td>
<td>(numerator 3/7)<br />
(denominator 3/7)</td>
<td>(numerator 3/7)<br />
(denominator 3/7)</td>
<td>(numerator 3/7)<br />
(denominator 3/7)</td>
<td><span style="color: gray"><em>none</em></span> <span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="complex-construction" id="complex-construction"></a><a href="#complex-construction-note">complex construction</a></td>
<td>#c(1 2)</td>
<td>1+2i<br />
(+ 1 +2i)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="complex-decomposition" id="complex-decomposition"></a><a href="#complex-decomposition-note">complex decomposition</a></td>
<td>(realpart #c(1 2))<br />
(imagpart #c(1 2))<br />
(phase #c(1 2))<br />
(abs #c(1 2))<br />
(conjugate #c(1 2))</td>
<td>(real-part 1+2i)<br />
(imag-part 1+2i)<br />
(angle 1+2i)<br />
(magnitude 1+2i)<br />
(conjugate 1+2i)</td>
<td><span style="color: gray"><em>none</em></span><br />
<span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span> <span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="random-num" id="random-num"></a><a href="#random-num-note">random number</a><br />
<span style="color: gray"><em>uniform integer, uniform float, normal float</em></span></td>
<td>(random 100)<br />
(random 1.0)<br />
<span style="color: gray"><em>none</em></span></td>
<td>(random 100)<br />
(random)<br />
<span style="color: gray"><em>none</em></span></td>
<td>(def rnd (java.util.Random.))<br />
(.nextInt rnd 100)<br />
(.nextFloat rnd)<br />
(.nextGaussian rnd)</td>
<td>(random 100)<br />
<span style="color: gray"><em>none</em></span><br />
<span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="random-seed" id="random-seed"></a><a href="#random-seed-note">random seed</a></td>
<td>(setq *random-state*<br />
<span style="white-space: pre-wrap;">  </span>(sb-ext:seed-random-state 17))</td>
<td>(random-seed 17)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="bit-op" id="bit-op"></a><a href="#bit-op-note">bit operators</a></td>
<td>ash <span style="color: gray"><em>left shift when 2nd argument positive</em></span> logand logior logxor lognot</td>
<td>arithmetic-shift <span style="color: gray"><em>left shift when 2nd argument positive</em></span> bitwise-and bitwise-ior bitwise-xor bitwise-not</td>
<td>bit-shift-left bit-shift-right bit-and bit-or bit-xor bit-not</td>
<td>lsh <span style="color: gray"><em>left shift when 2nd argument positive</em></span> logand logior logxor lognot</td>
</tr>
<tr>
<td><a name="binary-octal-hex-literals" id="binary-octal-hex-literals"></a><a href="#binary-octal-hex-literals-note">binary, octal, and hex literals</a></td>
<td>#b101010<br />
#o52<br />
#x2a</td>
<td>#b101010<br />
#o52<br />
#x2a</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="radix" id="radix"></a><a href="#radix-note">radix</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(format nil "~7r" 42)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="strings" id="strings"></a><a href="#strings-note">strings</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="str-test" id="str-test"></a><a href="#str-test-note">string test</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(stringp "foo")</td>
<td>(string? "foo")</td>
<td>(string? "foo")</td>
<td>(stringp "foo")</td>
</tr>
<tr>
<td><a name="str-literal" id="str-literal"></a><a href="#str-litera-notel">string literal</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>"foo bar"</td>
<td>"foo bar"</td>
<td>"foo bar"</td>
<td>"foo bar"</td>
</tr>
<tr>
<td><a name="newline-in-str-literal" id="newline-in-str-literal"></a><a href="#newline-in-str-literal-note">newline in literal</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>yes</em></span></td>
<td><span style="color: gray"><em>yes</em></span></td>
<td><span style="color: gray"><em>yes</em></span></td>
<td><span style="color: gray"><em>yes</em></span></td>
</tr>
<tr>
<td><a name="str-literal-esc" id="str-literal-esc"></a><a href="#str-literal-esc-note">literal escapes</a></td>
<td>\" \\</td>
<td>\t \n \r \" \\ \<span style="color: gray"><em>ooo</em></span> \u<span style="color: gray"><em>hhhh</em></span></td>
<td>\b \t \n \f \r \" \\ \<span style="color: gray"><em>ooo</em></span> \u<span style="color: gray"><em>hhhh</em></span></td>
<td>\b \t \n \f \r \" \\ \<span style="color: gray"><em>ooo</em></span> \u<span style="color: gray"><em>hhhh</em></span> \x<span style="color: gray"><em>h</em></span> - \x<span style="color: gray"><em>hhhhhh</em></span> \C-<span style="color: gray"><em>x</em></span> \M-<span style="color: gray"><em>x</em></span></td>
</tr>
<tr>
<td><a name="str-ctor" id="str-ctor"></a><a href="#str-ctor-note">constructor</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td>(string #\f #\o #\o)</td>
<td></td>
<td>(string ?f ?o ?o)</td>
</tr>
<tr>
<td><a name="fmt-str" id="fmt-str"></a><a href="#fmt-str-note">format string</a></td>
<td>(format nil "~a: ~a ~,2f" "Foo" 7 13.457)</td>
<td>(format "~a ~a ~a" "Foo" 7 13.457)</td>
<td>(String/format "%s: %d %.2f"<br />
<span style="white-space: pre-wrap;">  </span>(to-array ["Foo" 7 13.457]))</td>
<td>(format "%s: %d %.2f" "Foo" 7 13.457)</td>
</tr>
<tr>
<td><a name="fmt-specifiers" id="fmt-specifiers"></a><a href="#fmt-specifiers-note">format specifiers</a></td>
<td><span style="color: gray">~a<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>any type, human readable<br />
~s<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>any time, read parseable<br />
~%<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>newline<br />
~~<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>tilde<br />
~c<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>character<br />
~,5f<span style="white-space: pre-wrap;">  </span>5 digits right of decimal mark<br />
~d<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>decimal<br />
~x<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>hex<br />
~o<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>octal<br />
~b<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>binary</span></td>
<td><span style="color: gray">~a<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>any type, human readable<br />
~s<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>any time, read parseable<br />
~%<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>newline<br />
~~<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>tilde<br />
~c<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>character<br />
<br />
~d<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>decimal<br />
~x<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>hex<br />
~o<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>octal<br />
~b<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>binary</span></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="compare-str" id="compare-str"></a><a href="#compare-str-note">compare strings</a></td>
<td>(string= "foo" "bar")<br />
(string&lt; "foo" "bar")</td>
<td>(string=? "foo" "bar")<br />
(string&lt;? "foo" "bar")</td>
<td>(.equals "foo" "bar")<br />
(.compareTo "foo" "bar")</td>
<td>(string= "foo" "bar")<br />
(string&lt; "foo" "bar")</td>
</tr>
<tr>
<td><a name="str-concat" id="str-concat"></a><a href="#str-concat-note">concatenate</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(concatenate 'string "foo " "bar " "bar")</td>
<td>(string-append "foo " "bar " "baz")</td>
<td>(str "foo " "bar " "baz")</td>
<td>(concat "foo " "bar " "baz")</td>
</tr>
<tr>
<td><a name="str-replicate" id="str-replicate"></a><a href="#str-replicate-note">replicate</a></td>
<td>make-string 3 :initial-element #\f)</td>
<td>(make-string 3 #\f)</td>
<td>(String. (into-array<br />
<span style="white-space: pre-wrap;">  </span>(. Character TYPE)<br />
<span style="white-space: pre-wrap;">  </span>(repeat 3 \f)))</td>
<td>(make-string 3 ?f)</td>
</tr>
<tr>
<td><a name="translate-case" id="translate-case"></a><a href="#translate-case-note">translate case</a></td>
<td>(string-downcase "FOO")<br />
(string-upcase "foo")</td>
<td>(string-downcase "FOO")<br />
(string-upcase "foo")</td>
<td>(.toLowerCase "FOO")</td>
<td>(downcase "FOO")<br />
(upcase "foo")</td>
</tr>
<tr>
<td><a name="capitalize" id="capitalize"></a><a href="#capitalize-note">capitalize</a></td>
<td><span style="color: gray">; "Foo Bar":</span><br />
(string-capitalize "foo bar")</td>
<td></td>
<td></td>
<td><span style="color: gray">; "Foo Bar":</span><br />
(capitalize "foo")</td>
</tr>
<tr>
<td><a href="#string-trim">trim</a></td>
<td>(string-trim<br />
<span style="white-space: pre-wrap;">  </span>'(#\space #\tab #\newline)<br />
<span style="white-space: pre-wrap;">  </span>" foo ")</td>
<td>(require srfi/13/string)<br />
(string-trim-both " foo ")</td>
<td>(.trim " foo ")</td>
<td><span style="color: gray"><em>none; see notes for an implementation</em></span></td>
</tr>
<tr>
<td><a name="pad" id="pad"></a><a href="#pad-note">pad</a><br />
<span style="color: gray"><em>on right, on left</em></span></td>
<td>(format nil "~10a" "foo")<br />
(format nil "~10@a" "foo")</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="num-to-str" id="num-to-str"></a><a href="#num-to-str-note">number to string</a></td>
<td>(concatenate 'string<br />
<span style="white-space: pre-wrap;">  </span>"value: "<br />
<span style="white-space: pre-wrap;">  </span>(princ-to-string 8))</td>
<td>(string-append<br />
<span style="white-space: pre-wrap;">  </span>"value: "<br />
<span style="white-space: pre-wrap;">  </span>(number-&gt;string 8))</td>
<td>(str "Value: " 8)</td>
<td>(concat<br />
<span style="white-space: pre-wrap;">  </span>"value: "<br />
<span style="white-space: pre-wrap;">  </span>(number-to-string 8))</td>
</tr>
<tr>
<td><a name="str-to-num" id="str-to-num"></a><a href="#str-to-num-note">string to number</a></td>
<td>(+ 7 (parse-integer "12"))<br />
<span style="white-space: pre-wrap;"> </span><br />
(+ 73.9 (read-from-string ".037"))</td>
<td>(+ 7 (string-&gt;number "12"))<br />
<span style="white-space: pre-wrap;"> </span><br />
(+ 73.9 (string-&gt;number ".037"))</td>
<td>(+ 7 (Integer/parseInt "12"))<br />
<span style="white-space: pre-wrap;"> </span><br />
(+ 73.9 (Float/parseFloat ".037"))</td>
<td>(+ 7 (string-to-number "12"))<br />
<span style="white-space: pre-wrap;"> </span><br />
(+ 73.9 (string-to-number ".037"))</td>
</tr>
<tr>
<td><a name="split" id="split"></a><a href="#split-note">split</a></td>
<td>(cl-ppcre:split<br />
<span style="white-space: pre-wrap;">  </span>"[ \t\n]+"<br />
<span style="white-space: pre-wrap;">  </span>"foo bar baz")</td>
<td>(regexp-split #rx"[ \n\t]+"<br />
<span style="white-space: pre-wrap;">  </span>"foo bar baz")</td>
<td>(seq<br />
<span style="white-space: pre-wrap;">  </span>(.split "foo bar baz"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"[ \t\n]+"))</td>
<td>(split-string "foo bar baz")</td>
</tr>
<tr>
<td><a name="str-join" id="str-join"></a><a href="#str-join-note">string join</a></td>
<td>(reduce<br />
<span style="white-space: pre-wrap;">  </span>(lambda (m o)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(concatenate 'string m " " o))<br />
<span style="white-space: pre-wrap;">  </span>'("foo" "bar" "baz"))</td>
<td>(string-join<br />
<span style="white-space: pre-wrap;">  </span>'("foo" "bar" "baz")<br />
<span style="white-space: pre-wrap;">  </span>" ")</td>
<td>(reduce #(str %1 " " %2)<br />
<span style="white-space: pre-wrap;">  </span>'("foo" "bar" "baz"))</td>
<td>(reduce<br />
<span style="white-space: pre-wrap;">  </span>(lambda (m o) (concat m " " o))<br />
<span style="white-space: pre-wrap;">  </span>'("foo" "bar" "baz"))</td>
</tr>
<tr>
<td><a name="str-len" id="str-len"></a><a href="#str-len-note">length</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(length "foo")</td>
<td>(string-length "foo")</td>
<td>(.length "foo")</td>
<td>(length "foo")</td>
</tr>
<tr>
<td><a name="index-substr" id="index-substr"></a><a href="#index-substr-note">index of substring</a></td>
<td>(search "bar" "foo bar")</td>
<td><span style="color: gray"><em>racket:</em></span><br />
(require srfi/13/string)<br />
(string-contains "foo bar" "bar")</td>
<td>(.indexOf "foo bar" "bar")</td>
<td>(search "bar" "foo bar")</td>
</tr>
<tr>
<td><a name="extract-substr" id="extract-substr"></a><a href="#extract-substr-note">extract substring</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(subseq "foo bar" 4 7)</td>
<td>(substring "foo bar" 4 7)</td>
<td>(.substring "foo bar" 4 7)</td>
<td>(substring "foo bar" 4 7)</td>
</tr>
<tr>
<td><a name="char-literal" id="char-literal"></a><a href="#char-literal-note">character literal</a></td>
<td>#\a #\space #\newline #\backspace #\tab #\linefeed #\page #\return #\rubout</td>
<td>#\a #\space #\newline #\backspace #\tab #\linefeed #\page #\return #\nul #\vtab #\alarm #\esc #\delete<br />
<span style="color: gray"><em>not in racket:</em> #\alarm #\esc #\delete</span></td>
<td>\a \newline \space \backspace \tab <span style="color: gray"><em>?</em></span> \formfeed \return <span style="color: gray"><em>?</em></span></td>
<td>?a ?\b ?\t ?\n ?\f ?\r ?\" ?\\ ?\<span style="color: gray"><em>ooo</em></span> ?\u<span style="color: gray"><em>hhhh</em></span> ?\x<span style="color: gray"><em>h</em></span> - ?\x<span style="color: gray"><em>hhhhhh</em></span> ?\C-<span style="color: gray"><em>x</em></span> ?\M-<span style="color: gray"><em>x</em></span></td>
</tr>
<tr>
<td><a name="char-test" id="char-test"></a><a href="#char-test-note">test characters</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(characterp #\x)<br />
(alpha-char-p #\x)<br />
(alphanumericp #\x)<br />
(digit-char-p #\7)<br />
(lower-case-p #\x)<br />
(upper-case-p #\X)</td>
<td>(char? #\x)</td>
<td>(char? \x)</td>
<td>(characterp ?x)</td>
</tr>
<tr>
<td><a name="chr-ord" id="chr-ord"></a><a href="#chr-ord-note">chr and ord</a></td>
<td>(code-char 97)<br />
(char-code #\a)</td>
<td>(integer-&gt;char 97)<br />
(char-&gt;integer #\a)</td>
<td>(char 97)<br />
(int \a)</td>
<td></td>
</tr>
<tr>
<td><a name="str-to-char-array" id="str-to-char-array"></a><a href="#str-to-char-array-note">to array of characters</a></td>
<td></td>
<td><span style="color: gray">; list:</span><br />
(string-&gt;list "foo")</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="lookup-char" id="lookup-char"></a><a href="#lookup-char-note">character lookup</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(char "foo" 0)</td>
<td>(string-ref "foo" 0)</td>
<td>(.charAt "foo" 0)</td>
<td>(aref "foo" 0)</td>
</tr>
<tr>
<th colspan="5"><a name="regexes" id="regexes"></a><a href="#regexes-note">regular expressions</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="regex-literal" id="regex-literal"></a><a href="#regex-literal-note">literal</a></td>
<td><span style="color: gray"><em>use a string:</em></span><br />
"\\b\\d{5}\\b"</td>
<td><span style="color: gray"><em>posix extended:</em></span><br />
#rx"^[0-9][0-9][0-9][0-9][0-9]$"<br />
(regexp "^[0-9][0-9][0-9][0-9][0-9]$")<br />
<br />
<span style="color: gray"><em>perl style:</em></span><br />
#px"\\b\\d{5}\\b"<br />
(pregexp "\\b\\d{5}\\b")</td>
<td>#"\b\d{5}\b"</td>
<td></td>
</tr>
<tr>
<td><a name="char-class-abbrev" id="char-class-abbrev"></a><a href="#char-class-abbrev-note">character class abbrevations</a></td>
<td>. \d \D \s \S \w \W</td>
<td><span style="color: gray"><em>regexp:</em></span><br />
.<br />
<br />
<span style="color: gray"><em>pregexp:</em></span><br />
. \d \D \s \S \w \W</td>
<td>. \d \D \s \S \w \W</td>
<td>. \w \W \ca \cl \cg \Ca \Cl \Cg \s<span style="color: gray"><em>x</em></span><br />
<br />
<span style="color: gray">\ca \cl <em>and</em> \cg <em>match ASCII, Latin, and Greek characters.</em></span><br />
<br />
<span style="color: gray"><em>Character classes of the form</em> \sx <em>depend on the current syntax table.</em></span></td>
</tr>
<tr>
<td><a name="regex-anchors" id="regex-anchors"></a><a href="#regex-anchors-note">anchors</a></td>
<td>^ $ \b \B</td>
<td><span style="color: gray"><em>regexp:</em></span><br />
^ $<br />
<br />
<span style="color: gray"><em>pregexp:</em></span><br />
^ $ \b \B</td>
<td>^ $ \A \b \B \G \z \Z</td>
<td>^ $ \b \B</td>
</tr>
<tr>
<td><a name="regex-test" id="regex-test"></a><a href="#regex-test-note">match test</a></td>
<td>(ql:quickload "cl-ppcre")<br />
<br />
(if (cl-ppcre:all-matches "1999" s)<br />
<span style="white-space: pre-wrap;">  </span>(format t "party!"))</td>
<td>(regexp-match #rx"bar" "foo bar")</td>
<td>(re-find #"bar" "foo bar")</td>
<td>(string-match "bar" "foo bar")</td>
</tr>
<tr>
<td><a name="case-insensitive-regex" id="case-insensitive-regex"></a><a href="#case-insensitive-regex-note">case insensitive match test</a></td>
<td></td>
<td>(regexp-match #px"(?i:lorem)" "Lorem")</td>
<td>(re-find #"(?i:lorem)" "Lorem")</td>
<td></td>
</tr>
<tr>
<td><a name="subst" id="subst"></a><a href="#subst-note">substitution</a></td>
<td>(cl-ppcre:regex-replace "[^l]l"<br />
<span style="white-space: pre-wrap;">  </span>"hello"<br />
<span style="white-space: pre-wrap;">  </span>"EL")<br />
<span style="white-space: pre-wrap;"> </span><br />
(cl-ppcre:regex-replace-all "[^l]l"<br />
<span style="white-space: pre-wrap;">  </span>"hello hello"<br />
<span style="white-space: pre-wrap;">  </span>"EL")</td>
<td>(regexp-replace #rx"el"<br />
<span style="white-space: pre-wrap;">  </span>"hello"<br />
<span style="white-space: pre-wrap;">  </span>"EL")<br />
<span style="white-space: pre-wrap;"> </span><br />
(regexp-replace* #rx"el"<br />
<span style="white-space: pre-wrap;">  </span>"hello hello"<br />
<span style="white-space: pre-wrap;">  </span>"EL")</td>
<td>(.replaceFirst "hello" "[^l]l" "XX")<br />
<span style="white-space: pre-wrap;"> </span><br />
(.replaceAll "hello hello"<br />
<span style="white-space: pre-wrap;">  </span>"[^l]l" "XX")</td>
<td><span style="color: gray"><em>?</em></span><br />
<span style="white-space: pre-wrap;"> </span><br />
(replace-regexp-in-string "[^l]l"<br />
<span style="white-space: pre-wrap;">  </span>"EL"<br />
<span style="white-space: pre-wrap;">  </span>"hello hello")</td>
</tr>
<tr>
<td><a name="group-capture" id="group-capture"></a><a href="#group-capture-note">group capture</a></td>
<td></td>
<td>(match (regexp-match<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>#px"(\\d{4})-(\\d{2})-(\\d{2})"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"2010-06-03")<br />
<span style="white-space: pre-wrap;">  </span>[(list s yr mn dy) (list yr mn dy)])</td>
<td>(let [[_ yr mn dy]<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(re-find #"(\d{4})-(\d{2})-(\d{2})"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"2010-06-03")]<br />
<span style="white-space: pre-wrap;">  </span>yr)</td>
<td></td>
</tr>
<tr>
<td><a name="scan" id="scan"></a><a href="#scan-note">scan</a></td>
<td></td>
<td></td>
<td>(re-seq #"\w+" "dolor sit amet")</td>
<td></td>
</tr>
<tr>
<td><a name="backreference" id="backreference"></a><a href="#backreference-note">backreference in match and substitution</a></td>
<td></td>
<td>(regexp-match #px"(\\w+) \\1" "do do")<br />
<br />
(regexp-replace #px"(\\w+) (\\w+)"<br />
<span style="white-space: pre-wrap;">  </span>"do re"<br />
<span style="white-space: pre-wrap;">  </span>"\\2 \\1")</td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="dates-time" id="dates-time"></a><a href="#dates-time-note">dates and time</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="broken-down-datetime-type" id="broken-down-datetime-type"></a><a href="#broken-down-datetime-type-note">broken-down datetime type</a></td>
<td><span style="color: gray"><em>No dedicated type; a list of 9 values is used:</em><br />
<br />
<span style="white-space: pre-wrap;">  </span>second: 0-59<br />
<span style="white-space: pre-wrap;">  </span>minute: 0-59<br />
<span style="white-space: pre-wrap;">  </span>hour: 0-23<br />
<span style="white-space: pre-wrap;">  </span>day of month: 1-31<br />
<span style="white-space: pre-wrap;">  </span>month: 1-12<br />
<span style="white-space: pre-wrap;">  </span>year: 4 digits<br />
<span style="white-space: pre-wrap;">  </span>day of week: 0-6 for Mon-Sun<br />
<span style="white-space: pre-wrap;">  </span>is daylight savings time: t or nil<br />
<span style="white-space: pre-wrap;">  </span>timezone: negated UTC offset in hours</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="current-datetime" id="current-datetime"></a><a href="#current-datetime-note">current datetime</a></td>
<td>(get-decoded-time)</td>
<td>(require racket/date)<br />
<br />
(current-date)</td>
<td>(def dt (new java.util.Date))</td>
<td>(current-time)</td>
</tr>
<tr>
<td><a name="current-unix-epoch" id="current-unix-epoch"></a><a href="#current-unix-epoch-note">current unix epoch</a></td>
<td>gray|; seconds since Jan 1, 1900:##<br />
(get-universal-time)</td>
<td>(current-seconds)</td>
<td>(/ (System/currentTimeMillis) 1000.0)</td>
<td>(float-time)</td>
</tr>
<tr>
<td><a name="unix-epoch-to-broken-down-datetime" id="unix-epoch-to-broken-down-datetime"></a><a href="#unix-epoch-to-broken-down-datetime-note">unix epoch to broken-down datetime</a></td>
<td>(decode-universal-time<br />
<span style="white-space: pre-wrap;">  </span>(get-unversal-time))</td>
<td>(seconds-&gt;date (current-seconds))</td>
<td>(def dt (new java.util.Date<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(System/currentTimeMillis)))</td>
<td>(seconds-to-time (float-time))</td>
</tr>
<tr>
<td><a name="broken-down-datetime-to-unix-epoch" id="broken-down-datetime-to-unix-epoch"></a><a href="#broken-down-datetime-to-unix-epoch-note">broken-down datetime to unix epoch</a></td>
<td>(encode-universal-time 0 22 10 31 5 2015)</td>
<td>(require racket/date)<br />
<br />
(date-&gt;seconds (current-date))</td>
<td>(/ (.getTime (new java.util.Date)) 1000.0)</td>
<td>(multiple-value-bind (b s)<br />
<span style="white-space: pre-wrap;">  </span>(current-time)<br />
<span style="white-space: pre-wrap;">  </span>(+ (* b (expt 2 16)) s))</td>
</tr>
<tr>
<td><a name="fmt-datetime" id="fmt-datetime"></a><a href="#fmt-datetime-note">format datetime</a></td>
<td></td>
<td></td>
<td>(def s "yyyy-MM-dd HH:mm:ss")<br />
(def fmt (new java.text.SimpleDateFormat s))<br />
<br />
(.format fmt (new java.util.Date))</td>
<td>(format-time-string<br />
<span style="white-space: pre-wrap;">  </span>"%Y-%m-%d %H:%M:%S"<br />
<span style="white-space: pre-wrap;">  </span>(current-time))</td>
</tr>
<tr>
<td><a name="parse-datetime" id="parse-datetime"></a><a href="#parse-datetime-note">parse datetime</a></td>
<td></td>
<td>(require (prefix-in s19. srfi/19))<br />
<br />
(define (date-str-&gt;unix-time s fmt)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(s19.time-second<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(s19.date-&gt;time-utc<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(s19.string-&gt;date s fmt))))<br />
<br />
(date-str-&gt;unix-time<br />
<span style="white-space: pre-wrap;">  </span>"2015-05-31 07:06:00"<br />
<span style="white-space: pre-wrap;">  </span>"~Y-~m-~d ~H:~M:~S")</td>
<td>(def s "yyyy-MM-dd HH:mm:ss")<br />
(def fmt (new java.text.SimpleDateFormat s))<br />
<br />
(.parse fmt "2015-05-30 09:14:14")</td>
<td></td>
</tr>
<tr>
<td><a name="datet-parts" id="datet-parts"></a><a href="#date-parts-note">date parts</a></td>
<td>(multiple-value-bind<br />
<span style="white-space: pre-wrap;">  </span>(ss mi hr dy mo yr)<br />
<span style="white-space: pre-wrap;">  </span>(get-decoded-time)<br />
<span style="white-space: pre-wrap;">  </span>(list ss mi hr) <span style="color: gray">; quiesce warning</span><br />
<span style="white-space: pre-wrap;">  </span>(list dy mo yr))</td>
<td>(date-year (current-date))<br />
(date-month (current-date))<br />
(date-day (current-date))</td>
<td>(def cal (new java.util.GregorianCalendar))<br />
(.setTime cal dt)<br />
<br />
(.get cal java.util.Calendar/DAY_OF_MONTH)<br />
(+ (.get cal java.util.Calendar/MONTH) 1)<br />
(.get cal java.util.Calendar/YEAR)</td>
<td>(multiple-value-bind<br />
<span style="white-space: pre-wrap;">  </span>(ss mi hr dy mo yr)<br />
<span style="white-space: pre-wrap;">  </span> (decode-time (current-time))<br />
<span style="white-space: pre-wrap;">  </span>(list dy mo yr))</td>
</tr>
<tr>
<td><a name="time-parts" id="time-parts"></a><a href="#time-parts-note">time parts</a></td>
<td>(multiple-value-bind<br />
<span style="white-space: pre-wrap;">  </span>(ss mi hr)<br />
<span style="white-space: pre-wrap;">  </span>(get-decoded-time)<br />
<span style="white-space: pre-wrap;">  </span>(list ss mi hr))</td>
<td>(date-hour (current-date))<br />
(date-minute (current-date))<br />
(date-second (current-date))</td>
<td>(def cal (new java.util.GregorianCalendar))<br />
(.setTime cal dt)<br />
<br />
(.get cal java.util.Calendar/HOUR_OF_DAY)<br />
(.get cal java.util.Calendar/MINUTE)<br />
(.get cal java.util.Calendar/SECOND)</td>
<td>(multiple-value-bind<br />
<span style="white-space: pre-wrap;">  </span>(ss mi hr dy mo yr)<br />
<span style="white-space: pre-wrap;">  </span> (decode-time (current-time))<br />
<span style="white-space: pre-wrap;">  </span>(list ss mi hr))</td>
</tr>
<tr>
<td><a name="build-datetime" id="build-datetime"></a><a href="#build-datetime-note">build broken-down datetime</a></td>
<td>(encode-universal-time 0 22 10 31 5 2015)</td>
<td></td>
<td>(let<br />
<span style="white-space: pre-wrap;">  </span>[yr 2015 mo 5 dy 31 hr 10 mi 22 ss 0]<br />
<span style="white-space: pre-wrap;">  </span>(def cal<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(new java.util.GregorianCalendar<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>yr (- mo 1) dy hr mi ss)))</td>
<td>(encode-time 0 50 8 31 5 2015)</td>
</tr>
<tr>
<th colspan="5"><a name="lists" id="lists"></a><a href="#lists-note">lists</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a href="#list-literal">literal</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>'(1 2 3)<br />
(quote (1 2 3))</td>
<td>'(1 2 3)<br />
'[1 2 3]<br />
'{1 2 3}<br />
(quote (1 2 3))</td>
<td>'(1 2 3)<br />
(quote (1 2 3))</td>
<td>'(1 2 3)<br />
(quote (1 2 3))</td>
</tr>
<tr>
<td>constructor<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(list 1 2 3)</td>
<td>(list 1 2 3)</td>
<td>(list 1 2 3)</td>
<td>(list 1 2 3)</td>
</tr>
<tr>
<td>predicate<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(listp '(1 2 3))</td>
<td>(list? '(1 2 3))</td>
<td>(list? '(1 2 3))</td>
<td>(listp '(1 2 3))</td>
</tr>
<tr>
<td>empty test</td>
<td><span style="color: gray">nil <em>and</em> '() <em>are synonyms and evaluate as false in a boolean context. All other values are true.</em></span></td>
<td>(empty? '())</td>
<td>(empty? ())</td>
<td><span style="color: gray">nil <em>and</em> '() <em>are synonyms and evaluate as false in a boolean context. All other values are true.</em></span></td>
</tr>
<tr>
<td>evaluating the empty list</td>
<td>nil</td>
<td><span style="color: gray"><em>error</em></span></td>
<td>()</td>
<td>nil</td>
</tr>
<tr>
<td><a href="#cons">cons</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(cons 1 '(2 3))</td>
<td>(cons 1 '(2 3))</td>
<td>(cons 1 '(2 3))</td>
<td>(cons 1 '(2 3))</td>
</tr>
<tr>
<td>head<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(car '(1 2 3))<br />
(first '(1 2 3))</td>
<td>(car '(1 2 3))<br />
(first '(1 2 3))</td>
<td>first</td>
<td>car</td>
</tr>
<tr>
<td>tail<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(cdr '(1 2 3))<br />
(rest '(1 2 3))</td>
<td>(cdr '(1 2 3))<br />
(rest '(1 2 3))</td>
<td>(rest '(1 2 3))<br />
(next '(1 2 3))</td>
<td>(cdr '(1 2 3))<br />
(rest '(1 2 3))</td>
</tr>
<tr>
<td>head and tail of empty list</td>
<td><span style="color: gray"><em>both evaluate to</em> nil</span></td>
<td><span style="color: gray"><em>error</em></span></td>
<td>()</td>
<td><span style="color: gray"><em>both evaluate to</em> nil</span></td>
</tr>
<tr>
<td>length<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(length '(1 2 3))</td>
<td>(length '(1 2 3))</td>
<td>(count '(1 2 3))</td>
<td>(length '(1 2 3))</td>
</tr>
<tr>
<td>equality test<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(equal '(1 2 3) '(1 2 3))</td>
<td>(equal? '(1 2 3) '(1 2 3))</td>
<td>(= '(1 2 3) '(1 2 3))</td>
<td>(equal '(1 2 3) '(1 2 3))</td>
</tr>
<tr>
<td>nth element</td>
<td><span style="color: gray">; indexed from zero:</span><br />
(nth 2 '(1 2 3 4))</td>
<td>(list-ref '(1 2 3 4) 2)</td>
<td>(nth '(1 2 3 4) 2)</td>
<td>(nth 2 '(1 2 3 4))</td>
</tr>
<tr>
<td>out-of-bounds behavior</td>
<td>nil</td>
<td><span style="color: gray"><em>error</em></span></td>
<td><span style="color: gray"><em>raises</em> IndexOutOfBoundsException</span></td>
<td>nil</td>
</tr>
<tr>
<td>element index</td>
<td>(position 7 '(5 6 7 8))</td>
<td>(require srfi/1)<br />
<br />
(list-index (lambda (x) (= x 7)) '(5 6 7 8))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(position 7 '(5 6 7 8))</td>
</tr>
<tr>
<td>concatenate<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(append '(1 2 3) '(4 5 6))</td>
<td>(append '(1 2 3) '(4 5 6))</td>
<td>(concat '(1 2 3) '(4 5 6))</td>
<td>(append '(1 2 3) '(4 5 6))</td>
</tr>
<tr>
<td><a href="#take">take</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(take '(1 2 3 4) 2)</td>
<td>(take 2 '(1 2 3 4))</td>
<td>(subseq '(1 2 3 4) 0 2)</td>
</tr>
<tr>
<td><a href="#drop">drop</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(nthcdr 2 '(1 2 3 4))</td>
<td>(drop '(1 2 3 4) 2)</td>
<td>(drop 2 '(1 2 3 4))</td>
<td>(nthcdr 2 '(1 2 3 4))</td>
</tr>
<tr>
<td>last element<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(car (last '(1 2 3)))</td>
<td>(last '(1 2 3))</td>
<td>(last '(1 2 3))</td>
<td>(car (last '(1 2 3)))</td>
</tr>
<tr>
<td>all but last element</td>
<td>(butlast '(1 2 3))</td>
<td>(define a '(1 2 3))<br />
(take a (- (length a) 1))</td>
<td>(butlast '(1 2 3))</td>
<td>(butlast '(1 2 3))</td>
</tr>
<tr>
<td>reverse<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(reverse '(1 2 3))</td>
<td>(reverse '(1 2 3))</td>
<td>(reverse '(1 2 3))</td>
<td>(reverse '(1 2 3))</td>
</tr>
<tr>
<td><a href="#sort">sort</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(sort '(3 2 4 1) '&lt;)</td>
<td>(sort '(3 2 4 1) &lt;)</td>
<td>(sort &lt; '(3 2 4 1))</td>
<td>(sort '(3 2 4 1) '&lt;)</td>
</tr>
<tr>
<td>dedupe<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(remove-duplicates '(1 1 2 3))</td>
<td>(remove-duplicates '(1 1 2 3))</td>
<td></td>
<td>(remove-duplicates '(1 1 2 3))</td>
</tr>
<tr>
<td>membership<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(member 7 '(1 2 3))</td>
<td>(member 7 '(1 2 3))</td>
<td></td>
<td>(member 7 '(1 2 3)</td>
</tr>
<tr>
<td><a href="#map">map</a></td>
<td>(mapcar<br />
<span style="white-space: pre-wrap;">  </span>(lambda (x) (* x x))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3))</td>
<td>(map (lambda (x) (* x x)) '(1 2 3))</td>
<td>(map #(* % %) '(1 2 3))</td>
<td>(mapcar<br />
<span style="white-space: pre-wrap;">  </span>(lambda (x) (* x x))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3))</td>
</tr>
<tr>
<td><a href="#filter">filter</a></td>
<td>(remove-if-not<br />
<span style="white-space: pre-wrap;">  </span>(lambda (x) (&gt; x 2))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3))<br />
<br />
<span style="color: gray">; remove-if returns complement</span></td>
<td>(filter<br />
<span style="white-space: pre-wrap;">  </span>(lambda (x) (&gt; x 2))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3))<br />
<br />
<span style="color: gray">; filter-not returns complement</span></td>
<td>(filter #(&gt; % 2) '(1 2 3))<br />
<br />
<span style="color: gray">; remove returns complement</span></td>
<td>(remove-if-not<br />
<span style="white-space: pre-wrap;">  </span>(lambda (x) (&gt; x 2))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3))<br />
<br />
<span style="color: gray">; remove-if returns complement</span></td>
</tr>
<tr>
<td><a href="#reduce">reduce</a></td>
<td>(reduce '-<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3 4)<br />
<span style="white-space: pre-wrap;">  </span>:initial-value 0)</td>
<td>(foldl (lambda (x y) (- y x)) 0 '(1 2 3 4))</td>
<td>(reduce - 0 '(1 2 3 4))</td>
<td>(reduce '-<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3 4)<br />
<span style="white-space: pre-wrap;">  </span>:initial-value 0)</td>
</tr>
<tr>
<td><a href="#right-fold">right fold</a></td>
<td>(reduce '-<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3 4)<br />
<span style="white-space: pre-wrap;">  </span>:initial-value 0<br />
<span style="white-space: pre-wrap;">  </span>:from-end t)</td>
<td>(foldr - 0 '(1 2 3 4))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(reduce '-<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3 4)<br />
<span style="white-space: pre-wrap;">  </span>:initial-value 0<br />
<span style="white-space: pre-wrap;">  </span>:from-end t)</td>
</tr>
<tr>
<td>iterate</td>
<td>(dolist (x '(1 2 3))<br />
<span style="white-space: pre-wrap;">  </span>(print x)<br />
<span style="white-space: pre-wrap;">  </span>(print (- x)))</td>
<td>(for ((x '(1 2 3)))<br />
<span style="white-space: pre-wrap;">  </span>(printf "~a~n" x)<br />
<span style="white-space: pre-wrap;">  </span>(printf "~a~n" (- x)))</td>
<td>(doseq [x '(1 2 3)]<br />
<span style="white-space: pre-wrap;">  </span>(println x)<br />
<span style="white-space: pre-wrap;">  </span>(println (- x)))</td>
<td>(dolist (x '(1 2 3))<br />
<span style="white-space: pre-wrap;">  </span>(print x)<br />
<span style="white-space: pre-wrap;">  </span>(print (- x)))</td>
</tr>
<tr>
<td><a href="#universal-predicate">universal predicate</a></td>
<td>(every<br />
<span style="white-space: pre-wrap;">  </span>(lambda (i) (= 0 (rem i 2)))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3 4))</td>
<td>(for/and ((i '(1 2 3 4)))<br />
<span style="white-space: pre-wrap;">  </span>(= 0 (remainder i 2)))</td>
<td>(every? #(= 0 (rem % 2)) '(1 2 3 4))</td>
<td>(every<br />
<span style="white-space: pre-wrap;">  </span>(lambda (i) (= 0 (% i 2)))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3 4))</td>
</tr>
<tr>
<td><a href="#existential-predicate">existential predicate</a></td>
<td>(some<br />
<span style="white-space: pre-wrap;">  </span>(lambda (i) (= 0 (rem i 2)))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3 4))</td>
<td>(for/or ((i '(1 2 3 4)))<br />
<span style="white-space: pre-wrap;">  </span>(= 0 (remainder i 2)))</td>
<td>(some #(= 0 (rem % 2)) '(1 2 3 4))</td>
<td>(some<br />
<span style="white-space: pre-wrap;">  </span>(lambda (i) (= 0 (% i 2)))<br />
<span style="white-space: pre-wrap;">  </span>'(1 2 3 4))</td>
</tr>
<tr>
<td>list comprehension</td>
<td></td>
<td>(for*/list<br />
<span style="white-space: pre-wrap;">  </span>((file "ABCDEFGH") (rank (in-range 1 9)))<br />
<span style="white-space: pre-wrap;">  </span>(format "~a~a" file rank))</td>
<td>(for<br />
<span style="white-space: pre-wrap;">  </span>[file "ABCDEFGH" rank (range 1 9)]<br />
<span style="white-space: pre-wrap;">  </span>(format "%c%d" file rank))</td>
<td></td>
</tr>
<tr>
<td>shuffle<br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td>(shuffle '(1 2 3 4))</td>
<td>(shuffle '(1 2 3 4))</td>
<td></td>
</tr>
<tr>
<td>set head</td>
<td>(defparameter *a* '(1 2 3))<br />
(setf (car *a*) 3)</td>
<td>(require schema/mpair)<br />
<br />
(define a (mlist 1 2 3))<br />
(set-mcar! a 3)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(setq a '(1 2 3)<br />
(setcar a 3)</td>
</tr>
<tr>
<td>set tail</td>
<td>(defparameter *a* '(1 2 3))<br />
(setf (cdr *a*) '(4 5 6))</td>
<td>(require schema/mpair)<br />
<br />
(define a (mlist 1 2 3))<br />
(set-mcdr! a (mlist 4 5 6))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(setq a '(1 2 3)<br />
(setcar a 3)<br />
(setcdr a '(4 5 6))</td>
</tr>
<tr>
<td>manipulate back</td>
<td>(defparameter *a* '(1 2 3))<br />
(push 4 *a*)<br />
(pop *a*)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td></td>
<td>(setq a '(1 2 3))<br />
(push 4 a)<br />
(pop a)</td>
</tr>
<tr>
<td>flatten</td>
<td></td>
<td>(flatten '(1 2 (3 (4))))</td>
<td>(flatten '(1 2 (3 (4))))</td>
<td></td>
</tr>
<tr>
<td>associative array lookup<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(assoc 3 '((1 2) (3 4)))</td>
<td>(assoc 3 '((1 2) (3 4)))</td>
<td><span style="color: gray"><em>none, see note</em></span></td>
<td>(assoc 3 '((1 2) (3 4)))</td>
</tr>
<tr>
<td>flat associative array lookup<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(getf '(1 2 3 4) 3)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(getf '(1 2 3 4) 3)</td>
</tr>
<tr>
<td><a href="#pair-literal">pair literal</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>'(1 . 2)</td>
<td>'(1 . 2)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>'(1 . 2)</td>
</tr>
<tr>
<td>cons cell test</td>
<td>(cons '(1 . 2))<br />
(not (atom '(1 . 2)))</td>
<td>(cons? '(1 . 2))<br />
(pair? '(1 . 2))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(cons '(1 . 2))<br />
(not (atom '(1 . 2)))</td>
</tr>
<tr>
<td>translate elements recursively</td>
<td>(sublis '((1 . 2) (3 . 4))<br />
<span style="white-space: pre-wrap;">  </span>'(1 (3 3 (1))))</td>
<td></td>
<td></td>
<td>(sublis '((1 . 2) (3 . 4))<br />
<span style="white-space: pre-wrap;">  </span>'(1 (3 3 (1))))</td>
</tr>
<tr>
<th colspan="5"><a name="fixed-length-arrays" id="fixed-length-arrays"></a><a href="#fixed-length-arrays-note">fixed-length arrays</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="fixed-len-array-literal" id="fixed-len-array-literal"></a><a href="#fixed-len-array-literal-note">literal</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>#(1 2 3)</td>
<td>#(1 2 3)</td>
<td>[1 2 3]</td>
<td>[1 2 3]</td>
</tr>
<tr>
<td>constructor<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(vector 1 2 3)</td>
<td>(vector 1 2 3)</td>
<td>(vector 1 2 3)</td>
<td>(vector 1 2 3)</td>
</tr>
<tr>
<td>size<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(length #(1 2 3))</td>
<td>(vector-length #(1 2 3))</td>
<td>(count [1 2 3])</td>
<td>(length [1 2 3])</td>
</tr>
<tr>
<td>lookup</td>
<td>(elt #(1 2 3) 0) <span style="color: gray"><em>or</em></span><br />
(aref #(1 2 3) 0)</td>
<td>(vector-ref #(1 2 3) 0)</td>
<td>(nth [1 2 3] 0)</td>
<td>(elt [1 2 3] 0)</td>
</tr>
<tr>
<td>update</td>
<td>(setq v [1 2 3])<br />
(setf (aref v 2) 4)</td>
<td>(define v (vector 1 2 3))<br />
(vector-set! v 2 4)</td>
<td>(replace {2 4} [1 2 3])</td>
<td>(setq v #(1 2 3))<br />
(setf (aref v 2) 4)</td>
</tr>
<tr>
<td>out-of-bounds behavior</td>
<td><span style="color: gray"><em>raises</em> sb-kernel:index-too-large-error</span></td>
<td><span style="color: gray"><em>error</em></span></td>
<td></td>
<td></td>
</tr>
<tr>
<td>array to list<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(coerce #(1 2 3) 'list)</td>
<td>(vector-&gt;list #(1 2 3))</td>
<td>(seq [1 2 3])</td>
<td>(coerce [1 2 3] 'list)</td>
</tr>
<tr>
<td>list to array<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(coerce '(1 2 3) 'vector)</td>
<td>(list-&gt;vector '(1 2 3))</td>
<td>(vec '(1 2 3))</td>
<td>(coerce '(1 2 3) 'vector)</td>
</tr>
<tr>
<td>reverse</td>
<td>(reverse #(1 2 3))</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>sort</td>
<td>(sort #(2 4 1 3) #'&lt;)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>map</td>
<td>(map 'vector (lambda (x) (* x x)) #(1 2 3))</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>filter</td>
<td>(remove-if-not (lambda (x) (&gt; x 2)) #(1 2 3))<br />
<br />
<span style="color: gray">; also remove-if</span></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="dictionaries" id="dictionaries"></a><a href="#dictionaries-note">dictionaries</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="dict-literal" id="dict-literal"></a><a href="#dict-literal-note">literal</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray">; immutable:</span><br />
#hash(("t" . 1) ("f" . 0))</td>
<td><span style="color: gray">; clojure.lang.PersistentArrayMap:</span><br />
{"t" 1 "f" 0}</td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="dict-ctor" id="dict-ctor"></a><a href="#dict-ctor-note">constructor</a></td>
<td>(defparameter *h* (make-hash-table :test 'equal))<br />
<br />
<span style="color: gray">; default equality test is 'eql</span></td>
<td>(define ih<br />
<span style="white-space: pre-wrap;">  </span>(make-immutable-hash<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>'(("t" . 1) ("f" . 0))))<br />
<br />
<span style="color: gray">; mutable:</span><br />
(define h (make-hash '(("t" . 1) ("f" . 0))))</td>
<td><span style="color: gray">; immutable:</span><br />
(def ih (hash-map "t" 1 "f" 0))</td>
<td>(setq h (make-hash-table :test 'equal))</td>
</tr>
<tr>
<td><a name="dict-pred" id="dict-pred"></a><a href="#dict-pred-note">predicate</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(hash-table-p *h*)</td>
<td>(hash? h)<br />
<br />
<span style="color: gray">; also true of assoc. lists and vectors:</span><br />
(dict? h)</td>
<td>(map? ih)</td>
<td>(hash-table-p h)</td>
</tr>
<tr>
<td><a name="dict-size" id="dict-size"></a><a href="#dict-size-note">size</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(hash-table-count *h*)</td>
<td>(hash-count h)<br />
<br />
<span style="color: gray">; also works with assoc lists and vectors:</span><br />
(dict-count ih)</td>
<td>(count ih)</td>
<td>(hash-table-count h)</td>
</tr>
<tr>
<td><a name="dict-lookup" id="dict-lookup"></a><a href="#dict-lookup-note">lookup</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(gethash "t" *h*)</td>
<td>(hash-ref h "t")<br />
<br />
<span style="color: gray">; return -1 if not found:</span><br />
(hash-ref h "m" -1)<br />
<br />
<span style="color: gray">; also works with assoc. lists and vectors:</span><br />
(dict-ref ih "t")<br />
(dict-ref ih "m" -1)</td>
<td>(get ih "t")<br />
(find ih "t")<br />
<br />
<span style="color: gray">; return -1 if not found:</span><br />
(get ih "m" -1)</td>
<td>(gethash "t" h)</td>
</tr>
<tr>
<td><a name="dict-update" id="dict-update"></a><a href="#dict-update-note">update</a></td>
<td>(setf (gethash "t" *h*) 1)</td>
<td>(hash-set! h "t" 2)<br />
<br />
(define ih2 (hash-set ih "t" 2))<br />
<br />
<span style="color: gray">; also dict-set! and dict-set</span></td>
<td>(def ih2 (assoc ih "t" 2))</td>
<td>(puthash "t" 1 h)</td>
</tr>
<tr>
<td><a name="dict-missing-key" id="dict-missing-key"></a><a href="#dict-missing-key-note">missing key behavior</a></td>
<td><span style="color: gray"><em>returns</em> nil</span></td>
<td><span style="color: gray"><em>error</em></span></td>
<td><span style="color: gray"><em>returns</em> nil</span></td>
<td><span style="color: gray"><em>returns</em> nil</span></td>
</tr>
<tr>
<td><a name="dict-is-key-present" id="dict-is-key-present"></a><a href="#dict-is-key-present-note">is key present</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(nth-value 1 (gethash "t" *h*))</td>
<td>(hash-has-key? h "t")<br />
<br />
<span style="color: gray">; also dict-has-key?</span></td>
<td>(contains? ih "t")</td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a name="dict-dele" id="dict-dele"></a><a href="#dict-del-note">delete</a></td>
<td>(remhash "t" *h*)</td>
<td>(hash-remove! h "t")<br />
<span style="white-space: pre-wrap;"> </span><br />
(define ih2<br />
<span style="white-space: pre-wrap;">  </span>(hash-remove ih "t"))<br />
<br />
<span style="color: gray">; also dict-remove! and dict-remove</span></td>
<td>(def ih2 (dissoc ih "t"))</td>
<td>(remhash "hello" h)</td>
</tr>
<tr>
<td><a name="dict-merge" id="dict-merge"></a><a href="#dict-merge-note">merge</a></td>
<td></td>
<td></td>
<td><span style="color: gray">; values in ih2 take precedence:</span><br />
(define ih3 (merge ih ih2))</td>
<td></td>
</tr>
<tr>
<td><a name="dict-invert" id="dict-invert"></a><a href="#dict-invert-note">invert</a></td>
<td></td>
<td></td>
<td>(require 'clojure.set)<br />
<br />
(define ih4 (clojure.set/map-invert ih))</td>
<td></td>
</tr>
<tr>
<td><a name="dict-iter" id="dict-iter"></a><a href="#dict-iter-note">iterate</a></td>
<td>(maphash<br />
<span style="white-space: pre-wrap;">  </span>(lambda (k v)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(print k)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(print v))<br />
<span style="white-space: pre-wrap;">  </span>*h*)</td>
<td>(hash-for-each h<br />
<span style="white-space: pre-wrap;">  </span>(lambda (k v)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(printf "~a~n" k)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(printf "~a~n" v)))<br />
<br />
<span style="color: gray">; also dict-for-each</span></td>
<td>(doseq [p ih]<br />
<span style="white-space: pre-wrap;">  </span>(println (first p))<br />
<span style="white-space: pre-wrap;">  </span>(println (second p)))</td>
<td>(maphash<br />
<span style="white-space: pre-wrap;">  </span>(lambda (k v)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(print k)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(print v))<br />
<span style="white-space: pre-wrap;">  </span>h)</td>
</tr>
<tr>
<td><a name="dict-key-val-lists" id="dict-key-val-lists"></a><a href="#dict-key-val-lists-note">keys and values as lists</a></td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(hash-keys h)<br />
(hash-values h)<br />
<br />
<span style="color: gray">; also dict-keys and dict-values</span></td>
<td>(def hkeys (map (fn [p] (first p)) ih))<br />
(def hvals (map (fn [p] (second p)) ih))</td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<th colspan="5"><a name="user-defined-types" id="user-defined-types"></a><a href="#user-defined-types-note">user-defined types</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a href="#defstruct">defstruct</a></td>
<td>(defstruct account id balance)</td>
<td>(define-struct account (id (balance #:mutable)))</td>
<td>(defstruct account :id :balance)</td>
<td>(defstruct account id balance)</td>
</tr>
<tr>
<td><a href="#struct">struct</a></td>
<td>(setq a<br />
<span style="white-space: pre-wrap;">  </span>(make-account<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>:id 3<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>:balance 17.12))</td>
<td>(define a (make-account 3 17.12))</td>
<td>(def a (struct account 3 17.12))</td>
<td>(setq a<br />
<span style="white-space: pre-wrap;">  </span>(make-account :id 3 :balance 17.12))</td>
</tr>
<tr>
<td><a href="#struct-getter">struct getter</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(account-id a)</td>
<td>(account-id a)</td>
<td>(:id a)</td>
<td>(account-id a)</td>
</tr>
<tr>
<td><a href="#struct-setter">struct setter</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(setf (account-balance a) 0)</td>
<td>(set-account-balance! a 0)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(setf (account-balance a) 0)</td>
</tr>
<tr>
<td><a href="#struct-predicate">struct predicate</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(account-p a)</td>
<td>(account? a)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(account-p a)</td>
</tr>
<tr>
<th colspan="5"><a name="functions" id="functions"></a><a href="#functions-note">functions</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a href="#define-function">define function</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(defun add (x y) (+ x y))</td>
<td>(define (add x y) (+ x y))</td>
<td>(defn add [x y] (+ x y))</td>
<td>(defun add (x y) (+ x y))</td>
</tr>
<tr>
<td>can function and variable share name</td>
<td><span style="color: gray"><em>yes</em></span></td>
<td><span style="color: gray"><em>no</em></span></td>
<td><span style="color: gray"><em>no</em></span></td>
<td><span style="color: gray"><em>yes</em></span></td>
</tr>
<tr>
<td><a href="#optional-argument">optional argument</a></td>
<td>(defun add (a &amp;optional b)<br />
<span style="white-space: pre-wrap;">  </span>(if (null b) a (+ a b)))</td>
<td>(define (add a (b null))<br />
<span style="white-space: pre-wrap;">  </span>(if (null? b) a (+ a b)))</td>
<td>(defn add ([a] a) ([a b] (+ a b)))<br />
<span style="color: gray"><em>no syntax error if called with more than 2 args:</em></span><br />
(defn add [a &amp; [b]]<br />
<span style="white-space: pre-wrap;">  </span>(if (nil? b) a (+ a b)))</td>
<td>(defun add (a &amp;optional b)<br />
<span style="white-space: pre-wrap;">  </span>(if (null b) a (+ a b)))</td>
</tr>
<tr>
<td><a href="#variable-arguments">variable number of arguments</a></td>
<td>(defun add (a &amp;rest b)<br />
<span style="white-space: pre-wrap;">  </span>(if (null b)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>a<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(+ a (eval (cons '+ b)))))</td>
<td>(define (add a . b)<br />
<span style="white-space: pre-wrap;">  </span>(if (null? b)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>a<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(+ a (apply + b))))</td>
<td>(defn add [a &amp; b]<br />
<span style="white-space: pre-wrap;">  </span>(if (nil? b) a (+ a (apply + b))))</td>
<td>(defun add (a &amp;rest b)<br />
<span style="white-space: pre-wrap;">  </span>(if (null b)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>a<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(+ a (eval (cons '+ b)))))</td>
</tr>
<tr>
<td><a href="#default-value">default value</a></td>
<td>(defun add (a &amp;optional (b 0))<br />
<span style="white-space: pre-wrap;">  </span>(+ a b))</td>
<td><span style="color: gray"><em>racket:</em></span><br />
(define (add a (b 0)) (+ a b))</td>
<td>(defn add<br />
<span style="white-space: pre-wrap;">  </span>([a] (add a 0))<br />
<span style="white-space: pre-wrap;">  </span>([a b] (+ a b)))</td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a href="#named-parameter">named parameter</a></td>
<td>(defun logarithm (&amp;key number base)<br />
<span style="white-space: pre-wrap;">  </span>(/ (log number) (log base)))<br />
<span style="white-space: pre-wrap;"> </span><br />
(logarithm :base 2 :number 8)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(defn logarithm [{x :number b :base}] (/ (Math/log x) (Math/log b)))<br />
(logarithm {:base 2 :number 8})</td>
<td>(defun logarithm<br />
<span style="white-space: pre-wrap;">  </span>(&amp;key number &amp;key base)<br />
<span style="white-space: pre-wrap;">  </span>(if base<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(/ (log number) (log base))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(log number)))<br />
<span style="white-space: pre-wrap;"> </span><br />
<span style="color: gray"><em>order significant, not key names:</em></span><br />
(logarithm :foo 8 :bar 2)</td>
</tr>
<tr>
<td><a href="#return-multiple-values">return multiple values</a></td>
<td>(defun sqrts (x)<br />
<span style="white-space: pre-wrap;">  </span>(values (sqrt x) (- (sqrt x))))</td>
<td>(define (sqrts x)<br />
<span style="white-space: pre-wrap;">  </span>(values (sqrt x) (- (sqrt x))))</td>
<td>(defn sqrts [x] (list (Math/sqrt x) (- (Math/sqrt x))))</td>
<td><span style="color: gray">values <em>creates a list:</em></span><br />
(defun sqrts (x)<br />
<span style="white-space: pre-wrap;">  </span>(values (sqrt x) (- (sqrt x))))</td>
</tr>
<tr>
<td><a href="#multiple-values-local-variables">assign multiple values to local variables</a></td>
<td>(multiple-value-bind (r1 r2)<br />
<span style="white-space: pre-wrap;">  </span>(sqrts 3)<br />
<span style="white-space: pre-wrap;">  </span>r2)</td>
<td>(let-values<br />
<span style="white-space: pre-wrap;">  </span>(((r1 r2) (sqrts 3)))<br />
<span style="white-space: pre-wrap;">  </span>r2)</td>
<td>(let [[r1 r2] (sqrts 3)] r2)</td>
<td>(multiple-value-bind<br />
<span style="white-space: pre-wrap;">  </span>(r1 r2)<br />
<span style="white-space: pre-wrap;">  </span>(sqrts 3)<br />
<span style="white-space: pre-wrap;">  </span>r2)</td>
</tr>
<tr>
<td><a href="#multiple-values-global-variables">assign multiple values to global variables</a></td>
<td>(multiple-value-setq (r1 r2)<br />
<span style="white-space: pre-wrap;">  </span>(sqrts 3))</td>
<td>(define-values (r1 r2) (sqrts 3))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(multiple-value-setq (r1 r2) (sqrts 3))</td>
</tr>
<tr>
<td><a href="#list-to-multiple-values">convert list to multiple values</a></td>
<td>(values-list '(1 2 3))</td>
<td>(apply values '(1 2 3))</td>
<td><span style="color: gray"><em>multiple values are lists</em></span></td>
<td><span style="color: gray"><em>multiple values are lists</em></span></td>
</tr>
<tr>
<td><a href="#multiple-values-list">assign multiple values to list</a></td>
<td>(multiple-value-list (sqrts 3))</td>
<td>(call-with-values<br />
<span style="white-space: pre-wrap;">  </span>(lambda () (sqrts 3))<br />
<span style="white-space: pre-wrap;">  </span>list)</td>
<td><span style="color: gray"><em>multiple values are lists</em></span></td>
<td><span style="color: gray"><em>multiple values are lists</em></span></td>
</tr>
<tr>
<td><a href="#tail-call">tail call optimization</a></td>
<td><span style="color: gray"><em>yes for sbcl</em></span></td>
<td><span style="color: gray"><em>yes</em></span></td>
<td><span style="color: gray"><em>yes with</em></span> recur</td>
<td><span style="color: gray"><em>no</em></span></td>
</tr>
<tr>
<td><a href="#lambda">lambda</a></td>
<td>(lambda (x) (* x x))</td>
<td>(lambda (x) (* x x))</td>
<td>#(* % %)<br />
(fn [x] (* x x))<br />
<br />
<span style="color: gray">; shortcut notation with two args:</span><br />
#(* %1 %2)</td>
<td>(lambda (x) (* x x))</td>
</tr>
<tr>
<td><a href="#apply">apply</a></td>
<td>((lambda (x) (* x x)) 2)<br />
<span style="white-space: pre-wrap;"> </span><br />
(apply #'(lambda (x) (* x x)) '(2))</td>
<td>((lambda (x) (* x x)) 2)<br />
<span style="white-space: pre-wrap;"> </span><br />
(apply (lambda (x) (* x x)) '(2))</td>
<td>(#(* % %) 2)<br />
<span style="white-space: pre-wrap;"> </span><br />
((fn [x] (* x x)) 2)<br />
<span style="white-space: pre-wrap;"> </span><br />
(apply #(* % %) '(2))</td>
<td>((lambda (x) (* x x)) 2)<br />
<span style="white-space: pre-wrap;"> </span><br />
(apply<br />
<span style="white-space: pre-wrap;">  </span>#'(lambda (x) (* x x))<br />
<span style="white-space: pre-wrap;">  </span>'(2))</td>
</tr>
<tr>
<th colspan="5"><a name="execution-control" id="execution-control"></a><a href="#execution-control-note">execution control</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a href="#progn">progn</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>progn prog1 prog2</td>
<td>begin <span style="color: gray"><em>none</em></span> <span style="color: gray"><em>none</em></span><br />
<span style="color: gray"><em>r6rs:</em></span><br />
begin begin0 <span style="color: gray"><em>none</em></span></td>
<td>do <span style="color: gray"><em>none</em></span> <span style="color: gray"><em>none</em></span></td>
<td>progn prog1 prog2</td>
</tr>
<tr>
<td><a href="#loop">loop</a></td>
<td>(setq i 1)<br />
(loop (print "hello")<br />
<span style="white-space: pre-wrap;">  </span>(if (&gt; i 10)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(return)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(setq i (+ i 1))))</td>
<td><span style="color: gray"><em>none, use recursion</em></span></td>
<td>(loop [i 1]<br />
<span style="white-space: pre-wrap;">  </span>(if (&lt;= i 10)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(do (println "hello")<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(recur (+ i 1)))))</td>
<td>(setq i 1)<br />
(loop (print "hello")<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(if (&gt; i 10)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(return)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(setq i (+ i 1))))</td>
</tr>
<tr>
<td><a href="#do">do</a></td>
<td>(do ((i 1) (sum 0))<br />
<span style="white-space: pre-wrap;">  </span>((&gt; i 100) sum)<br />
<span style="white-space: pre-wrap;">  </span>(setq sum (+ sum i))<br />
<span style="white-space: pre-wrap;">  </span>(setq i (+ i 1)))<br />
<span style="color: gray">do* <em>initializes serially</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(do ((i 1) (sum 0))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>((&gt; i 100) sum)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(setq sum (+ sum i))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(setq i (+ i 1)))<br />
<span style="color: gray">do* <em>initializes sequentially</em></span></td>
</tr>
<tr>
<td><a href="#dotimes">dotimes</a></td>
<td>(dotimes (i 10 nil)<br />
<span style="white-space: pre-wrap;">  </span>(format t "hello~%"))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(dotimes [_ 10]<br />
<span style="white-space: pre-wrap;">  </span>(println "hello"))</td>
<td>(dotimes (i 10 nil)<br />
<span style="white-space: pre-wrap;">  </span>(print "hello\n"))</td>
</tr>
<tr>
<td><a href="#if">if</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(if (&lt; x 0) (- x) x)</td>
<td>(if (&lt; x 0) (- x) x)</td>
<td>(if (&lt; x 0) (- x) x)</td>
<td>(if (&lt; x 0) (- x) x)</td>
</tr>
<tr>
<td><a href="#when">when</a></td>
<td>(when (&lt; x y)<br />
<span style="white-space: pre-wrap;">  </span>(print "x is less ")<br />
<span style="white-space: pre-wrap;">  </span>(print "than y"))</td>
<td><span style="color: gray"><em>racket:</em></span><br />
(when (&lt; x y)<br />
<span style="white-space: pre-wrap;">  </span>(display "x is less ")<br />
<span style="white-space: pre-wrap;">  </span>(display "than y"))</td>
<td>(when (&lt; x y)<br />
<span style="white-space: pre-wrap;">  </span>(println "x is less ")<br />
<span style="white-space: pre-wrap;">  </span>(println "than y"))</td>
<td>(when (&lt; x y)<br />
<span style="white-space: pre-wrap;">  </span>(print "x is less ")<br />
<span style="white-space: pre-wrap;">  </span>(print "than y"))</td>
</tr>
<tr>
<td><a href="#cond">cond</a></td>
<td>(cond ((&gt; x 0) 1)<br />
<span style="white-space: pre-wrap;">  </span>((= x 0) 0)<br />
<span style="white-space: pre-wrap;">  </span>(t -1))</td>
<td>(cond ((&gt; x 0) 1)<br />
<span style="white-space: pre-wrap;">  </span>((= x 0) 0)<br />
<span style="white-space: pre-wrap;">  </span>(else -1))</td>
<td>(cond (&gt; x 0) 1<br />
<span style="white-space: pre-wrap;">  </span>(= x 0) 0<br />
<span style="white-space: pre-wrap;">  </span>true -1)</td>
<td>(cond ((&gt; x 0) 1)<br />
<span style="white-space: pre-wrap;">  </span>((= x 0) 0)<br />
<span style="white-space: pre-wrap;">  </span>(t -1))</td>
</tr>
<tr>
<td><a href="#lazy-evaluation">lazy evaluation</a></td>
<td></td>
<td>(define x (delay (/ 1 0)))<br />
(promise? x)<br />
(+ 1 (force x))</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#continuations">continuations</a></td>
<td></td>
<td>(define cc null)<br />
(+ 1 (call/cc (lambda (x) (set! cc x) 0)))<br />
(cc 5)</td>
<td></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="exceptions" id="exceptions"></a><a href="#exceptions-note">exceptions</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a href="#error">error</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(error "failed")</td>
<td>(error "failed")</td>
<td>(throw (Exception. "failed"))</td>
<td>(error "failed")</td>
</tr>
<tr>
<td><a href="#handle-error">handle error</a></td>
<td>(handler-case<br />
<span style="white-space: pre-wrap;">  </span>(error "failed")<br />
<span style="white-space: pre-wrap;">  </span>(simple-error (e)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(format t "error: ~a" e)))</td>
<td>(with-handlers<br />
<span style="white-space: pre-wrap;">  </span>((exn:fail?<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">   </span>(lambda (e)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">   </span>(printf "error: ~a"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">   </span>(exn-message e)))))<br />
<span style="white-space: pre-wrap;">  </span>(error "failed"))</td>
<td>(try (throw (Exception. "failure"))<br />
<span style="white-space: pre-wrap;">  </span>(catch Exception e<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(printf "error: %s"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(.getMessage e))))</td>
<td>(condition-case e<br />
<span style="white-space: pre-wrap;">  </span>(error "failed")<br />
<span style="white-space: pre-wrap;">  </span>(error (message "error: %s"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(error-message-string e))))</td>
</tr>
<tr>
<td><a href="#define-exception">define exception</a></td>
<td>(define-condition odd-err (error)<br />
<span style="white-space: pre-wrap;">  </span>((num :accessor odd-err-num<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>:initarg :num))<br />
<span style="white-space: pre-wrap;">  </span>(:report<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(lambda (e s)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(format s "odd number: ~a"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(odd-err-num e)))))</td>
<td>(define exn:odd-err? "odd number")</td>
<td></td>
<td><span style="color: gray"><em>only symbols and keywords can be thrown and caught</em></span></td>
</tr>
<tr>
<td><a href="#throw-exception">throw exception</a></td>
<td>(error 'odd-err :num 7)</td>
<td>(raise exn:odd-err?)</td>
<td>(throw (Exception. "failed"))</td>
<td>(throw 'odd-err t)</td>
</tr>
<tr>
<td><a href="#catch-exception">catch exception</a></td>
<td>(handler-case (/ 1 0)<br />
<span style="white-space: pre-wrap;">  </span>(division-by-zero ()<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(progn<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(format t "division by zero")<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>nil)))</td>
<td>(with-handlers ((exn:fail? (lambda (e) (begin (printf "division by zero~n") null)))) (/ 1 0))</td>
<td>(try (/ 1 0) (catch ArithmeticException _ (do (println "division by zero") nil)))</td>
<td>(catch 'failed (throw 'failed nil) t)</td>
</tr>
<tr>
<td><a href="#restart-case">restart-case</a></td>
<td>(defun halve (l)<br />
<span style="white-space: pre-wrap;">  </span>(mapcar (lambda (x)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(restart-case<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(if (= (rem x 2) 0) (/ x 2)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(error 'odd-error :num x))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(round-down () (/ (- x 1) 2))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(round-up () (/ (+ x 1) 2)))) l))</td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a href="#invoke-restart">invoke-restart</a></td>
<td>(handler-bind<br />
<span style="white-space: pre-wrap;">  </span>((odd-err<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(lambda (c)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(invoke-restart<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>'round-down))))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(halve '(1 2 4 9)))</td>
<td></td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a href="#finally-clause">finally clause</a></td>
<td>(unwind-protect<br />
<span style="white-space: pre-wrap;">  </span>(error "failure")<br />
<span style="white-space: pre-wrap;">  </span>(print "clean up"))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(try (throw (Exception. "failure"))<br />
<span style="white-space: pre-wrap;">     </span>(finally (println "clean up")))</td>
<td>(unwind-protect<br />
<span style="white-space: pre-wrap;">  </span>(error "failure")<br />
<span style="white-space: pre-wrap;">  </span>(print "clean up"))</td>
</tr>
<tr>
<th colspan="5"><a name="streams" id="streams"></a><a href="#streams-note">streams</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="std-file-handles" id="std-file-handles"></a><a href="#std-file-handles-note">standard file handles</a></td>
<td>*standard-input*<br />
*standard-output*<br />
*error-output*</td>
<td>(current-input-port)<br />
(current-output-port)<br />
(current-error-port)</td>
<td>*in*<br />
*out*<br />
*err*</td>
<td></td>
</tr>
<tr>
<td><a name="eof" id="eof"></a><a href="#eof-note">end-of-file behavior</a></td>
<td><span style="color: gray">read-line <em>returns two values, the 2nd set to</em> T <em>at end-of-file.</em><br />
<br />
EOF-OF-FILE <em>is signaled when reading past end of file.</em></span></td>
<td><span style="color: gray"><em>Returns the value</em> eof.<br />
<br />
<em>Use</em> eof-object? <em>to test for it.</em></span></td>
<td><span style="color: gray">.readLine <em>on a</em> java.io.Reader <em>object returns</em> nil.</span></td>
<td></td>
</tr>
<tr>
<td><a name="read-stdin" id="read-stdin"></a><a href="#read-stdin-note">read line from stdin</a></td>
<td>(setq line (read-line))</td>
<td>(let ((s (read-line)))<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray">#|use s<span style="white-space: pre-wrap;">|#</span></span>)</td>
<td>(let [s (read-line)]<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray">(comment use s)</span>)</td>
<td></td>
</tr>
<tr>
<td><a name="chomp" id="chomp"></a><a href="#chomp-note">chomp</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td><span style="color: gray">read-line <em>discards newline</em></span></td>
<td><span style="color: gray">read-line <em>discards newline</em></span></td>
<td></td>
</tr>
<tr>
<td><a name="println" id="println"></a><a href="#println-note">write line to stdout</a></td>
<td>(defun println (s)<br />
<span style="white-space: pre-wrap;">  </span>(format t "~a~%" s))<br />
<span style="white-space: pre-wrap;"> </span><br />
(println "hello")</td>
<td>(write-string s)<br />
(newline)</td>
<td>(println "hello")</td>
<td></td>
</tr>
<tr>
<td><a name="format-stdout" id="format-stdout"></a><a href="#format-stdout-note">write formatted string to stdout</a></td>
<td>(format t "~s ~d: ~2$~%"<br />
<span style="white-space: pre-wrap;">  </span>"foo"<br />
<span style="white-space: pre-wrap;">  </span>7<br />
<span style="white-space: pre-wrap;">  </span>13.7)</td>
<td>(printf "~a ~a: ~a~n"<br />
<span style="white-space: pre-wrap;">  </span>"foo"<br />
<span style="white-space: pre-wrap;">  </span>7<br />
<span style="white-space: pre-wrap;">  </span>(/ (round (* 13.7 100)) 100))</td>
<td>(printf "%s %d %.2f\n" "foo" 7 13.7)</td>
<td></td>
</tr>
<tr>
<td><a name="open-file" id="open-file"></a><a href="#open-file-note">open file for reading</a></td>
<td>(setq in (open "/etc/hosts"))</td>
<td>(let<br />
<span style="white-space: pre-wrap;">  </span>((f (open-input-file "/etc/hosts")))<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray">#| use f <span style="white-space: pre-wrap;">|#</span></span>)</td>
<td><span style="color: gray">; f is java.io.Reader object:</span><br />
(let [f (clojure.java.io/reader "/etc/hosts")]<br />
<span style="white-space: pre-wrap;">  </span>(.readLine f))</td>
<td></td>
</tr>
<tr>
<td><a name="open-file-write" id="open-file-write"></a><a href="#open-file-write-note">open file for writing</a></td>
<td>(setq out (open "/tmp/test" :direction :output :if-exists :supersede))</td>
<td>(let<br />
<span style="white-space: pre-wrap;">  </span>((f (open-output-file<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"/tmp/foo"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>#:exists 'truncate)))<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray">#| use f <span style="white-space: pre-wrap;">|#</span></span>)</td>
<td><span style="color: gray">; f is java.io.Writer object:</span><br />
(let [f (clojure.java.io/writer "/tmp/foo")]<br />
<span style="white-space: pre-wrap;">  </span>(.write f "lorem ipsum\n")<br />
<span style="white-space: pre-wrap;">  </span>(.close f))</td>
<td></td>
</tr>
<tr>
<td><a name="open-file-append" id="open-file-append"></a><a href="#open-file-append-note">open file for appending</a></td>
<td>(setq out (open "/tmp/test" :direction :output :if-exists :append))</td>
<td>(let<br />
<span style="white-space: pre-wrap;">  </span>((f (open-output-file<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"/tmp/foo"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>#:exists 'append)))<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray">#| use f <span style="white-space: pre-wrap;">|#</span></span>)</td>
<td>(let [f (clojure.java.io/writer "/tmp/foo"<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>:append true)]<br />
<span style="white-space: pre-wrap;">  </span>(.write f "lorem ipsum\n")<br />
<span style="white-space: pre-wrap;">  </span>(.close f))</td>
<td></td>
</tr>
<tr>
<td><a name="close-file" id="close-file"></a><a href="#close-file-note">close file</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(close in)</td>
<td>(close-input-port f)<br />
(close-output-port f)</td>
<td>(.close f)</td>
<td></td>
</tr>
<tr>
<td><a name="close-file-implicitly" id="close-file-implicitly"></a><a href="#close-file-implicitly-note">close file implicitly</a></td>
<td>(with-open-file (out #P"/tmp/test" :direction :output) (write-line "lorem ipsum" out))</td>
<td>(call-with-input-file<br />
<span style="white-space: pre-wrap;">  </span>"/etc/hosts"<br />
<span style="white-space: pre-wrap;">  </span>(lambda (f) (<span style="color: gray">#| use f <span style="white-space: pre-wrap;">|#</span></span>))<br />
<br />
<span style="color: gray">; also call-with-output-file</span></td>
<td>(with-open [f<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(clojure.java.io/reader "/etc/hosts")]<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray">(comment use f)</span>)</td>
<td></td>
</tr>
<tr>
<td><a name="read-line" id="read-line"></a><a href="#read-line-note">read line</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(setq line (read-line f))</td>
<td>(define line (read-line in))</td>
<td>(.readLine f)</td>
<td></td>
</tr>
<tr>
<td><a name="iterate-file" id="iterate-file"></a><a href="#iterate-file-note">iterate over file by line</a></td>
<td></td>
<td>(for ([line (in-lines<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(open-input-file<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"/etc/hosts"))])<br />
<span style="white-space: pre-wrap;">  </span>(write-string line)<br />
<span style="white-space: pre-wrap;">  </span>(newline))</td>
<td>(loop [line (.readLine f)]<br />
<span style="white-space: pre-wrap;">  </span>(if (not= line nil)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(do (println line)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(recur (.readLine f)))))</td>
<td></td>
</tr>
<tr>
<td><a name="read-file-array" id="read-file-array"></a><a href="#read-file-array-note">read file into array of strings</a></td>
<td></td>
<td><span style="color: gray">; to list of strings:</span><br />
(sequence-&gt;list (in-lines<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(open-input-file "/etc/hosts")))</td>
<td>(vec (line-seq f))</td>
<td></td>
</tr>
<tr>
<td><a name="read-file-str" id="read-file-str"></a><a href="#read-file-str-note">read file into string</a></td>
<td></td>
<td>(define s (file-&gt;string "/etc/hosts"))</td>
<td>(let [s (slurp "/etc/hosts")]<br />
<span style="white-space: pre-wrap;">  </span>(print s))</td>
<td></td>
</tr>
<tr>
<td><a name="write-str" id="write-str"></a><a href="#write-str-note">write string</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td>(write-string s f)</td>
<td>(.write f s)</td>
<td></td>
</tr>
<tr>
<td><a name="write-line" id="write-line"></a><a href="#write-line-note">write line</a></td>
<td></td>
<td>(write-string s f)<br />
(newline f)</td>
<td>(.write f (println-str s))</td>
<td></td>
</tr>
<tr>
<td><a name="flush-file" id="flush-file"></a><a href="#flush-file-note">flush file handle</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td>(flush-output f)</td>
<td>(f .flush)</td>
<td></td>
</tr>
<tr>
<td><a name="seek" id="seek"></a><a href="#seek-note">file handle position</a><br />
<br />
<span style="color: gray"><em>get, set</em></span></td>
<td></td>
<td><span style="color: gray">; Evaluates to non-negative integer:</span><br />
(file-position f)<br />
<br />
<span style="color: gray">; Sets next read or write<br />
; to beginning of file:</span><br />
(file-position f 0)</td>
<td><span style="color: gray">; arg is characters from current position;<br />
; moving backward not possible:</span><br />
(.skip f 1000)<br />
<br />
<span style="color: gray">; arg is max characters to buffer:</span><br />
(.mark f 1000000)<br />
<span style="color: gray">; move to position saved when .mark was called:</span><br />
(.rest f)</td>
<td></td>
</tr>
<tr>
<td><a name="in-memory-stream" id="in-memory-stream"></a><a href="#in-memory-stream-note">in memory stream</a></td>
<td>(setq f (make-string-input-stream<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"lorem ipsum"))<br />
(read-line f)<br />
<br />
(setq f2 (make-string-output-stream)<br />
(write-string "lorem ipsum)<br />
(get-output-stream-string out)</td>
<td>(define f (open-input-string "lorem ipsum"))<br />
(read-line f)<br />
<br />
(define f2 (open-output-string))<br />
(write-string "lorem ipsum" f2)<br />
(get-output-string f2)</td>
<td><span style="color: gray">; use *in* to read from string:</span><br />
(with-in-str "lorem ispum"<br />
<span style="white-space: pre-wrap;">  </span>(read-line))<br />
<br />
<span style="color: gray">; use *out* to write to string:</span><br />
(with-out-str<br />
<span style="white-space: pre-wrap;">  </span>(println "lorem ipsum"))</td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="emacs-buffers" id="emacs-buffers"></a><a href="#emacs-buffers-note">emacs buffers</a></th>
</tr>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="list-buffers" id="list-buffers"></a><a href="#list-buffers-note">list buffers</a></td>
<td></td>
<td></td>
<td></td>
<td><span style="color: gray">;; list of buffer objects:</span><br />
(buffer-list)<br />
<br />
<span style="color: gray">;; name of first buffer in list:</span><br />
(buffer-name (car (buffer-list)))<br />
<br />
<span style="color: gray">;; name of current buffer:</span><br />
(buffer-name (current-buffer))</td>
</tr>
<tr>
<td><a name="current-buffer" id="current-buffer"></a><a href="#current-buffer-note">current buffer</a><br />
<span style="color: gray"><em>get and set</em></span></td>
<td></td>
<td></td>
<td></td>
<td><span style="color: gray">;; name of current buffer:</span><br />
(buffer-name (current-buffer))<br />
<br />
<span style="color: gray">;; open in current pane:</span><br />
(switch-to-buffer "foo.txt")<br />
<br />
<span style="color: gray">;; open in other pane:</span><br />
(switch-to-buffer-other-window<br />
<span style="white-space: pre-wrap;">  </span>"bar.txt")</td>
</tr>
<tr>
<td><a name="clear-buffer" id="clear-buffer"></a><a href="#clear-buffer-note">clear buffer</a></td>
<td></td>
<td></td>
<td></td>
<td><span style="color: gray">;; current buffer:</span><br />
(erase-buffer)<br />
<br />
<span style="color: gray">;; buffer named "foo.txt:</span><br />
(with-current-buffer "foo.txt"<br />
<span style="white-space: pre-wrap;">  </span>(erase-buffer))</td>
</tr>
<tr>
<td><a name="point" id="point"></a><a href="#point-note">point</a><br />
<span style="color: gray"><em>get and set</em></span></td>
<td></td>
<td></td>
<td></td>
<td><span style="color: gray">;; 1-based index of char under cursor:</span><br />
(point)<br />
<br />
<span style="color: gray">;; go to beginning of current buffer:</span><br />
(goto-char 1)<br />
<br />
<span style="color: gray">;; go to end of current buffer:</span><br />
(goto-char (buffer-size))</td>
</tr>
<tr>
<td>search and set point</td>
<td></td>
<td></td>
<td></td>
<td><span style="color: gray">;; Set point to character after string.<br />
;; 1st arg is position in buffer beyond<br />
;;<span style="white-space: pre-wrap;">   </span>which search stops.<br />
;; If 2nd arg is true, return nil<br />
;;<span style="white-space: pre-wrap;">   </span>on failure, otherwise raise error.<br />
;; 3rd argument is the occurrence<br />
;;<span style="white-space: pre-wrap;">   </span>of the string, if negative<br />
;;<span style="white-space: pre-wrap;">   </span>search backwards from point.</span><br />
(search-forward "lorem" nil t 1)</td>
</tr>
<tr>
<td>insert at string point</td>
<td></td>
<td></td>
<td></td>
<td><span style="color: gray">;; takes 1 or more args:</span><br />
(insert "lorem" " ipsum")</td>
</tr>
<tr>
<td>current buffer as string</td>
<td></td>
<td></td>
<td></td>
<td>(buffer-string)</td>
</tr>
<tr>
<td>insert file contents at point</td>
<td></td>
<td></td>
<td></td>
<td>(insert-file "/etc/passwd")</td>
</tr>
<tr>
<td><a name="mark" id="mark"></a><a href="#mark-note">mark</a><br />
<span style="color: gray"><em>get and set</em></span></td>
<td></td>
<td></td>
<td></td>
<td><span style="color: gray">;; to beginning of current buffer:</span><br />
(set-mark 1)<br />
<br />
<span style="color: gray">;; to point of current buffer:</span><br />
(set-mark (point))</td>
</tr>
<tr>
<th colspan="5"><a name="files" id="files"></a><a href="#files-note">files</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="file-test" id="file-test"></a><a href="#file-test-note">file test, regular file test</a></td>
<td>(osicat:file-exists-p "/tmp/foo")<br />
(osicat:regular-file-exists-p "/tmp/foo")</td>
<td><span style="color: gray"><em>??</em></span><br />
(file-exists? "/etc/hosts")</td>
<td>(.exists (io/file "/etc/hosts"))</td>
<td>(file-exists-p "/etc/hosts")<br />
<br />
(file-regular-p "/etc/hosts")</td>
</tr>
<tr>
<td><a name="file-size" id="file-size"></a><a href="#file-size-note">file size</a></td>
<td></td>
<td>(file-size "/etc/hosts")</td>
<td>(.length (io/file "/etc/hosts"))</td>
<td>(eighth<br />
<span style="white-space: pre-wrap;">  </span>(file-attributes "/etc/hosts"))</td>
</tr>
<tr>
<td><a name="file-readable-writable-executable" id="file-readable-writable-executable"></a><a href="#file-readable-writable-executable-note">is file readable, writable, executable</a></td>
<td></td>
<td>(pair? (filter<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(lambda (x) (eq? x 'read))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(file-or-directory-permissions<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"/etc/hosts")))<br />
(pair? (filter<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(lambda (x) (eq? x 'write))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(file-or-directory-permissions<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"/etc/hosts")))<br />
(pair? (filter<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(lambda (x) (eq? x 'execute))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(file-or-directory-permissions<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>"/etc/hosts")))</td>
<td>(.canRead (io/file "/etc/hosts"))<br />
(.canWrite (io/file "/etc/hosts"))<br />
(.canExecute (io/file "/etc/hosts"))</td>
<td></td>
</tr>
<tr>
<td><a name="chmod" id="chmod"></a><a href="#chmod-note">set file permissions</a></td>
<td></td>
<td>(file-or-directory-permissions<br />
<span style="white-space: pre-wrap;">  </span>"/tmp/foo"<br />
<span style="white-space: pre-wrap;">  </span>#o755)</td>
<td></td>
<td>(set-file-modes "/tmp/foo" #o755)</td>
</tr>
<tr>
<td><a name="last-modification-time" id="last-modification-time"></a><a href="#last-modification-time-note">last modification time</a></td>
<td></td>
<td>(file-or-directory-modify-seconds "/tmp/foo")</td>
<td><span style="color: gray">; Unix epoch in milliseconds:</span><br />
(.lastModified (java.io.File. "/tmp/foo"))</td>
<td></td>
</tr>
<tr>
<td><a name="cp-rm-mv" id="cp-rm-mv"></a><a href="#cp-rm-mv-note">copy file, remove file, rename file</a></td>
<td>(cl-fad:copy-file #P"/tmp/foo"<br />
<span style="white-space: pre-wrap;">  </span>#P"/tmp/bar")<br />
<br />
(delete-file #P"/tmp/foo")<br />
<br />
(rename-file #P"/tmp/bar"<br />
<span style="white-space: pre-wrap;">  </span>#P"/tmp/foo")</td>
<td>(copy-file "/tmp/foo" "/tmp/bar")<br />
(delete-file "/tmp/foo")<br />
(rename-file-or-directory<br />
<span style="white-space: pre-wrap;">  </span>"/tmp/bar"<br />
<span style="white-space: pre-wrap;">  </span>"/tmp/foo")</td>
<td>(clojure.java.io/copy<br />
<span style="white-space: pre-wrap;">  </span>(java.io.File. "/tmp/foo")<br />
<span style="white-space: pre-wrap;">  </span>(java.io.File. "/tmp/bar"))<br />
(clojure.java.io/delete-file "/tmp/foo")<br />
(.renameTo (java.io.File. "/tmp/bar")<br />
<span style="white-space: pre-wrap;">  </span>(java.io.File. "/tmp/foo"))</td>
<td>(copy-file "/tmp/foo" "/tmp/bar")<br />
(delete-file "/tmp/foo")<br />
(rename-file "/tmp/bar" "/tmp/foo")</td>
</tr>
<tr>
<td><a name="symlink" id="symlink"></a><a href="#symlink-note">create symlink, symlink test, get target</a></td>
<td>(osicat:make-link "/tmp/hosts" :target "/etc/hosts")</td>
<td>(make-file-or-directory-link<br />
<span style="white-space: pre-wrap;">  </span>"/etc/hosts"<br />
<span style="white-space: pre-wrap;">  </span>"/tmp/hosts")<br />
(link-exists? "/tmp/hosts")<br />
<span style="color: gray"><em>??</em></span></td>
<td></td>
<td>(make-symbolic-link "/etc/hosts" /tmp/hosts")<br />
<span style="color: gray"><em>returns target if symlink or nil:</em></span><br />
(file-symlink-p "/tmp/hosts")</td>
</tr>
<tr>
<td><a name="tmp-file" id="tmp-file"></a><a href="#tmp-file-note">temporary file</a></td>
<td></td>
<td>(define tmp (make-temporary-file))<br />
(path-&gt;string tmp)</td>
<td><span style="color: gray">; java.io.File:</span><br />
(java.io.File/createTempFile "foo" ".txt")</td>
<td>(make-temp-file "foo")</td>
</tr>
<tr>
<th colspan="5"><a name="directories" id="directories"></a><a href="#directories-note">directories</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="build-pathname" id="build-pathname"></a><a href="#build-pathname-note">build pathname</a></td>
<td>(make-pathname<br />
<span style="white-space: pre-wrap;">  </span>:directory '(:absolute "etc")<br />
<span style="white-space: pre-wrap;">  </span>:name "hosts")</td>
<td><span style="color: gray">; returns path; convert to string<br />
; with path-&gt;string:</span><br />
(build-path "/etc" "hosts")</td>
<td>(require '[clojure.java.io :as io])<br />
<br />
<span style="color: gray">; returns java.io.File;<br />
; convert to string with .getPath:</span><br />
(io/file "/etc" "hosts")</td>
<td></td>
</tr>
<tr>
<td><a name="dirname-basename" id="dirname-basename"></a><a href="#dirname-basename-note">dirname and basename</a></td>
<td>(pathname-directory #P"/etc/hosts")<br />
<br />
(pathname-name #P"/etc/hosts")</td>
<td>(let-values (((dir file _)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(split-path "/etc/hosts")))<br />
<span style="white-space: pre-wrap;">  </span><span style="color: gray">#| use dir or file <span style="white-space: pre-wrap;">|#</span></span>)</td>
<td>(require '[clojure.java.io :as io])<br />
<br />
(.getParent (io/file "/etc/hosts"))<br />
(.getName (io/file "/etc/hosts"))</td>
<td>(file-name-directory "/etc/hosts")<br />
<br />
(file-name-nondirectory<br />
<span style="white-space: pre-wrap;">  </span>"/etc/hosts")</td>
</tr>
<tr>
<td><a name="abs-pathname" id="abs-pathname"></a><a href="#abs-pathname-note">absolute pathname</a></td>
<td></td>
<td>(simplify-path<br />
<span style="white-space: pre-wrap;">  </span>(path-&gt;complete-path ".."))</td>
<td>(.getCanonicalPath (java.io.File. ".."))</td>
<td>(expand-file-name "..")</td>
</tr>
<tr>
<td><a name="iterate-dir" id="iterate-dir"></a><a href="#iterate-dir-note">iterate over directory by file</a></td>
<td>(dolist (file (osicat:list-directory "/tmp")) (format t "~a~%" file))</td>
<td>(for ([path (directory-list "/etc")])<br />
<span style="white-space: pre-wrap;">  </span>(write-string<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(path-&gt;string path)))</td>
<td><span style="color: gray">; file-seq returns java.io.File objects for files<br />
; in arg directory and any subdirs recursively.</span><br />
(filter #(= (.getParent %) "/etc")<br />
<span style="white-space: pre-wrap;">  </span>(file-seq (clojure.java.io/file "/etc")))</td>
<td>(dolist<br />
<span style="white-space: pre-wrap;">  </span>(file (directory-files "/etc"))<br />
<span style="white-space: pre-wrap;">  </span>(print file)))</td>
</tr>
<tr>
<td><a name="mkdir" id="mkdir"></a><a href="#mkdir-note">make directory</a></td>
<td></td>
<td>(make-directory* "/tmp/foo/bar")</td>
<td>(require '[clojure.java.io :as io])<br />
<br />
(.mkdir (io/file "/tmp/foo"))</td>
<td><span style="color: gray"><em>creates parents if 2nd arg non-nil:</em></span><br />
(make-directory "/tmp/foo/bar" t)</td>
</tr>
<tr>
<td><a name="recursive-cp" id="recursive-cp"></a><a href="#recursive-cp-note">recursive copy</a></td>
<td></td>
<td>(copy-directory/files "/tmp/foo.d"<br />
<span style="white-space: pre-wrap;">  </span>"/tmp/bar.d")</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="rmdir" id="rmdir"></a><a href="#rmdir-note">remove empty directory</a></td>
<td>(delete-directory "/tmp/foo.d")</td>
<td>(delete-directory "/tmp/foo.d")</td>
<td>(clojure.java.io/delete-file "/tmp/foo.d")</td>
<td>(delete-directory "/tmp/foo.d")</td>
</tr>
<tr>
<td><a name="rm-rf" id="rm-rf"></a><a href="#rm-rf-note">remove directory and contents</a></td>
<td>(osicat:delete-directory-and-files "/tmp/foo.d")</td>
<td>(delete-directory/files "/tmp/foo.d")</td>
<td></td>
<td>(delete-directory "/tmp/foo.d" t)</td>
</tr>
<tr>
<td><a name="dir-test" id="dir-test"></a><a href="#dir-test-note">directory test</a></td>
<td>(osicat:directory-exists-p #P"/etc")</td>
<td>(directory-exists? "/etc")</td>
<td>(.isDirectory (io/file "/etc"))</td>
<td>(file-directory-p "/etc")</td>
</tr>
<tr>
<th colspan="5"><a name="processes-environment" id="processes-environment"></a><a href="#processes-environment-note">processes and environment</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a name="cmd-line-arg" id="cmd-line-arg"></a><a href="#cmd-line-arg-note">command line arguments</a></td>
<td>*posix-argv*</td>
<td>current-command-line-arguments</td>
<td>*command-line-args*</td>
<td><span style="color: gray"><em>in shebang mode only:</em></span><br />
command-line-args <span style="color: gray"><em>or</em></span> argv</td>
</tr>
<tr>
<td><a name="program-name" id="program-name"></a><a href="#program-name-note">program name</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="env-var" id="env-var"></a><a href="#env-var-note">environment variables</a></td>
<td>(posix-getenv "HOME")</td>
<td>(getenv "HOME")</td>
<td>(System/getenv "HOME")</td>
<td>(getenv "HOME")</td>
</tr>
<tr>
<td><a name="user-id-name" id="user-id-name"></a><a href="#user-id-name-note">user id and name</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="exit" id="exit"></a><a href="#exit-note">exit</a></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a name="external-cmd" id="external-cmd"></a><a href="#external-cmd-note">external command</a></td>
<td>(run-program "ls" '( "/etc"))</td>
<td>(require scheme/system)<br />
(system "ls /etc")</td>
<td>(.exec (Runtime/getRuntime) "ls")</td>
<td>(shell-command "ls /etc")</td>
</tr>
<tr>
<td><a name="cmd-subst" id="cmd-subst"></a><a href="#cmd-subst-note">command substitution</a></td>
<td></td>
<td></td>
<td></td>
<td>(shell-command-to-string "ls /etc")</td>
</tr>
<tr>
<th colspan="5"><a name="libraries-namespaces" id="libraries-namespaces"></a><a href="#libraries-namespaces-note">libraries and namespaces</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td>complete example</td>
<td></td>
<td></td>
<td>$ cat b/a.clj<br />
(ns b.a)<br />
(def x 3)<br />
<br />
$ java -cp clojure.jar:. clojure.main<br />
=&gt; (require 'b.a)<br />
=&gt; b.a/x<br />
3</td>
<td></td>
</tr>
<tr>
<td>compile library</td>
<td>(compile-file "a.lisp")</td>
<td>$ raco make a.rkt</td>
<td>(compile 'a)</td>
<td>$ emacs -batch -Q -L . \<br />
<span style="white-space: pre-wrap;">  </span>-f batch-byte-compile a.el</td>
</tr>
<tr>
<td>load library<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(load "a.lisp")</td>
<td>(require a)</td>
<td>(require 'a)</td>
<td>(require "a")</td>
</tr>
<tr>
<td>load library in subdirectory</td>
<td>(load "b/a.lisp")</td>
<td>(require "b/a.rkt")</td>
<td>(require 'b.a)</td>
<td></td>
</tr>
<tr>
<td>hot patch</td>
<td>(load "a.lisp")</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(require 'b.a :reload)</td>
<td>(load "a")</td>
</tr>
<tr>
<td>load error</td>
<td><span style="color: gray"><em>raises</em> sb-int:simple-file-error</span></td>
<td><span style="color: gray"><em>raises</em> exn:fail:syntax:missing-module. <em>Because</em> require <em>must be top-level, the exception cannot be handled.</em></span></td>
<td><span style="color: grya"><em>raises</em> FileNotFoundException</span></td>
<td><span style="color: gray"><em>raises</em> file-err</span></td>
</tr>
<tr>
<td>library path</td>
<td><span style="color: gray"><em>contains working directory at startup</em></span></td>
<td>(require setup/dirs)<br />
<br />
(get-collects-search-dirs)</td>
<td><span style="color: gray"><em>same as path used by java VM</em></span></td>
<td><span style="color: gray">; adds directory to library path:</span><br />
(add-to-list 'load-path ("/home/ed/.emacs.d/lib"))</td>
</tr>
<tr>
<td>library path environment variable</td>
<td><span style="color: gray"><em>none</em></span></td>
<td></td>
<td><span style="color: gray">CLASSPATH</span></td>
<td><span style="color: gray">EMACSLOADPATH</span></td>
</tr>
<tr>
<td>library path command line option</td>
<td><span style="color: gray"><em>none</em></span></td>
<td></td>
<td>$ java -cp /foo/bar:/baz/quux</td>
<td>$ emacs -L /foo/bar</td>
</tr>
<tr>
<td>namespace declaration</td>
<td>(defpackage :foo)</td>
<td>(module mconst racket<br />
<span style="white-space: pre-wrap;">  </span>(provide pi)<br />
<span style="white-space: pre-wrap;">  </span>(define pi 3.14))</td>
<td>(ns mconst)</td>
<td><span style="color: gray"><em>No namespaces; a common convention is to use a prefix on all identifiers in a library, separated from the rest of the identifier by a hyphen.</em></span></td>
</tr>
<tr>
<td>subnamespace declaration</td>
<td><span style="color: gray"><em>none</em></span></td>
<td></td>
<td><span style="color: gray">; must be in b/a.clj:</span><br />
(ns b.a)</td>
<td></td>
</tr>
<tr>
<td>namespace separator</td>
<td>:</td>
<td>:</td>
<td>. <span style="color: gray"><em>and</em></span> /</td>
<td></td>
</tr>
<tr>
<td>import definitions</td>
<td><span style="color: gray">; set current *package* to foo and import symbol twiddle from bar:</span><br />
(defpackage :foo<br />
<span style="white-space: pre-wrap;">  </span>(:import-from :bar :twiddle))</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>import all definitions in namespace</td>
<td><span style="color: gray">; set current *package* to foo and import symbols from bar:</span><br />
(defpackage :foo<br />
<span style="white-space: pre-wrap;">  </span>(:use :bar))</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>namespace shadow avoidance</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>identifier shadow avoidance</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>package manager help</td>
<td></td>
<td>$ raco help<br />
$ raco pkg <span style="white-space: pre-wrap;">--</span>help<br />
$ raco pkg install <span style="white-space: pre-wrap;">--</span>help</td>
<td></td>
<td></td>
</tr>
<tr>
<td>list installed packages</td>
<td></td>
<td>$ raco pkg show <span style="white-space: pre-wrap;">--</span>all</td>
<td></td>
<td>M-x list packages</td>
</tr>
<tr>
<td>search packages</td>
<td>(ql:system-apropos "time")</td>
<td><a href="http://pkgs.racket-lang.org">http://pkgs.racket-lang.org</a></td>
<td></td>
<td>M-x list-packages</td>
</tr>
<tr>
<td>install package</td>
<td><span style="color: gray">; install quicklisp</span><br />
(load "~/quicklisp/setup.lisp")<br />
(ql:quickload "osicat")</td>
<td>$ raco pkg install <span style="white-space: pre-wrap;">--</span>deps search-auto srfi</td>
<td></td>
<td><span style="color: gray"><em>Use</em> M-x list-packages <em>to bring up the package menu;</em> i <em>to select a package to install, and</em> x <em>to install it.</em></span></td>
</tr>
<tr>
<td>remove package</td>
<td></td>
<td>$ raco pkg remove srfi</td>
<td></td>
<td><span style="color: gray"><em>In the package menu, use</em> d <em>to select a package to uninstall and</em> x <em>to uninstall it.</em></span></td>
</tr>
<tr>
<th colspan="5"><a name="objects" id="objects"></a><a href="#objects-note">objects</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a href="#defclass">define class</a></td>
<td>(defclass rectangle ()<br />
<span style="white-space: pre-wrap;">  </span>(<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(height<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>:accessor rectangle-height<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>:initarg :height)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(width<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>:accessor rectangle-width<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>:initarg :width)))</td>
<td>(define rectangle%<br />
<span style="white-space: pre-wrap;">  </span>(class object%<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(init width)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(init height)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(super-new)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(define curr-height height)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(define curr-width width)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(define/public (get-height)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>curr-height)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(define/public (get-width)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>curr-width)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(define/public (set-height ht)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(set! curr-height ht))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(define/public (set-width wd)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(set! curr-width wd))))</td>
<td><span style="color: gray"><em>use java:</em></span><br />
public class Rectangle {<br />
<span style="white-space: pre-wrap;">  </span>public float height;<br />
<span style="white-space: pre-wrap;">  </span>public float width;<br />
<span style="white-space: pre-wrap;">  </span>public Rectangle(float h, float w) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>this.height = h;<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>this.width = w;<br />
<span style="white-space: pre-wrap;">  </span>}<br />
<span style="white-space: pre-wrap;">  </span>public void setHeight(float h) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>this.height = h;<br />
<span style="white-space: pre-wrap;">  </span>}<br />
<span style="white-space: pre-wrap;">  </span>public void setWidth(float w) {<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>this.width = w;<br />
}</td>
<td></td>
</tr>
<tr>
<td><a href="#make-instance">make instance</a></td>
<td>(make-instance 'rectangle<br />
<span style="white-space: pre-wrap;">  </span>:height 3<br />
<span style="white-space: pre-wrap;">  </span>:width 7)</td>
<td>(define rect<br />
<span style="white-space: pre-wrap;">  </span>(new rectangle<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(height 7)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(width 3)))</td>
<td>(import 'Rectangle)<br />
(def r (Rectangle. 7 3))</td>
<td></td>
</tr>
<tr>
<td><a href="#read-attribute">read attribute</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(rectangle-height rect)</td>
<td>(send rect get-height)</td>
<td>(.height r)</td>
<td></td>
</tr>
<tr>
<td><a href="#write-attribute">write attribute</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(setf (rectangle-height rect) 4)</td>
<td>(send rect set-height 4)</td>
<td>(.setHeight r 8)</td>
<td></td>
</tr>
<tr>
<td><a href="#defmethod">define method</a></td>
<td>(defmethod area ((figure rectangle))<br />
<span style="white-space: pre-wrap;">  </span>(* (rectangle-height figure)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(rectangle-width figure)))</td>
<td>(define/public (area)<br />
<span style="white-space: pre-wrap;">  </span>(* curr-height curr-width))</td>
<td>(defmulti area class)<br />
(defmethod area Rectangle [r] (* (.height r) (.width r)))</td>
<td></td>
</tr>
<tr>
<td><a href="#invoke-method">invoke method</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(area rect)</td>
<td>(send rect area)</td>
<td>(area r)</td>
<td></td>
</tr>
<tr>
<td><a href="#universal-superclass">universal superclass</a></td>
<td>standard-object t</td>
<td>object%</td>
<td>Object</td>
<td></td>
</tr>
<tr>
<td><a href="#multiple-inheritance">multiple inheritance</a></td>
<td>yes</td>
<td>no</td>
<td><span style="color: gray"><em>only one direct superclass; can implement multiple interfaces</em></span></td>
<td></td>
</tr>
<tr>
<th colspan="5"><a name="lisp-macros" id="lisp-macros"></a><a href="#lisp-macros-note">lisp macros</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a href="#backquote-comma">backquote and comma</a></td>
<td>(setq op '+)<br />
(eval <span style="white-space: pre-wrap;">`</span>(,op 1 1))</td>
<td>(define op '+)<br />
(eval <span style="white-space: pre-wrap;">`</span>(,op 1 1))<br />
(eval (quasiquote ((unquote op) 1 1)))</td>
<td>(def op +)<br />
(eval <span style="white-space: pre-wrap;">`</span>(,op 1 1))</td>
<td>(setq op '+)<br />
(eval <span style="white-space: pre-wrap;">`</span>(,op 1 1))</td>
</tr>
<tr>
<td><a href="#defmacro">defmacro</a></td>
<td>(defmacro rpn (arg1 arg2 op)<br />
<span style="white-space: pre-wrap;">  </span>(list op arg1 arg2))</td>
<td>(define-syntax-rule (rpn arg1 arg2 op) (op arg1 arg2))</td>
<td>(defmacro rpn [arg1 arg2 op]<br />
<span style="white-space: pre-wrap;">  </span>(list op arg1 arg2))</td>
<td>(defmacro rpn (arg1 arg2 op)<br />
<span style="white-space: pre-wrap;">  </span>(list op arg1 arg2))</td>
</tr>
<tr>
<td><a href="#defmacro-backquote">defmacro w/ backquote</a></td>
<td>(defmacro rpn (arg1 arg2 op)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">`</span>(,op ,arg1 ,arg2))</td>
<td>(define-syntax-rule (rpn3 arg1 arg2 op)<br />
<span style="white-space: pre-wrap;">  </span>(eval ‘(,op ,arg1 ,arg2)))</td>
<td>(defmacro rpn [arg1 arg2 op] <span style="white-space: pre-wrap;">`</span>(~op ~arg1 ~arg2))</td>
<td>(defmacro rpn (arg1 arg2 op)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">`</span>(,op ,arg1 ,arg2))</td>
</tr>
<tr>
<td><a href="#macro-predicate">macro predicate</a></td>
<td>(macro-function rpn)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<td><a href="#macroexpand">macroexpand</a></td>
<td>(macroexpand ’(rpn 1 2 +))</td>
<td>(syntax-object-&gt;datum (expand-to-top-form '(rpn 1 2 +)))</td>
<td>(macroexpand '(rpn 1 2 +))</td>
<td>(macroexpand '(rpn 1 2 +))</td>
</tr>
<tr>
<td><a href="#splice-quote">splice quote</a></td>
<td>(defmacro add ( &amp;rest args )<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">`</span>(+ ,@args))</td>
<td>(define-syntax-rule ( add first …) (+ first …))</td>
<td>(defmacro add [ &amp; args ] <span style="white-space: pre-wrap;">`</span>(+ ~@args))</td>
<td>(defmacro add ( &amp;rest args )<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">`</span>(+ ,@args))</td>
</tr>
<tr>
<td><a href="#recursive-macro">recursive macro</a></td>
<td>(defmacro add (a &amp;rest b)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">`</span>(if (null ',b)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(+ ,a)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(+ ,a (add ,@b))))</td>
<td>(define-syntax add (syntax-rules ()<br />
<span style="white-space: pre-wrap;">  </span>[(add x) x]<br />
<span style="white-space: pre-wrap;">  </span>[(add x y) (+ x y)]<br />
<span style="white-space: pre-wrap;">  </span>[(add x y …) (+ x (add y …))]))</td>
<td>(defmacro add ([a] <span style="white-space: pre-wrap;">`</span>(+ ~a)) ([a &amp; b] <span style="white-space: pre-wrap;">`</span>(+ ~a (add ~@b))))</td>
<td>(defmacro add (a &amp;rest b)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">`</span>(if (null ',b)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(+ ,a)<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(+ ,a (add ,@b))))</td>
</tr>
<tr>
<td><a href="#hygienic">hygienic</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td><span style="color: gray"><em>no</em></span></td>
<td><span style="color: gray"><em>yes</em></span></td>
<td><span style="color: gray"><em>with</em> # <em>suffix</em></span></td>
<td><span style="color: gray"><em>no</em></span></td>
</tr>
<tr>
<td><a href="#local-values">local values</a></td>
<td>(defmacro square-sum (x y)<br />
<span style="white-space: pre-wrap;">  </span>(let ((sum (gensym)))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">`</span>(let ((,sum (+ ,x ,y)))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(* ,sum ,sum))))</td>
<td>(define-syntax-rule (square-sum x y)<br />
<span style="white-space: pre-wrap;">  </span>(let ((sum (+ x y)))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(* sum sum)))</td>
<td>(defmacro two-list [x] <span style="white-space: pre-wrap;">`</span>(let [arg# ~x] (list arg# arg#)))</td>
<td>(defmacro square-sum (x y)<br />
<span style="white-space: pre-wrap;">  </span>(let ((sum (gensym)))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">`</span>(let ((,sum (+ ,x ,y)))<br />
<span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span><span style="white-space: pre-wrap;">  </span>(* ,sum ,sum))))</td>
</tr>
<tr>
<th colspan="5"><a name="reflection" id="reflection"></a><a href="#reflection-note">reflection</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td>inspect type<br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(type-of '(1 2 3))<br />
(typep '(1 2 3) 'list)<br />
(listp '(1 2 3))</td>
<td>(list? '(1 2 3))</td>
<td>(= (type 1) java.lang.Long)<br />
(= (class 1) java.lang.Long)<br />
(integer? 1)</td>
<td>(type-of [1 2 3] 'vector)<br />
(typep [1 2 3] 'vector)<br />
(vectorp [1 2 3])</td>
</tr>
<tr>
<td>instance-of</td>
<td></td>
<td></td>
<td>instance?</td>
<td></td>
</tr>
<tr>
<td>basic types</td>
<td><span style="color: gray"><em>logical and numeric:</em></span><br />
bignum bit complex double-float fixnum float integer long-float nil null number ratio rational real short-float signed-btye single-float t unsigned-byte<br />
<br />
<span style="color: gray"><em>symbols and strings:</em></span><br />
base-character character extended-character keyword simple-string standard-char string symbol<br />
<br />
<span style="color: gray"><em>data structures:</em></span><br />
array atom bit-vector cons hash-table list sequence simple-array simple-bit-vector simple-vector vector<br />
<br />
<span style="color: gray"><em>other:</em></span><br />
compiled-function function package pathname random-state stream</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#sequence-data-types">sequence data types</a></td>
<td>list vector</td>
<td>list vector hash-table string input-port range</td>
<td>all collections and strings</td>
<td>list vector</td>
</tr>
<tr>
<td><a name="docstring" id="docstring"></a><a href="#docstring-note">get docstring</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td>(describe #'mapcar)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(doc map)</td>
<td>(describe-function 'mapcar)</td>
</tr>
<tr>
<td><a name="define-docstring" id="define-docstring"></a><a href="#define-docstring-note">define function with docstring</a></td>
<td>(defun add (x y)<br />
<span style="white-space: pre-wrap;">  </span>"add x and y"<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(defn add "add x and y" [x y]<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))</td>
<td>(defun add (x y)<br />
<span style="white-space: pre-wrap;">  </span>"add x and y"<br />
<span style="white-space: pre-wrap;">  </span>(+ x y))</td>
</tr>
<tr>
<td><a name="search-doc" id="search-doc"></a><a href="#search-doc-note">apropos and documentation search</a></td>
<td><span style="color: gray"><em>none</em></span></td>
<td><span style="color: gray"><em>none</em></span></td>
<td>(apropos #"^add$")<br />
(find-doc #"add \S+ and \S+")</td>
<td>(apropos "^add$")<br />
<span style="color: gray"><em>none</em></span></td>
</tr>
<tr>
<th colspan="5"><a name="java-interop" id="java-interop"></a><a href="#java-interop-note">java interoperation</a></th>
</tr>
<tr>
<th></th>
<th>common lisp</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td><a href="#java-new">new</a></td>
<td></td>
<td></td>
<td>(def rnd (new java.util.Random))<br />
(def rnd (java.util.Random.))</td>
<td></td>
</tr>
<tr>
<td><a href="#java-method">method</a></td>
<td></td>
<td></td>
<td>(. rnd nextFloat)<br />
(.nextFloat rnd)<br />
(. rnd nextInt 10)<br />
(.nextInt rnd 10)</td>
<td></td>
</tr>
<tr>
<td><a href="#java-class-method">class method</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td>(Math/sqrt 2)</td>
<td></td>
</tr>
<tr>
<td><a href="#java-chain">chain</a><br />
<span style="white-space: pre-wrap;"> </span></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="#java-import">import</a></td>
<td></td>
<td></td>
<td>(import '(java.util Random))<br />
(def rnd (Random.))</td>
<td></td>
</tr>
<tr>
<td><a href="#java-to-array">to java array</a></td>
<td></td>
<td></td>
<td>(to-array '(1 2 3))<br />
(into-array Integer '(1 2 3))</td>
<td></td>
</tr>
<tr>
<th></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">__________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">__________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">__________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">__________________________________________</span></span></th>
</tr>
</table>
<p><a name="version-used-note" id="version-used-note"></a></p>
<h2 id="toc0"><span><a href="#version-used">version used</a></span></h2>
<p>Versions used to verify examples in the reference sheet.</p>
<p><a name="show-version-note" id="show-version-note"></a></p>
<h2 id="toc1"><span><a href="#show-version">show version</a></span></h2>
<p>How to determine the version.</p>
<p><a name="grammar-execution-note" id="grammar-execution-note"></a></p>
<h1 id="toc2"><span><a href="#grammar-execution">Grammar and Execution</a></span></h1>
<p><a name="compiler-note" id="compiler-note"></a></p>
<h2 id="toc3"><span><a href="#compiler">compiler</a></span></h2>
<p><strong>racket</strong></p>
<p>Compiling a.ss creates the byte-code compiled file a_ss.zo, which will be used by <em>mzscheme</em> in preference to the source code if it encounters</p>
<div class="code">
<pre>
<code>(require a)</code>
</pre></div>
<p><a name="standalone-executable-note" id="standalone-executable-note"></a></p>
<h2 id="toc4"><span><a href="#standalone-executable">standalone executable</a></span></h2>
<p><strong>racket</strong></p>
<p>In order for code to be compiled as a standalone executable, it must be packaged as a module. This can be accomplished by putting the <em>#lang scheme</em> shorthand the top of the file. All functions that are defined in the module will be executed in order. Here is a simple example:</p>
<div class="code">
<pre>
<code>#lang scheme
(define hello
  (printf "Hello world!~n"))</code>
</pre></div>
<p><strong>emacs</strong></p>
<p><a href="http://www.gnu.org/s/emacs/manual/html_node/elisp/Building-Emacs.html">Building Emacs</a></p>
<p><a name="interpreter-note" id="interpreter-note"></a></p>
<h2 id="toc5"><span><a href="#interpreter">interpreter</a></span></h2>
<p>How to interpret the code in a file.</p>
<p><a name="shebang-note" id="shebang-note"></a></p>
<h2 id="toc6"><span><a href="#shebang">shebang</a></span></h2>
<p>How to have a script run by the interpreter automatically. Replace the given path with the path to the interpreter on your system.</p>
<p><strong>emacs lisp</strong></p>
<p>To run some lisp code from within emacs, use <em>M-x load</em> or <em>M-x load-file</em>. The first command will use the list of strings in <em>load-path</em> to search for the file. It is not necessary to specify the <em>.el</em> or <em>.elc</em> suffix if the file has one.</p>
<p>The following snippet is an emacs lisp shebang script implementation of <em>cat</em>:</p>
<div class="code">
<pre>
<code>#!/usr/bin/env emacs --script
(condition-case nil
  (let (line)
    (while (setq line (read-from-minibuffer ""))
        (princ line)
        (princ "\n")))
  (error nil))</code>
</pre></div>
<p>An implementation of <em>echo</em>:</p>
<div class="code">
<pre>
<code>#!/usr/bin/env emacs --script
(condition-case nil
  (progn
    (dotimes (i (length argv) nil)
            (princ (nth i argv))
            (princ " "))
    (princ "\n"))
  (error nil))</code>
</pre></div>
<p><a name="repl-note" id="repl-note"></a></p>
<h2 id="toc7"><span><a href="#repl">repl</a></span></h2>
<p>How to invoke the repl from the command line.</p>
<p><strong>racket:</strong></p>
<p>Racket also provides a GUI repl environment called DrRacket.</p>
<p><strong>clojure:</strong></p>
<p>The clojure repl saves the result of each evaluation in the variables *1, *2, … and the last exception in *e.</p>
<p><a name="cmd-line-prog-note" id="cmd-line-prog-note"></a></p>
<h2 id="toc8"><span><a href="#cmd-ilne-prog">command line program</a></span></h2>
<p>How to pass in a program to be executed on the command line.</p>
<p><a name="word-separator-note" id="word-separator-note"></a></p>
<h2 id="toc9"><span><a href="#word-separator">word separator</a></span></h2>
<p>What is used to separate the operator and data of a S-expression.</p>
<p><a name="identifier-char-note" id="identifier-char-note"></a></p>
<h2 id="toc10"><span><a href="#identifier-char">identifier characters</a></span></h2>
<p>In lisps other than clojure, any character can be used in a symbol. Some characters are special to the reader and must be escaped to include them in a symbol. The reader will interpret a sequence of characters starting with a digit as a number instead of a symbol, so escaping must be used to create such a symbol.</p>
<p><strong>common lisp:</strong></p>
<p>Common Lisp is case insensitive, and the reader converts all letters to upper case. A symbol consisting of just periods "." must be escaped. Symbols that start and end with an asterisk "*" may conflict with system defined special variables.</p>
<p><strong>racket:</strong></p>
<p><span style="white-space: pre-wrap;">#</span> is only disallowed by the reader at the beginning of symbols. A symbol consisting of a single period must be escaped.</p>
<p><a name="eol-comment-note" id="eol-comment-note"></a></p>
<h2 id="toc11"><span><a href="#eol-comment">end-of-line comment</a></span></h2>
<p><a name="multiple-line-comment-note" id="multiple-line-comment-note"></a></p>
<h2 id="toc12"><span><a href="#multiple-line-comment">multiple line comment</a></span></h2>
<p>#| |# delimited comments in Common Lisp and Scheme can span multiple lines, and thus can be used to comment out code.</p>
<p><strong>clojure:</strong></p>
<p>Code with balanced parens can be commented out in the following manner:</p>
<div class="code">
<pre>
<code>(comment
(+ 1 1)
)</code>
</pre></div>
<p><a name="var-expr-note" id="var-expr-note"></a></p>
<h1 id="toc13"><span><a href="#var-expr">Variables and Expressions</a></span></h1>
<p><a name="id-note" id="id-note"></a></p>
<h2 id="toc14"><span><a href="#id">identifier</a></span></h2>
<p>Are identifiers case sensitive; which characters can be used in identifers.</p>
<p>In Lisp, identifiers are called <em>symbols</em>.</p>
<p><a name="quoted-id-note" id="quoted-id-note"></a></p>
<h2 id="toc15"><span><a href="#quoted-id">quoted identifer</a></span></h2>
<p>How to quote or escape characters in identifiers which are otherwise prohibited.</p>
<p><a name="local-var-note" id="local-var-note"></a></p>
<h2 id="toc16"><span><a href="#local-var">local variable</a></span></h2>
<p>How to declare a local variable.</p>
<p><a name="global-var-note" id="global-var-note"></a></p>
<h2 id="toc17"><span><a href="#global-var">global variable</a></span></h2>
<p>How to declare a global variable.</p>
<p><a name="rm-var-note" id="rm-var-note"></a></p>
<h2 id="toc18"><span><a href="#rm-var">remove variable</a></span></h2>
<p>How to remove a variable.</p>
<p><a name="null-note" id="null-note"></a></p>
<h2 id="toc19"><span><a href="#null">null</a></span></h2>
<p>The null value.</p>
<p><strong>common lisp</strong></p>
<p><tt>nil</tt> and the empty list <tt>'()</tt> are identical.</p>
<p><strong>racket</strong></p>
<p><tt>null</tt> and the empty list <tt>'()</tt> are identical.</p>
<p><strong>clojure</strong></p>
<p><tt>nil</tt> and the empty list <tt>'()</tt> are distinct.</p>
<p><strong>emacs lisp</strong></p>
<p><tt>nil</tt> and the empty list <tt>'()</tt> are identical.</p>
<p><a name="null-test-note" id="null-test-note"></a></p>
<h2 id="toc20"><span><a href="#null-test">null test</a></span></h2>
<p>How to test whether a value is null.</p>
<p><a name="id-as-val-note" id="id-as-val-note"></a></p>
<h2 id="toc21"><span><a href="#id-as-val">identifier as value</a></span></h2>
<p>How to get the value of an identifier.</p>
<p>In Lisp, identifiers are first class values and can be stored in variables. When used as an argument, the Lisp interpreter will treat an identifier as the value of the variable associated with the identifier unless special syntax is used.</p>
<p><a name="id-test-note" id="id-test-note"></a></p>
<h2 id="toc22"><span><a href="#id-test">identifier test</a></span></h2>
<p>How to test whether a value is an identifier.</p>
<p><a name="non-referential-id-note" id="non-referential-id-note"></a></p>
<h2 id="toc23"><span><a href="#non-referential-id">non-referential identifier</a></span></h2>
<p>A non-referential identifier is an identifier whose value is itself.</p>
<p>Non-referential identifiers are called <em>keywords</em> in Lisp. They also appear in Prolog, where they are called <em>atoms</em>, and Ruby, where they are called <em>symbols</em>.</p>
<p>A non-referential identifier can be convenient to use as a key in a dictionary, since it doesn't have to single quote escaped.</p>
<p>Strings are an alternative to non-referential identifiers; some languages have string interning which makes the use of strings just as efficient as non-referential identifiers.</p>
<p><a name="id-attr-note" id="id-attr-note"></a></p>
<h2 id="toc24"><span><a href="#id-attr">identifier attributes</a></span></h2>
<p>In Common Lisp, there is a dictionary of attributes associated with each identifier called a <em>property list</em>.</p>
<p>Clojure <em>metadata</em> is stored with a value which is an instance of <tt>clojure.lang.IObj</tt>. Many types are subclasses of <tt>clojure.lang.IObj</tt>, but integers, floats, and strings are not. Clojure metadata is immutable: all keys must be set at once and there is no way to remove keys.</p>
<p><a name="cell-types" id="cell-types"></a></p>
<h2 id="toc25"><span>cell types</span></h2>
<p>The different cell types. A lisp-1 only stores a single entity under a symbol in a given environment. A lisp-2 stores multiple entities, and which entity a symbol will resolve to depends on how the symbol is used. In particular, a value and a function can be stored under the same symbol without collision.</p>
<p><a name="nil" id="nil"></a></p>
<h2 id="toc26"><span>nil, is () null?, is () symbol?</span></h2>
<div class="code">
<pre>
<code>(eq nil ())</code>
</pre></div>
<p>is true in common lisp and emacs lisp.</p>
<div class="code">
<pre>
<code>(eq? () null)</code>
</pre></div>
<p>is true in Scheme.</p>
<p><a name="keyword" id="keyword"></a></p>
<h2 id="toc27"><span>keyword</span></h2>
<p>Keywords are pre-defined symbols that evaluate to their printed representation. The reader recognizes them by the initial colon, or in the case of Scheme, by the initial "#:". In Scheme it is an error to use a keyword as an expression.</p>
<p><a name="atom" id="atom"></a></p>
<h2 id="toc28"><span>atom</span></h2>
<p><em>atom</em> is is a predicate which returns false for cons cells, and true for anything else. All lists except for the empty list are cons cells.</p>
<p><strong>racket</strong></p>
<p>Scheme lacks <em>atom</em>, but <em>cons?</em> is its logical negation.</p>
<p><strong>clojure</strong></p>
<p>Clojure lacks cons cells. Thus <em>atom</em> if implemented in the language would always return true. However, <em>(not (list? x))</em> is closer to the spirit and certainly more useful. Because <em>nil</em> is not the empty list in clojure there is also ambiguity about what the value of <em>(atom ())</em> would be.</p>
<p><a name="quote" id="quote"></a></p>
<h2 id="toc29"><span>quote</span></h2>
<p>All lisps have a single quote macro abbreviation for <em>quote</em>. Here are identical ways to quote a symbol and a list:</p>
<div class="code">
<pre>
<code>(quote a)
'a

(quote (+ 3 7))
'(+ 3 7)</code>
</pre></div>
<p><em>eval</em> is a one-sided inverse of <em>quote</em>. If X is arbitrary lisp code, then the following are identical</p>
<div class="code">
<pre>
<code>X
(eval (quote X))</code>
</pre></div>
<p><a name="eq" id="eq"></a></p>
<h2 id="toc30"><span>eq, equal, =</span></h2>
<p>In his 1960 paper, McCarthy described <em>eq</em> as undefined if either or both arguments are not atomic. Common Lisp and Scheme (eq?) return true if the arguments both evaluate to the same list in memory, otherwise false. <em>equal</em> and <em>equal?</em> (Scheme) return true if the arguments evaluate to lists with the same elements as determined by calling <em>equal</em> or <em>equal?</em> recursively.</p>
<p>In Common Lisp and Scheme, = can only be called on numeric arguments. The predicates for whether a symbol is numeric are <em>numberp</em> and <em>number?</em>, respectively.</p>
<p>Clojure dispenses with <em>eq</em> and <em>equal</em> and defines <em>=</em> to be equivalent to the Common Lisp <em>equal</em>.</p>
<p><a name="car" id="car"></a></p>
<h2 id="toc31"><span>car</span></h2>
<p>Because <em>car</em> and <em>cdr</em> are abbreviations for parts of the word of the IBM 704, there is a trend to replace them with <em>first</em> and <em>rest</em>. However, <em>car</em> and <em>cdr</em> are short, and convenient notation exists for abbreviating nested calls to <em>car</em> and <em>cdr</em>.</p>
<p>In terms of <em>car</em>, <em>cdr</em>, and combinations thereof, here is what the dialects define:</p>
<table class="wiki-content-table">
<tr>
<th>common lisp</th>
<th>r5rs</th>
<th>racket</th>
<th>clojure</th>
<th>emacs lisp</th>
</tr>
<tr>
<td>car,first</td>
<td>car</td>
<td>car,first</td>
<td>first</td>
<td>car,first</td>
</tr>
<tr>
<td>cadr,second</td>
<td>cadr</td>
<td>cadr,second</td>
<td>second,fnext</td>
<td>cadr,second</td>
</tr>
<tr>
<td>caddr,third</td>
<td>caddr</td>
<td>caddr,third</td>
<td></td>
<td>caddr,third</td>
</tr>
<tr>
<td>cadddr,fourth</td>
<td>cadddr</td>
<td>cadddr,fourth</td>
<td></td>
<td>cadddr,fourth</td>
</tr>
<tr>
<td>fifth</td>
<td></td>
<td>fifth</td>
<td></td>
<td>fifth</td>
</tr>
<tr>
<td>sixth</td>
<td></td>
<td>sixth</td>
<td></td>
<td>sixth</td>
</tr>
<tr>
<td>seventh</td>
<td></td>
<td>seventh</td>
<td></td>
<td>seventh</td>
</tr>
<tr>
<td>eighth</td>
<td></td>
<td>eighth</td>
<td></td>
<td>eighth</td>
</tr>
<tr>
<td>ninth</td>
<td></td>
<td>ninth</td>
<td></td>
<td>ninth</td>
</tr>
<tr>
<td>tenth</td>
<td></td>
<td>tenth</td>
<td></td>
<td>tenth</td>
</tr>
<tr>
<td>cdr, rest</td>
<td>cdr</td>
<td>cdr, rest</td>
<td>rest,next</td>
<td>cdr, rest</td>
</tr>
<tr>
<td>cddr</td>
<td>cddr</td>
<td>cddr</td>
<td></td>
<td>cddr</td>
</tr>
<tr>
<td>cdddr</td>
<td>cdddr</td>
<td>cdddr</td>
<td></td>
<td>cdddr</td>
</tr>
<tr>
<td>cddddr</td>
<td>cddddr</td>
<td>cddddr</td>
<td></td>
<td>cddddr</td>
</tr>
<tr>
<td>caar</td>
<td>caar</td>
<td>caar</td>
<td>ffirst</td>
<td>caar</td>
</tr>
<tr>
<td>cdar</td>
<td>cdar</td>
<td>cdar</td>
<td>nfirst</td>
<td>cdar</td>
</tr>
</table>
<p><a name="cdr" id="cdr"></a></p>
<h2 id="toc32"><span>cdr</span></h2>
<p><strong>common lisp</strong></p>
<p><em>cdr</em> and <em>rest</em> return <em>nil</em> when called on an empty list.</p>
<p><strong>racket</strong></p>
<p><em>cdr</em> and <em>rest</em> raise an error when called on an empty list.</p>
<p><strong>clojure</strong></p>
<p><em>rest</em> returns an empty set () when called on an empty or singleton list, whereas <em>next</em> returns <em>nil</em>. In clojure, the empty set evaluates as true in a boolean context and <em>nil</em> evaluates as false.</p>
<p><a name="cons" id="cons"></a></p>
<h2 id="toc33"><span>cons</span></h2>
<p><strong>clojure</strong></p>
<p>Clojure does not implement a list as a linked list of cons cells. The second argument to <em>cons</em> must be a list.</p>
<p><a name="cond" id="cond"></a></p>
<h2 id="toc34"><span>cond</span></h2>
<p><a name="lambda" id="lambda"></a></p>
<h2 id="toc35"><span>lambda</span></h2>
<p><strong>clojure:</strong></p>
<div class="code">
<pre>
<code>(#(+ %1 %2) 1 2)</code>
</pre></div>
<p><a name="label" id="label"></a></p>
<h2 id="toc36"><span>label</span></h2>
<p><a name="apply" id="apply"></a></p>
<h2 id="toc37"><span>apply</span></h2>
<p><a name="arithmetic-logic-note" id="arithmetic-logic-note"></a></p>
<h1 id="toc38"><span><a href="#arithmetic-logic">Arithmetic and Logic</a></span></h1>
<p><strong>integers</strong></p>
<p>Common Lisp and Racket have arbitrary-precision integers and use them by default.</p>
<p>Racket provides the <tt>fixnum</tt> library for access to hardware integers:</p>
<div class="code">
<pre>
<code>(require racket/fixnum)

(fx+ 3 7)</code>
</pre></div>
<p>Operations on Racket fixnums cause an error when they overflow.</p>
<p><strong>rationals and floats</strong></p>
<p>Common Lisp and Racket have arbitrary-precision rationals. Racket uses them in a number of cases when Common Lisp uses hardware floats:</p>
<div class="code">
<pre>
<code>3.14
3e10
(exp 1)</code>
</pre></div>
<p>Racket provides the <tt>flonum</tt> library for access to hardware floats:</p>
<div class="code">
<pre>
<code>(require racket/flonum)

(fl* 3.1 -7.2)</code>
</pre></div>
<p><strong>complex numbers</strong></p>
<p>Both the real and imaginary part of a Common Lisp complex number will have the same type, but the type can be integer, rational, or float.</p>
<p><a name="true-false-note" id="true-false-note"></a></p>
<h2 id="toc39"><span><a href="#true-false">true and false</a></span></h2>
<p>Literals for true and false.</p>
<p><a name="falsehoods-note" id="falsehoods-note"></a></p>
<h2 id="toc40"><span><a href="#falsehoods">falsehoods</a></span></h2>
<p>Values which evaluate to false in a boolean context.</p>
<p><strong>racket</strong></p>
<p><tt>null</tt> and the empty list {{'{} do not evaluate as false in a boolean context.</p>
<p><a name="logical-op-note" id="logical-op-note"></a></p>
<h2 id="toc41"><span><a href="#logical-op">logical operators</a></span></h2>
<p>The logical operators.</p>
<p><a name="relational-op-note" id="relational-op-note"></a></p>
<h2 id="toc42"><span><a href="#relational-op">relational operators</a></span></h2>
<p>Relational operators for performing comparisons.</p>
<p><a name="min-max-note" id="min-max-note"></a></p>
<h2 id="toc43"><span><a href="#min-max">min and max</a></span></h2>
<p>Functions for returning the least and greatest of the arguments.</p>
<p><a name="num-predicates-note" id="num-predicates-note"></a></p>
<h2 id="toc44"><span><a href="#num-predicates">numeric predicates</a></span></h2>
<p>A selection of numeric predicates.</p>
<p><em>realp</em> and <em>real?</em> are true of all numbers which have a zero imaginary component. <em>floatp</em> and <em>inexact?</em> are true if the number is being stored in a floating point representation.</p>
<p><strong>racket:</strong></p>
<p>The following all evaluate as #t:</p>
<div class="code">
<pre>
<code>(rational? 1.1)
(rational? (sqrt 2))
(rational? pi)</code>
</pre></div>
<p><a name="closure-of-integers" id="closure-of-integers"></a></p>
<h2 id="toc45"><span>closure of integers under division</span></h2>
<p>The number system that containing the potential results of integer division. In mathematics, the closure of integers under division is the rationals, and this is true for common lisp, scheme, and clojure as well.</p>
<p>Emacs lisp performs integer division (i.e. computes the quotient), so the closure of the integers under division is the integers.</p>
<p><a name="arith-op-note" id="arith-op-note"></a></p>
<h2 id="toc46"><span><a href="#arith-op">arithmetic operators</a></span></h2>
<p>In Lisp, + and * take zero or more arguments and - and / take one or more arguments. With zero arguments + and * return the additive and multiplicative identities 0 and 1. With one argument + and * return the argument and - and / return the additive and multiplicative inverses: i.e. the negation and the reciprocal. When evaluating 3 or more arguments - and / are computed from left to right: i.e. (- 3 4 5) is computed as (- (- 3 4) 5).</p>
<p><strong>clojure:</strong></p>
<p><em>Math.pow</em> returns a double.</p>
<p><strong>emacs:</strong></p>
<p>Unary division (i.e. computing the reciprocal) generates a wrong number of arguments error.</p>
<p><a name="transcendental-func-note" id="transcendental-func-note"></a></p>
<h2 id="toc47"><span><a href="#transcendental-func">transcendental functions</a></span></h2>
<p><a name="float-truncation-note" id="float-truncation-note"></a></p>
<h2 id="toc48"><span><a href="#float-truncation">float truncation</a></span></h2>
<p>For rounding, floor, and ceiling, the return value is integer if the argument is rational and floating point if the argument is floating point, unless otherwise noted.</p>
<p><strong>racket:</strong></p>
<p><em>inexact-&gt;exact</em> can be used to convert a float returned by <em>round</em>, <em>ceiling</em>, or <em>floor</em> to an integer.</p>
<p><strong>clojure:</strong></p>
<p><em>Math/round</em> always returns an integer and throws and error if called on a rational. <em>Math/floor</em> and <em>Math/ceil</em> can be called on a rational, but always return a float.</p>
<p><strong>emacs:</strong></p>
<p><em>round</em>, <em>ceiling</em>, and <em>floor</em> return integers. <em>fround</em>, <em>fceiling</em>, and <em>ffloor</em> return floats.</p>
<p><a name="quotient-remainder" id="quotient-remainder"></a></p>
<h2 id="toc49"><span>quotient and remainder</span></h2>
<p><a name="sqrt-negative-two" id="sqrt-negative-two"></a></p>
<h2 id="toc50"><span>(sqrt -2)</span></h2>
<p>The value of <em>(sqrt -2)</em>. Common lisp and Scheme support complex numbers. Clojure and Emacs Lisp do not.</p>
<p><a name="integer-rational-complex-decomposition" id="integer-rational-complex-decomposition"></a></p>
<h2 id="toc51"><span>decomposition of integer, rational, complex</span></h2>
<p>For absolute value, the type of the return value is the same of the type of the argument.</p>
<p><strong>racket:</strong></p>
<p>The <em>scheme/math</em> library must be loaded to use <em>sgn</em>.</p>
<p><strong>clojure:</strong></p>
<p><em>Math/signum</em> only operates on a float and returns a float</p>
<p><a name="random-num-note" id="random-num-note"></a></p>
<h2 id="toc52"><span><a href="#random-num">random number</a></span></h2>
<p>How to generate a random integer, and a random float in a uniform and a normal distribution.</p>
<p><a name="bit-op-note" id="bit-op-note"></a></p>
<h2 id="toc53"><span><a href="#bit-op">bit operators</a></span></h2>
<p><strong>racket:</strong></p>
<p>The bitwise operators implemented by Gambit and Racket are specified in the withdrawn standard <a href="http://srfi.schemers.org/srfi-33/">SRFI 33</a>.</p>
<p><strong>emacs:</strong></p>
<p>Also has <em>ash</em>, which gives a different value when both arguments are negative.</p>
<p><a name="strings-note" id="strings-note"></a></p>
<h1 id="toc54"><span><a href="#strings">Strings</a></span></h1>
<p><a name="character-literal" id="character-literal"></a></p>
<h2 id="toc55"><span>character literals</span></h2>
<p>The syntax for character literals. The first literal uses the letter "a" as an example of how to write a literal for all ASCII printing characters.</p>
<p><strong>common lisp:</strong></p>
<p>Characters are of type standard-char. The predicate is <em>characterp</em>.</p>
<p><strong>racket:</strong></p>
<p>The predicate is <em>char?</em>.</p>
<p><strong>clojure:</strong></p>
<p>Characters are of type java.lang.Character.</p>
<p><strong>emacs:</strong></p>
<p>Characters are of type integer and can be manipulated by arithmetic operators. <em>characterp</em> and <em>integerp</em> are synonyms.</p>
<p><a name="string-literal" id="string-literal"></a></p>
<h2 id="toc56"><span>string literal</span></h2>
<p>The syntax for a string literal.</p>
<p><a name="string-escapes" id="string-escapes"></a></p>
<h2 id="toc57"><span>string escapes</span></h2>
<p>A list of escape sequences that can be used in string literals.</p>
<p><strong>emacs lisp:</strong></p>
<p>The \x escape sequence is followed by one to six hex digits. Because a variable number of hex digits can be used, it may be necessary to indicate the end of the sequence with a backslash and a space, e.g. the following string literal is "λ123":</p>
<div class="code">
<pre>
<code>  "\x3bb\ 123"</code>
</pre></div>
<p><a name="string-char" id="string-char"></a></p>
<h2 id="toc58"><span>character access</span></h2>
<p>How to get the character at a given position in a string.</p>
<p><a name="find-substring" id="find-substring"></a></p>
<h2 id="toc59"><span>find substring</span></h2>
<p>Find the location of a substring in a string.</p>
<p><a name="extract-substring" id="extract-substring"></a></p>
<h2 id="toc60"><span>extract substring</span></h2>
<p><a name="string-length" id="string-length"></a></p>
<h2 id="toc61"><span>length</span></h2>
<p><a name="string-constructors" id="string-constructors"></a></p>
<h2 id="toc62"><span>constructors</span></h2>
<p><a name="string-comparison" id="string-comparison"></a></p>
<h2 id="toc63"><span>comparison</span></h2>
<p><strong>common lisp:</strong></p>
<p>Here is the complete list of string comparison functions:</p>
<div class="code">
<pre>
<code>string=
string&lt;
string&gt;
string&lt;=
string&gt;=
string/=</code>
</pre></div>
<p>There are also case insensitive versions of the above functions:</p>
<div class="code">
<pre>
<code>string-equal
string-lessp
string-greaterp
string-not-greaterp
string-not-lessp
string-not-equal</code>
</pre></div>
<p><strong>racket:</strong></p>
<p>Case sensitive string comparison:</p>
<div class="code">
<pre>
<code>string&lt;=?
string&lt;?
string=?
string&gt;=?
string&gt;?</code>
</pre></div>
<p>Case insensitive string comparison:</p>
<div class="code">
<pre>
<code>string-ci&lt;=?
string-ci&lt;?
string-ci=?
string-ci&gt;=?
string-ci&gt;?</code>
</pre></div>
<p><strong>emacs lisp:</strong></p>
<p>Emacs has only these string comparison functions, all of which are case sensitive:</p>
<div class="code">
<pre>
<code>string=
string-equal
string&lt;
string-lessp</code>
</pre></div>
<p><em>string=</em> and <em>string-equal</em> are synonyms, as are <em>string&lt;</em> and <em>string-lessp</em>.</p>
<p><a name="string-case" id="string-case"></a></p>
<h2 id="toc64"><span>case</span></h2>
<p><a name="string-trim" id="string-trim"></a></p>
<h2 id="toc65"><span>trim</span></h2>
<p><strong>emacs:</strong></p>
<p>An implementation of <tt>trim</tt>:</p>
<div class="code">
<pre>
<code>(defun trim (s)
  (let ((s1 (replace-regexp-in-string "[ \t]*$" "" s)))
    (replace-regexp-in-string "^[ \t]*" "" s1)))</code>
</pre></div>
<p><a name="number-string" id="number-string"></a></p>
<h2 id="toc66"><span>convert from string, to string</span></h2>
<p>How to convert strings to numbers, and numbers to strings.</p>
<p><strong>common lisp:</strong></p>
<p><em>read-from-string</em> invokes the reader, so the return value is not guaranteed to be a floating point number.</p>
<p>Here is a <em>parse-float</em> function which will convert all real numeric types to floats and raise a simple error if another condition is encountered.</p>
<div class="code">
<pre>
<code>(defun parse-float (s)
  (let ((readval (handler-case
                  (read-from-string s)
                  (sb-int:simple-reader-error nil)
                  (end-of-file nil))))
    (cond ((realp readval ) (+ readval 0.0))
          (t (error (concatenate 'string "not a float: " s))))))</code>
</pre></div>
<p><a name="string-concat" id="string-concat"></a></p>
<h2 id="toc67"><span>concat</span></h2>
<p><a name="string-split" id="string-split"></a></p>
<h2 id="toc68"><span>split</span></h2>
<p><a name="string-join" id="string-join"></a></p>
<h2 id="toc69"><span>join</span></h2>
<p><a name="format" id="format"></a></p>
<h2 id="toc70"><span>format</span></h2>
<p><a name="regexes-note" id="regexes-note"></a></p>
<h1 id="toc71"><span><a href="#regexes">Regular Expressions</a></span></h1>
<p><a name="regular-expressions" id="regular-expressions"></a></p>
<h2 id="toc72"><span>regular expressions</span></h2>
<p><strong>common lisp</strong></p>
<p><a href="http://weitz.de/cl-ppcre/">http://weitz.de/cl-ppcre/</a></p>
<p><strong>emacs lisp</strong></p>
<p><em>string-match</em> returns the first index of the first matching substring, or nil.</p>
<p>The following code moves the point to next position following the point that matches the argument, and returns the index of the that position.</p>
<div class="code">
<pre>
<code>(re-search-forward "hello")</code>
</pre></div>
<p><a name="regex-substitution" id="regex-substitution"></a></p>
<h2 id="toc73"><span>regex substitution</span></h2>
<p><a name="regex-special-chars" id="regex-special-chars"></a></p>
<h2 id="toc74"><span>regex special characters</span></h2>
<p><a name="dates-time-note" id="dates-time-note"></a></p>
<h1 id="toc75"><span><a href="#dates-time">Dates and Time</a></span></h1>
<p><a name="current-datetime-note" id="current-datetime-note"></a></p>
<h2 id="toc76"><span><a href="#current-datetime">current datetime</a></span></h2>
<p><a name="current-unix-epoch-note" id="current-unix-epoch-note"></a></p>
<h2 id="toc77"><span><a href="#current-unix-epoch">current unix epoch</a></span></h2>
<p><a name="broken-down-datetime-to-unix-epoch-note" id="broken-down-datetime-to-unix-epoch-note"></a></p>
<h2 id="toc78"><span><a href="#broken-down-datetime-to-unix-epoch">unix epoch to broken-down datetime</a></span></h2>
<p><a name="unix-epoch-to-broken-down-datetime-note" id="unix-epoch-to-broken-down-datetime-note"></a></p>
<h2 id="toc79"><span><a href="#unix-epoch-to-broken-down-datetime">broken-down datetime to unix epoch</a></span></h2>
<p><a name="fmt-datetime-note" id="fmt-datetime-note"></a></p>
<h2 id="toc80"><span><a href="#fmt-datetime">format datetime</a></span></h2>
<p><a name="parse-datetime-note" id="parse-datetime-note"></a></p>
<h2 id="toc81"><span><a href="#parse-datetime">parse datetime</a></span></h2>
<p><a name="date-parts-note" id="date-parts-note"></a></p>
<h2 id="toc82"><span><a href="#date-parts">date parts</a></span></h2>
<p><a name="time-parts-note" id="time-parts-note"></a></p>
<h2 id="toc83"><span><a href="#time-parts">time parts</a></span></h2>
<p><a name="build-datetime-note" id="build-datetime-note"></a></p>
<h2 id="toc84"><span><a href="#build-datetime">build broken-down datetime</a></span></h2>
<p><a name="lists-note" id="lists-note"></a></p>
<h1 id="toc85"><span><a href="#lists">Lists</a></span></h1>
<p><a name="list-literal" id="list-literal"></a></p>
<h2 id="toc86"><span>list literal</span></h2>
<p><a name="pair-literal" id="pair-literal"></a></p>
<h2 id="toc87"><span>pair literal</span></h2>
<p><a name="car-nil" id="car-nil"></a></p>
<h2 id="toc88"><span>(car '())</span></h2>
<p><a name="cdr-nil" id="cdr-nil"></a></p>
<h2 id="toc89"><span>(cdr '())</span></h2>
<p><a name="eval-nil" id="eval-nil"></a></p>
<h2 id="toc90"><span>(eval '())</span></h2>
<p>A practical advantage of having <em>(eval '())</em> be equal to '() is that the empty list doesn't have to be quoted.</p>
<p><a name="list-functions" id="list-functions"></a></p>
<h2 id="toc91"><span>list functions</span></h2>
<p><a name="nth" id="nth"></a></p>
<h2 id="toc92"><span>nth</span></h2>
<p><em>nth</em> and <em>list-ref</em> count from zero. <em>nth</em> returns <em>nil</em> if the index is too large. <em>list-ref</em> throws an error.</p>
<p><a name="list-element-index" id="list-element-index"></a></p>
<h2 id="toc93"><span>index of list element</span></h2>
<p>How to get the index of a list element. The first element of a list has an index of zero.</p>
<p><a name="last-butlast" id="last-butlast"></a></p>
<h2 id="toc94"><span>last butlast</span></h2>
<p>In clojure, <em>last</em> and <em>butlast</em> are analogs of <em>first</em> and <em>rest</em> which operate at the end of a list. If X is a list, then the following code pairs are identities:</p>
<div class="code">
<pre>
<code>(last X)
(first (reverse X))

(butlast X)
(reverse (rest (reverse X)))</code>
</pre></div>
<p>The analogy breaks down in Common Lisp because <em>last</em> returns a list with a single element.</p>
<p><a name="set-car-cdr" id="set-car-cdr"></a></p>
<h2 id="toc95"><span>set-car set-cdr</span></h2>
<p><strong>common lisp:</strong></p>
<p>The following code pairs perform the same operation on the list:</p>
<div class="code">
<pre>
<code>(setf (car l) 3)
(rplaca l 3)

(setf (cdr l) '(4 5 6))
(rplacd l '(4 5 6))</code>
</pre></div>
<p>However, they are not identical because <em>rplaca</em> and <em>rplacd</em> return the modified list instead of their 2nd argument.</p>
<p><strong>racket:</strong></p>
<p>Racket provides a separate interpreter <em>plt-r5rs</em> for an R5RS compliant version of Scheme. Also, the language can be set to R5RS within DrRacket.</p>
<p><strong>emacs lisp:</strong></p>
<p>Also has <em>setf</em>.</p>
<p><a name="sort" id="sort"></a></p>
<h2 id="toc96"><span>sort</span></h2>
<p><a name="assoc" id="assoc"></a></p>
<h2 id="toc97"><span>assoc</span></h2>
<p><strong>clojure</strong></p>
<p>In Clojure, <em>assoc</em> returns a new association with the specified values replaced:</p>
<div class="code">
<pre>
<code>(def numbers {1 :one 2 :two 3 :three 4 :four})
(def jumble (assoc numbers 1 :uno 3 :drei 4 :quatre))</code>
</pre></div>
<p><a name="getf" id="getf"></a></p>
<h2 id="toc98"><span>getf</span></h2>
<p><strong>racket:</strong></p>
<p>How to implement <em>getf</em> in Scheme:</p>
<div class="code">
<pre>
<code>(define (getf lst key (default null))
    (cond ((null? lst) default)
          ((null? (cdr lst)) default)
          ((eq? (car lst) key) (cadr lst))
          (else (getf (cddr lst) key default))))</code>
</pre></div>
<p><a name="map" id="map"></a></p>
<h2 id="toc99"><span>map</span></h2>
<p><strong>common lisp</strong></p>
<p>The lambda can accept multiple arguments:</p>
<div class="code">
<pre>
<code>(mapcar '+ '(1 2 3) '(4 5 6))</code>
</pre></div>
<p><strong>racket</strong></p>
<div class="code">
<pre>
<code>(map + '(1 2 3) '(4 5 6))</code>
</pre></div>
<p><strong>clojure</strong></p>
<div class="code">
<pre>
<code>(map + '(1 2 3) '(4 5 6))</code>
</pre></div>
<p><strong>emacs lisp</strong></p>
<p><em>mapcar</em> does not accept multiple argument lambdas</p>
<p><a name="filter" id="filter"></a></p>
<h2 id="toc100"><span>filter</span></h2>
<p><strong>common lisp</strong></p>
<p>Also the negative version:</p>
<div class="code">
<pre>
<code>(remove-if (lambda (x) (&gt; x 2)) '(1 2 3))</code>
</pre></div>
<p><strong>clojure</strong></p>
<p>Also the negative version:</p>
<div class="code">
<pre>
<code>(remove #(&gt; % 2) '(1 2 3))</code>
</pre></div>
<p><strong>emacs lisp</strong></p>
<p>Also has negative version:</p>
<div class="code">
<pre>
<code>(remove-if (λ (x) (&gt; x 2)) '(1 2 3))</code>
</pre></div>
<p><a name="reduce" id="reduce"></a></p>
<h2 id="toc101"><span>reduce (left fold)</span></h2>
<p><a name="right-fold" id="right-fold"></a></p>
<h2 id="toc102"><span>right fold</span></h2>
<p><strong>clojure:</strong></p>
<p>How to define <tt>foldr</tt>:</p>
<div class="code">
<pre>
<code>(defn foldr [f init list] (reduce #(f %2 %1) (reverse list)))</code>
</pre></div>
<p><a name="sublis" id="sublis"></a></p>
<h2 id="toc103"><span>sublis</span></h2>
<p>How to apply the mapping defined by an associative list to a recursive list.</p>
<h2 id="toc104"><span>dolist</span></h2>
<p><a name="take" id="take"></a></p>
<h2 id="toc105"><span>take</span></h2>
<p>Here is how to define <em>take</em> for common lisp or emacs lisp:</p>
<div class="code">
<pre>
<code>(defun take (n l)
  (cond ((&lt; n 0) (error "index negative"))
        ((= n 0) ())
        ((null l) (error "index too large"))
        (t (cons (car l) (take (- n 1) (cdr l))))))</code>
</pre></div>
<p><a name="drop" id="drop"></a></p>
<h2 id="toc106"><span>drop</span></h2>
<p><a name="push-pop" id="push-pop"></a></p>
<h2 id="toc107"><span>push and pop</span></h2>
<p><strong>racket:</strong></p>
<p>Here is an implementation of <em>push</em> and <em>pop</em> in Racket using boxes:</p>
<div class="code">
<pre>
<code>(define (push x a-list)
  (set-box! a-list (cons x (unbox a-list))))

(define (pop a-list)
  (let ((result (first (unbox a-list))))
    (set-box! a-list (rest (unbox a-list)))
    result))</code>
</pre></div>
<p><strong>clojure:</strong></p>
<p>Note the in clojure, <em>pop</em> only returns the first element; the original list is left unmodified.</p>
<p><a name="fixed-length-arrays-note" id="fixed-length-arrays-note"></a></p>
<h1 id="toc108"><span><a href="#fixed-length-arrays">Fixed-Length Arrays</a></span></h1>
<p><a name="vector-literal" id="vector-literal"></a></p>
<h2 id="toc109"><span>vector literal</span></h2>
<p><strong>racket</strong></p>
<p><em>#(1 2 3)</em> creates an immutable vect. <em>(vector 1 2 3)</em> creates a mutable vector.</p>
<p><a name="vector-access" id="vector-access"></a></p>
<h2 id="toc110"><span>vector access</span></h2>
<p><a name="set-vector-element" id="set-vector-element"></a></p>
<h2 id="toc111"><span>set vector element</span></h2>
<p><strong>racket</strong></p>
<p><em>vector-set!</em> throws an error if called on an immutable vector.</p>
<p><a name="vector-to-list" id="vector-to-list"></a></p>
<h2 id="toc112"><span>vector to list</span></h2>
<p><a name="list-to-vector" id="list-to-vector"></a></p>
<h2 id="toc113"><span>list to vector</span></h2>
<p><a name="abstract-sequence" id="abstract-sequence"></a></p>
<h2 id="toc114"><span>abstract sequence</span></h2>
<p>Lists and vectors support the same operations; the only difference is the speed at which the operations can be performed. It is a convenience for the developer if functions that perform the operations have the same name; i.e. if lists and vectors are members of an abstract sequence type. Clojure has gone furthest in this direction, making all the customary list functions work on vectors as well. In common lisp and emacs lisp, some of the list functions also work on vectors, and some don't. In Scheme none of the list functions work on vectors.</p>
<p><a name="sequence-data-types" id="sequence-data-types"></a></p>
<h2 id="toc115"><span>sequence data types</span></h2>
<p>The containers that respond to sequence functions.</p>
<p><a name="sequence-predicate" id="sequence-predicate"></a></p>
<h2 id="toc116"><span>sequence predicate</span></h2>
<p><a name="sequence-functions" id="sequence-functions"></a></p>
<h2 id="toc117"><span>list functions usable on sequences</span></h2>
<p><a name="make-array" id="make-array"></a></p>
<h2 id="toc118"><span>make-array</span></h2>
<p>In Lisp terminology, both arrays and vectors refer to collections which are of fixed size; vectors are arrays with rank 1. Only common lisp supports arrays with rank greater than 1.</p>
<p><a name="array-access" id="array-access"></a></p>
<h2 id="toc119"><span>array access</span></h2>
<p><a name="set-array-element" id="set-array-element"></a></p>
<h2 id="toc120"><span>set array element</span></h2>
<p><a name="array-dimensions" id="array-dimensions"></a></p>
<h2 id="toc121"><span>array dimensions</span></h2>
<p><em>array-rank</em> returns the number of indices required to specify an element in the array. <em>array-dimensions</em> returns the size of the array; the number of cells is the product of the elements of the list.</p>
<p><a name="range" id="range"></a></p>
<h2 id="toc122"><span>range</span></h2>
<p><a name="list-comprehension" id="list-comprehension"></a></p>
<h2 id="toc123"><span>list comprehension</span></h2>
<p><a name="dictionaries-note" id="dictionaries-note"></a></p>
<h1 id="toc124"><span><a href="#dictionaries">Dictionaries</a></span></h1>
<p>Lisp has a tradition of using lists of pairs for dictionaries. The data structures in this section are implemented using hash tables.</p>
<p><strong>racket:</strong></p>
<p>In addition to hash tables there are a set of functions which work with any dictionary type, which in Racket include hash tables, lists of cons cell pairs, and vectors. When a vector is treated as a dictionary, the value is an element and the key is the integer index of the element.</p>
<p><strong>clojure:</strong></p>
<p>There are three dictionary types which can be used with the functions described in this section:</p>
<table class="wiki-content-table">
<tr>
<th>constructor</th>
<th>type</th>
</tr>
<tr>
<td>(hash-map "t" 1 "f" 0)</td>
<td>clojure.lang.PersistentHashMap</td>
</tr>
<tr>
<td>(array-map "t" 1 "f" 0)</td>
<td>clojure.lang.PersistentArrayMap</td>
</tr>
<tr>
<td>(zipmap '("t" "f") '(1 0))</td>
<td>clojure.lang.PersistentArrayMap</td>
</tr>
<tr>
<td>(sorted-map "t" 1 "f" 0)</td>
<td>clojure.lang.PersistentTreeMap</td>
</tr>
<tr>
<td>(sorted-map-by #(&lt; %1 %2) "t" 1 "f" 0)</td>
<td>clojure.lang.PersistentTreeMap</td>
</tr>
</table>
<p><a name="dict-literal-note" id="dict-literal-note"></a></p>
<h1 id="toc125"><span><a href="#dict-literal">literal</a></span></h1>
<p>The syntax for a dictionary literal.</p>
<p><a name="dict-ctor-note" id="dict-ctor-note"></a></p>
<h1 id="toc126"><span><a href="#dict-ctor">constructor</a></span></h1>
<p>The constructor for a dictionary.</p>
<p><strong>racket:</strong></p>
<p>The constructors use <tt>equal?</tt> to test for equality of the two keys.</p>
<p>There are also constructors which use <tt>eq?</tt> or <tt>eqv?</tt> to test keys: <tt>hasheq</tt>, <tt>hasheqv</tt>, <tt>make-immutable-hasheq</tt>, <tt>make-immutable-hasheqv</tt>.</p>
<p><a name="dict-pred-note" id="dict-pred-note"></a></p>
<h1 id="toc127"><span><a href="#dict-pred">predicate</a></span></h1>
<p>How to test whether a value is a dictionary.</p>
<p><a name="dict-size-note" id="dict-size-note"></a></p>
<h1 id="toc128"><span><a href="#dict-size">size</a></span></h1>
<p>How to get the number of keys stored in the dictionary.</p>
<p><a name="dict-lookup-note" id="dict-lookup-note"></a></p>
<h1 id="toc129"><span><a href="#dict-lookup">lookup</a></span></h1>
<p>How to look up the value associated with a key.</p>
<p><a name="dict-update-note" id="dict-update-note"></a></p>
<h1 id="toc130"><span><a href="#dict-update">update</a></span></h1>
<p>How to insert a key-value pair or replace the value stored with an existing key.</p>
<p><a name="dict-missing-key-note" id="dict-missing-key-note"></a></p>
<h1 id="toc131"><span><a href="#dict-missing-key">missing key behavior</a></span></h1>
<p>What happens when a lookup is performed on a key not in the dictionary.</p>
<p><strong>racket:</strong></p>
<p>How to handle the error and return a null when the key is not found:</p>
<div class="code">
<pre>
<code>(with-handlers ((exn:fail? (lambda (e) null))) (get h "goodbye"))</code>
</pre></div>
<p><a name="dict-is-key-present-note" id="dict-is-key-present-note"></a></p>
<h1 id="toc132"><span><a href="#dict-is-key-present">is key present</a></span></h1>
<p>How to check whether a key exists in a dictionary.</p>
<p><a name="dict-del-note" id="dict-del-note"></a></p>
<h1 id="toc133"><span><a href="#dict-del">delete</a></span></h1>
<p>How to remove a key and its associated value from a dictionary.</p>
<p><a name="dict-merge-note" id="dict-merge-note"></a></p>
<h1 id="toc134"><span><a href="#dict-merge">merge</a></span></h1>
<p>How to merge two dictionaries.</p>
<p><a name="dict-invert-note" id="dict-invert-note"></a></p>
<h1 id="toc135"><span><a href="#dict-invert">invert</a></span></h1>
<p>How to turn a dictionary into its inverse. If a key 'foo' is mapped to value 'bar' by a dictionary, then its inverse will map the key 'bar' to the value 'foo'.</p>
<p>If multiple keys are mapped to the same value in the original dictionary, some of the keys will be discarded in the inverse.</p>
<p><a name="dict-iter-note" id="dict-iter-note"></a></p>
<h1 id="toc136"><span><a href="#dict-iter">iterate</a></span></h1>
<p>How to iterate over the key-value pairs in a dictionary.</p>
<p><a name="dict-key-val-lists-note" id="dict-key-val-lists-note"></a></p>
<h1 id="toc137"><span><a href="#dict-key-val-lists">keys and values as lists</a></span></h1>
<p>How to get the keys or the values in a dictionary as lists.</p>
<p><a name="user-defined-types-note" id="user-defined-types-note"></a></p>
<h1 id="toc138"><span><a href="#user-defined-types">User-Defined Types</a></span></h1>
<p><a name="defstruct" id="defstruct"></a></p>
<h2 id="toc139"><span>defstruct</span></h2>
<p><a name="struct" id="struct"></a></p>
<h2 id="toc140"><span>struct</span></h2>
<p><a name="struct-getter" id="struct-getter"></a></p>
<h2 id="toc141"><span>struct getter</span></h2>
<p><a name="struct-setter" id="struct-setter"></a></p>
<h2 id="toc142"><span>struct setter</span></h2>
<p><a name="struct-predicate" id="struct-predicate"></a></p>
<h2 id="toc143"><span>struct predicate</span></h2>
<p><a name="functions-note" id="functions-note"></a></p>
<h1 id="toc144"><span><a href="#functions">Functions</a></span></h1>
<p><a name="let" id="let"></a><a name="let-star" id="let-star"></a></p>
<h2 id="toc145"><span>let, let*</span></h2>
<p>Traditionally <tt>let</tt> performs its assignments in parallel and <tt>let*</tt> serially.</p>
<p><strong>clojure</strong></p>
<p>In Clojure, <em>let</em> and <em>let*</em> are synonyms and both perform serial assignment.</p>
<p><strong>emacs</strong></p>
<p>Note that <tt>let</tt> uses dynamic scope. Use <tt>lexical-let</tt> for lexical scope:</p>
<div class="code">
<pre>
<code>ELISP&gt; (let ((x 3)) (defun get-x () x))
get-x
ELISP&gt; (get-x)
*** Eval error ***  Symbol's value as variable is void: x
ELISP&gt; (let ((x 4)) (get-x))
4
ELISP&gt; (lexical-let ((x 3)) (defun get-x-2 () x))
get-x-2
ELISP&gt; (get-x-2)
3
ELISP&gt; (lexical-let ((x 4)) (get-x-2))
3</code>
</pre></div>
<p><a name="define-function" id="define-function"></a></p>
<h2 id="toc146"><span>define function</span></h2>
<p><a name="optional-argument" id="optional-argument"></a></p>
<h2 id="toc147"><span>optional argument</span></h2>
<p><a name="variable-arguments" id="variable-arguments"></a></p>
<h2 id="toc148"><span>variable number of arguments</span></h2>
<p><a name="default-value" id="default-value"></a></p>
<h2 id="toc149"><span>default value</span></h2>
<p><a name="named-parameter" id="named-parameter"></a></p>
<h2 id="toc150"><span>named parameter</span></h2>
<p><strong>common lisp:</strong></p>
<p>In common lisp, named parameters are optional. Named values can be assigned default values:</p>
<div class="code">
<pre>
<code> (defun logarithm (&amp;key number (base 10)) (/ (log number) (log base)))</code>
</pre></div>
<p>If a named parameter is not provided at invocation and has not been assigned a default value, then it is set to <em>nil</em>.</p>
<p><strong>racket:</strong></p>
<p><a href="http://rosettacode.org/wiki/Named_parameters#Scheme">How to Implement Named Parameters in Scheme</a></p>
<p><strong>emacs lisp:</strong></p>
<p>In emacs lisp named parameters are mandatory. A runtime error results in they are not provided when the function is invoked.</p>
<p><a name="tail-call" id="tail-call"></a></p>
<h2 id="toc151"><span>tail call optimization</span></h2>
<p><strong>common lisp:</strong></p>
<p>The ANSI Common Lisp specification does not require an implementation to perform tail call optimization.</p>
<p><a name="docstring-note" id="docstring-note"></a></p>
<h2 id="toc152"><span><a href="#docstring">get docstring</a></span></h2>
<p>How to get the documentation string for a function.</p>
<p><strong>common lisp:</strong></p>
<p><tt>describe</tt> returns the documentation string with additional information such as the function signature. To get just the documentation string use this:</p>
<div class="code">
<pre>
<code>(documentation #'mapcar 'function)</code>
</pre></div>
<p><a name="define-docstring-note" id="define-docstring-note"></a></p>
<h2 id="toc153"><span><a href="#define-docstring">define function with docstring</a></span></h2>
<p>How to define a function that has a documentation string.</p>
<p><a name="search-doc-note" id="search-doc-note"></a></p>
<h2 id="toc154"><span><a href="#search-doc">apropos and documentation search</a></span></h2>
<p>How to search definitions and documentation.</p>
<p>Apropos takes a pattern and returns all defined symbol names which match the pattern.</p>
<p><strong>clojure:</strong></p>
<p><tt>apropos</tt> returns matching symbol names as a list.</p>
<p><tt>find-doc</tt> searches all documentation strings and writes any which match to standard out.</p>
<p>Both <tt>apropos</tt> and <tt>find-doc</tt> can take a string or a regular expression as an argument.</p>
<p><strong>emacs lisp:</strong></p>
<p><tt>apropos</tt> displays the documentation for matching definitions in the <tt>*Apropos*</tt> buffer. The argument is a string but will be treated as a regular expression.</p>
<p><a name="execution-control-note" id="execution-control-note"></a></p>
<h1 id="toc155"><span><a href="#execution-control">Execution Control</a></span></h1>
<p><a name="progn" id="progn"></a></p>
<h2 id="toc156"><span>progn</span></h2>
<p><em>progn</em> and its equivalents in other dialects returns the value of the last expression. Common Lisp and Emacs Lisp also have <em>prog1</em> and <em>prog2</em> for returning the value of the 1st or 2nd expression.</p>
<p><a name="loop" id="loop"></a></p>
<h2 id="toc157"><span>loop</span></h2>
<p><a name="do" id="do"></a></p>
<h2 id="toc158"><span>do</span></h2>
<p><a name="dotimes" id="dotimes"></a></p>
<h2 id="toc159"><span>dotimes</span></h2>
<p><a name="if" id="if"></a></p>
<h2 id="toc160"><span>if</span></h2>
<p><a name="when" id="when"></a></p>
<h2 id="toc161"><span>when</span></h2>
<p><a name="exceptions-note" id="exceptions-note"></a></p>
<h1 id="toc162"><span><a href="#exceptions">Exceptions</a></span></h1>
<p><a name="error" id="error"></a></p>
<h2 id="toc163"><span>error</span></h2>
<p><a name="handle-error" id="handle-error"></a></p>
<h2 id="toc164"><span>handle error</span></h2>
<p><strong>racket:</strong></p>
<p>Calling <em>error</em> raises an exception of type exn:fail</p>
<p><strong>emacs:</strong></p>
<p>In the example:</p>
<div class="code">
<pre>
<code>(condition-case nil (error "failed") (error (message "caught error") nil))</code>
</pre></div>
<p>the 2nd argument to <em>condition-case</em> is the code which might raise an error, and the 3rd argument is the error handler. The error handler starts with condition to be caught. The last <em>nil</em> is the return value of the entire <em>condition-case</em> expression.</p>
<p>An error cannot be handled by catch. An uncaught throw will generate an error, which can be handled by a condition-case error handler.</p>
<p><a name="define-exception" id="define-exception"></a></p>
<h2 id="toc165"><span>define exception</span></h2>
<p>How to define a custom exception with a payload.</p>
<p><strong>common lisp:</strong></p>
<p>The :report clause is not necessary. If defined it will be displayed if the exception is handled by the lisp debugger.</p>
<p><a name="throw-exception" id="throw-exception"></a></p>
<h2 id="toc166"><span>throw exception</span></h2>
<p><strong>emacs:</strong></p>
<p>The 1st argument of an emacs <em>throw</em> expression identifies the type of exception, and the 2nd argument will be the return value of the <em>catch</em> expression that catches the exception.</p>
<p><a name="catch-exception" id="catch-exception"></a></p>
<h2 id="toc167"><span>catch exception</span></h2>
<p><strong>emacs</strong></p>
<p>The following <em>catch</em> expression will return <em>nil</em>:</p>
<div class="code">
<pre>
<code>(catch 'failed (throw 'failed nil) t)</code>
</pre></div>
<p><a name="restart-case" id="restart-case"></a></p>
<h2 id="toc168"><span>restart case</span></h2>
<p><a name="invoke-restart" id="invoke-restart"></a></p>
<h2 id="toc169"><span>invoke restart</span></h2>
<p><a name="finally-clause" id="finally-clause"></a></p>
<h2 id="toc170"><span>finally clause</span></h2>
<p><strong>racket:</strong></p>
<ul>
<li><a href="http://www.nhplace.com/kent/PFAQ/unwind-protect-vs-continuations-original.html">Unwind-protect vs. Continuations</a> Kent Pitman</li>
<li><a href="http://www.ccs.neu.edu/home/dorai/uwcallcc/uwcallcc.html">Unwind-protect in Portable Scheme</a> Dorai Sitiram</li>
</ul>
<p><strong>clojure:</strong></p>
<p>Here is an optional technique for making sure that a file handle is closed:</p>
<div class="code">
<pre>
<code>(with-open [#^PrintWriter w (writer f)] (.print w content))</code>
</pre></div>
<p><a name="lazy-evaluation" id="lazy-evaluation"></a></p>
<h2 id="toc171"><span>lazy evaluation</span></h2>
<p><a name="continuations" id="continuations"></a></p>
<h2 id="toc172"><span>continuations</span></h2>
<p><a name="streams-note" id="streams-note"></a></p>
<h1 id="toc173"><span><a href="#streams">Streams</a></span></h1>
<p><a name="std-file-handles-note" id="std-file-handles-note"></a></p>
<h2 id="toc174"><span><a href="#std-file-handles">standard file handles</a></span></h2>
<p><a name="eof-note" id="eof-note"></a></p>
<h2 id="toc175"><span><a href="#eof">end-of-file behavior</a></span></h2>
<p><a name="read-stdin-note" id="read-stdin-note"></a></p>
<h2 id="toc176"><span><a href="#read-stdin">read line from stdin</a></span></h2>
<p><a name="chomp-note" id="chomp-note"></a></p>
<h2 id="toc177"><span><a href="#chomp">chomp</a></span></h2>
<p><a name="println-note" id="println-note"></a></p>
<h2 id="toc178"><span><a href="#println">write line to stdout</a></span></h2>
<p><a name="format-stdout-note" id="format-stdout-note"></a></p>
<h2 id="toc179"><span><a href="#format-stdout">write formatted string to stdout</a></span></h2>
<p><strong>racket</strong></p>
<p><em>printf</em> prints to stdout. <em>format</em> returns a string.</p>
<p><strong>emacs lisp</strong></p>
<p>The <em>format</em> statement returns the generated string. When used for i/o, it prints in the emacs minibuffer.</p>
<p><a name="open-file-note" id="open-file-note"></a></p>
<h2 id="toc180"><span><a href="#open-file">open file for reading</a></span></h2>
<p><a name="open-file-write-note" id="open-file-write-note"></a></p>
<h2 id="toc181"><span><a href="#open-file-write">open file for writing</a></span></h2>
<p><a name="open-file-append-note" id="open-file-append-note"></a></p>
<h2 id="toc182"><span><a href="#open-file-append">open file for appending</a></span></h2>
<p><a name="close-file-note" id="close-file-note"></a></p>
<h2 id="toc183"><span><a href="#close-file">close file</a></span></h2>
<p><a name="close-file-implicitly-note" id="close-file-implicitly-note"></a></p>
<h2 id="toc184"><span><a href="#close-file-implicitly">close file implicitly</a></span></h2>
<p><a name="read-line-note" id="read-line-note"></a></p>
<h2 id="toc185"><span><a href="#read-line">read line</a></span></h2>
<p><a name="iterate-file-note" id="iterate-file-note"></a></p>
<h2 id="toc186"><span><a href="#iterate-file">iterate over file by line</a></span></h2>
<p><a name="read-file-array-note" id="read-file-array-note"></a></p>
<h2 id="toc187"><span><a href="#read-file-array">read file into array of strings</a></span></h2>
<p><a name="read-file-str-note" id="read-file-str-note"></a></p>
<h2 id="toc188"><span><a href="#read-file-str">read file into string</a></span></h2>
<p><a name="write-str-note" id="write-str-note"></a></p>
<h2 id="toc189"><span><a href="#write-str">write string</a></span></h2>
<p><a name="write-line-note" id="write-line-note"></a></p>
<h2 id="toc190"><span><a href="#write-line">write line</a></span></h2>
<p><a name="flush-file-note" id="flush-file-note"></a></p>
<h2 id="toc191"><span><a href="#flush-file">flush filehandle</a></span></h2>
<p><a name="emacs-buffers-note" id="emacs-buffers-note"></a></p>
<h1 id="toc192"><span><a href="#emacs-buffers">Emacs Buffers</a></span></h1>
<p><a name="files-note" id="files-note"></a></p>
<h1 id="toc193"><span><a href="#files">Files</a></span></h1>
<p><a name="file-test-note" id="file-test-note"></a></p>
<h2 id="toc194"><span><a href="#file-test">file test, regular file test</a></span></h2>
<p><a name="file-size-note" id="file-size-note"></a></p>
<h2 id="toc195"><span><a href="#file-size">file size</a></span></h2>
<p><a name="file-readable-writable-executable-note" id="file-readable-writable-executable-note"></a></p>
<h2 id="toc196"><span><a href="#file-readable-writable-executable">is file readable, writable, executable</a></span></h2>
<p><a name="chmod-note" id="chmod-note"></a></p>
<h2 id="toc197"><span><a href="#chmod">set file permissions</a></span></h2>
<p><a name="cp-rm-mv-note" id="cp-rm-mv-note"></a></p>
<h2 id="toc198"><span><a href="#cp-rm-mv">copy file, remove file, rename file</a></span></h2>
<p><a name="symlink-note" id="symlink-note"></a></p>
<h2 id="toc199"><span><a href="#symlink">create symlink, symlink test, get target</a></span></h2>
<p><a name="tmp-file-note" id="tmp-file-note"></a></p>
<h2 id="toc200"><span><a href="#tmp-file">temporary file</a></span></h2>
<p><a name="in-memory-file-note" id="in-memory-file-note"></a></p>
<h2 id="toc201"><span><a href="#in-memory-file">in memory file</a></span></h2>
<p><a name="directories-note" id="directories-note"></a></p>
<h1 id="toc202"><span><a href="#directories">Directories</a></span></h1>
<p><a name="build-pathname-note" id="build-pathname-note"></a></p>
<h2 id="toc203"><span><a href="#build-pathname">build pathname</a></span></h2>
<p>How to build a file pathname from components.</p>
<p><a name="dirname-basename-note" id="dirname-basename-note"></a></p>
<h2 id="toc204"><span><a href="#dirname-basename">dirname and basename</a></span></h2>
<p>How to extract the directory portion of a pathname; how to extract the non-directory portion.</p>
<p><a name="abs-pathname-note" id="abs-pathname-note"></a></p>
<h2 id="toc205"><span><a href="#abs-pathname">absolute pathname</a></span></h2>
<p>How to get the get the absolute pathname for a pathname. If the pathname is relative the current working directory will be appended.</p>
<p><a name="iterate-dir-note" id="iterate-dir-note"></a></p>
<h2 id="toc206"><span><a href="#iterate-dir">iterate over a directory by file</a></span></h2>
<p>How to iterate over the files in a directory.</p>
<p><a name="mkdir-note" id="mkdir-note"></a></p>
<h2 id="toc207"><span><a href="#mkdir">make directory</a></span></h2>
<p>How to create a directory, including any parents directories specified in the path.</p>
<p><a name="recursive-cp-note" id="recursive-cp-note"></a></p>
<h2 id="toc208"><span><a href="#recursive-cp">recursive copy</a></span></h2>
<p>How to copy a directory and its contents.</p>
<p><a name="rmdir-note" id="rmdir-note"></a></p>
<h2 id="toc209"><span><a href="#rmdir">remove empty directory</a></span></h2>
<p>How to remove an empty directory.</p>
<p><a name="rm-rf-note" id="rm-rf-note"></a></p>
<h2 id="toc210"><span><a href="#rm-rf">remove directory and its contents</a></span></h2>
<p>How to remove a directory and its contents.</p>
<p><a name="dir-test-note" id="dir-test-note"></a></p>
<h2 id="toc211"><span><a href="#dir-test">directory test</a></span></h2>
<p>How to test whether a directory exists.</p>
<p><a name="processes-environment-note" id="processes-environment-note"></a></p>
<h1 id="toc212"><span><a href="#processes-environment">Processes and Environment</a></span></h1>
<p><a name="external-command" id="external-command"></a></p>
<h2 id="toc213"><span>external command</span></h2>
<p><a name="command-line-arguments" id="command-line-arguments"></a></p>
<h2 id="toc214"><span>command line arguments</span></h2>
<p><strong>emacs</strong></p>
<p>The global variables <em>command-line-args</em> and <em>argv</em> are set when emacs is run in shebang mode: i.e. with the —script option. <em>command-line-args</em> contains the pathname used to invoke emacs, as well as any options processed by emacs at startup, in addition to any additional arguments. <em>argv</em> only contains the additional arguments.</p>
<p><a name="environment-variables" id="environment-variables"></a></p>
<h2 id="toc215"><span>environment variables</span></h2>
<p><a name="libraries-namespaces-note" id="libraries-namespaces-note"></a></p>
<h1 id="toc216"><span><a href="#libraries-namespaces">Libraries and Namespaces</a></span></h1>
<p><a name="load-file" id="load-file"></a></p>
<h2 id="toc217"><span>loading a file</span></h2>
<p>How to load a file and evaluate the top level expressions.</p>
<p><strong>common lisp</strong></p>
<p>Does not display the result of any evaluations.</p>
<p><strong>racket</strong></p>
<p>Displays the result of the last evaluation.</p>
<p><a name="load-library" id="load-library"></a></p>
<h2 id="toc218"><span>loading a library</span></h2>
<p><a name="objects-note" id="objects-note"></a></p>
<h1 id="toc219"><span><a href="#objects">Objects</a></span></h1>
<p><a name="defclass" id="defclass"></a></p>
<h2 id="toc220"><span>define class</span></h2>
<p><a name="make-instance" id="make-instance"></a></p>
<h2 id="toc221"><span>make instance</span></h2>
<p><a name="read-attribute" id="read-attribute"></a></p>
<h2 id="toc222"><span>read attribute</span></h2>
<p><a name="write-attribute" id="write-attribute"></a></p>
<h2 id="toc223"><span>write attribute</span></h2>
<p><a name="defmethod" id="defmethod"></a></p>
<h2 id="toc224"><span>define method</span></h2>
<p><a name="invoke-method" id="invoke-method"></a></p>
<h2 id="toc225"><span>invoke method</span></h2>
<p><a name="define-subclass" id="define-subclass"></a></p>
<h2 id="toc226"><span>define subclass</span></h2>
<p><a name="universal-superclass" id="universal-superclass"></a></p>
<h2 id="toc227"><span>universal superclass</span></h2>
<p><a name="multiple-inheritance" id="multiple-inheritance"></a></p>
<h2 id="toc228"><span>multiple inheritance</span></h2>
<p><a name="lisp-macros-note" id="lisp-macros-note"></a></p>
<h1 id="toc229"><span><a href="#lisp-macros">Lisp Macros</a></span></h1>
<p><a name="backquote-comma" id="backquote-comma"></a></p>
<h2 id="toc230"><span>backquote and comma</span></h2>
<p><a name="defmacro" id="defmacro"></a></p>
<h2 id="toc231"><span>defmacro</span></h2>
<p><a name="defmacro-backquote" id="defmacro-backquote"></a></p>
<h2 id="toc232"><span>defmacro-backquote</span></h2>
<p><a name="macro-predicate" id="macro-predicate"></a></p>
<h2 id="toc233"><span>macro predicate</span></h2>
<p><a name="macroexpand" id="macroexpand"></a></p>
<h2 id="toc234"><span>macroexpand</span></h2>
<p><em>macroexpand</em> recursively expands a sexp until the head is no longer a macro. It does not expand arguments that are macros.</p>
<p><strong>common lisp</strong></p>
<p>Common lisp also has <em>macroexpand-1</em>, which will non-recursively expand a macro once. The head of the expansion may thus be a macro.</p>
<p><strong>clojure</strong></p>
<p>Clojure also has <em>macroexpand-1</em>. See above for an example of use.</p>
<p><strong>emacs lisp</strong></p>
<p>Emacs has <em>macroexpand-all</em>, which will recursively expand a sexp until head and arguments are free of macros.</p>
<p><a name="splice-quote" id="splice-quote"></a></p>
<h2 id="toc235"><span>splice quote</span></h2>
<p><a name="recursive-macro" id="recursive-macro"></a></p>
<h2 id="toc236"><span>recursive macro</span></h2>
<p><a name="hygienic" id="hygienic"></a></p>
<h2 id="toc237"><span>hygienic</span></h2>
<p>Does the language have macros whose expansions are guaranteed not to introduce name collisions.</p>
<p><a name="local-values" id="local-values"></a></p>
<h2 id="toc238"><span>local values</span></h2>
<p><a name="reflection-note" id="reflection-note"></a></p>
<h1 id="toc239"><span><a href="#reflection">Reflection</a></span></h1>
<p><a name="type-of" id="type-of"></a></p>
<h2 id="toc240"><span>type-of</span></h2>
<p>How to get the data type of the entity referred to by a symbol.</p>
<p><a name="java-interop-note" id="java-interop-note"></a></p>
<h1 id="toc241"><span><a href="#java-interop">Java Interoperation</a></span></h1>
<p><a name="version-used-jvm" id="version-used-jvm"></a></p>
<h2 id="toc242"><span>version used on jvm</span></h2>
<p><a name="java-extra-libraries" id="java-extra-libraries"></a></p>
<h2 id="toc243"><span>extra libraries used</span></h2>
<p><strong>racket:</strong></p>
<p>The srfi-1 library brings in a common list functions which Kawa does not make available by default. See <a href="http://srfi.schemers.org/srfi-1/srfi-1.html">SRFI</a>.</p>
<p><a name="java-new" id="java-new"></a></p>
<h2 id="toc244"><span>new</span></h2>
<p><a name="java-method" id="java-method"></a></p>
<h2 id="toc245"><span>method</span></h2>
<p><a name="java-class-method" id="java-class-method"></a></p>
<h2 id="toc246"><span>class method</span></h2>
<p><a name="java-chain" id="java-chain"></a></p>
<h2 id="toc247"><span>chain</span></h2>
<p><a name="java-import" id="java-import"></a></p>
<h2 id="toc248"><span>import</span></h2>
<p><a name="java-to-array" id="java-to-array"></a></p>
<h2 id="toc249"><span>to java array</span></h2>
<p><a name="common-lisp" id="common-lisp"></a></p>
<h1 id="toc250"><span><a href="#top">Common Lisp</a></span></h1>
<p><a href="http://www.lispworks.com/documentation/HyperSpec/Front/">ANSI Specification</a><br />
<a href="http://www.sbcl.org/manual/">SBCL User Manual</a><br />
<a href="http://www.quicklisp.org/beta/">Quicklisp</a></p>
<p>For a package manager we use Quicklisp. Here is how to install it and use it to load the <tt>cl-ppcre</tt> library:</p>
<div class="code">
<pre>
<code>$ curl -O http://beta.quicklisp.org/quicklisp.lisp
$ sbcl
* (load "quicklisp.lisp")
* (quicklisp-quickstart:install)
* (ql:quickload "cl-ppcre")
* (cl-ppcre:all-matches "foo" "foo bar")</code>
</pre></div>
<p>Quicklisp creates a <tt>quicklisp</tt> directory in the user's home directory. Once quicklisp is downloaded and installed, it can be used like this:</p>
<div class="code">
<pre>
<code>$ sbcl
* (load "~/quicklisp/setup.lisp")
* (ql:quickload "cl-ppcre")
* (cl-ppcre:all-matches "foo" "foo bar")</code>
</pre></div>
<p>One can ensure that Quicklisp is automatically loaded at startup by putting the load command into the <tt>.sbclrc</tt> file:</p>
<div class="code">
<pre>
<code>$ cat ~/.sbclrc
(load "~/quicklisp/setup.lisp")</code>
</pre></div>
<p><a name="racket" id="racket"></a></p>
<h1 id="toc251"><span><a href="#top">Racket</a></span></h1>
<p><a href="http://docs.racket-lang.org/guide/index.html">Guide: Racket</a><br />
<a href="http://docs.racket-lang.org/reference/index.html">Reference: Racket</a><br />
<a href="http://planet.racket-lang.org/">PLaneT: Racket Packages</a></p>
<p>Racket ships with a large number of libraries in the <tt>collects</tt> directory of the installation which can be loaded with the <tt>require</tt> command, which takes a raw symbol which is the relative pathname from the <tt>collects</tt> directory to the file, not including the <tt>.rkt</tt> suffix. The Racket 5.1 distribution includes 50 SRFI libraries.</p>
<p>Racket also has a built in package management system. Browse the <a href="http://planet.racket-lang.org/">list of available packages</a>. To install a package, click through to the detail page for the package and get the <tt>require</tt> string to load it. If the <tt>require</tt> string is executed by Racket, the library will be downloaded somewhere in the user's home directory. When I ran this on my Mac</p>
<div class="code">
<pre>
<code>$ racket
&gt; (require (planet "spgsql.rkt" ("schematics" "spgsql.plt" 2 3)))</code>
</pre></div>
<p>the files for the PostgreSQL database bindings were installed in <tt>~/Library/Racket</tt>.</p>
<p><a name="clojure" id="clojure"></a></p>
<h1 id="toc252"><span><a href="#top">Clojure</a></span></h1>
<p><a href="http://clojure.org/Reference">Clojure Reference</a><br />
<a href="http://clojure.org/cheatsheet">Clojure Cheat Sheet</a></p>
<h2 id="toc253"><span>Calling Java</span></h2>
<p>Here are the basics of calling Java code:</p>
<div class="code">
<pre>
<code>(def rnd (new java.util.Random))  ; create Java object
(. rnd nextFloat)  ; invoke method on object
(. rnd nextInt 10)  ; invoke method with argument
(. Math PI)  ; static member
(import '(java.util Random))  ; import</code>
</pre></div>
<p>Clojure automatically imports everything in java.lang.</p>
<p>There are shortcuts for the above syntax:</p>
<div class="code">
<pre>
<code>(Random.)
(new Random)

Math/PI
(. Math PI)

(.nextInt rnd)
(. rnd nextInt)</code>
</pre></div>
<p>Because they are primitive types and not objects, Clojure provides functions specific to Java arrays:</p>
<div class="code">
<pre>
<code>(make-array CLASS LEN)
(make-array CLASS DIM &amp; DIMS)
(aset ARY IDX VAL)
(aset ARY IDX_DIM1 IDX_DIM2 ... VAL)
(aget ARY IDX)
(aget ARY IDX_DIM1 IDX_DIM2 ...)
(alength JARY)
(to-array SEQ)
(into-array TYPE SEQ)
(amap ARY I COPY EXPR)
(areduce ARY IDX  COPY INIT EXPR )</code>
</pre></div>
<p><a name="emacs-lisp" id="emacs-lisp"></a></p>
<h1 id="toc254"><span><a href="#top">Emacs Lisp</a></span></h1>
<p><a href="http://www.gnu.org/software/emacs/manual/html_mono/emacs.html">GNU Emacs Manual</a><br />
<a href="http://www.gnu.org/software/emacs/manual/html_mono/elisp.html">GNU Emacs Lisp Reference Manual</a></p>
<p>To get an introduction to Emacs Lisp Programming from within Emacs use</p>
<div class="code">
<pre>
<code>  C-h i m Emacs Lisp Intro</code>
</pre></div>
<p>Run <tt>M-x lisp-interaction-mode</tt> to put Emacs in lisp interaction mode. In lisp interaction mode the command <tt>C-x e</tt> will evaluate the s-expression on the current line. <tt>M-x eval-buffer</tt> will evaluate the entire buffer.</p>
<p>Use lisp interaction mode to define functions which can be called from Emacs. The following defines a function called <tt>dired-emacs-lisp</tt> for browsing the Emacs Lisp directory:</p>
<div class="code">
<pre>
<code>(defun dired-emacs-lisp ()
  "Open the Emacs Lisp directory in dired."
  (interactive)
   (dired "/Applications/Emacs.app/Contents/Resources/lisp"))</code>
</pre></div>
<p>The directory is hard-coded into the function and may be different on your system. Once defined the function can be invoked with <tt>M-x dired-emacs-lisp</tt>. Not all Lisp functions can be called in this manner. Those that can are called <em>commands</em>. The body of a command has an optional documentation string, followed by a call to <tt>interactive</tt>, followed by the code which executes when the command is invoked. The documentation string can be accessed from Emacs by running <tt>M-x describe-function</tt> and entering the name of the function when prompted.</p>
<p>The call to <tt>interactive</tt> is what makes a Lisp function a command. It can takes optional arguments. Use <tt>M-x describe-function</tt> on <tt>interactive</tt> to see a description of these arguments.</p>
<p>To bind the command to the key <tt>C-c l</tt> run the following in Lisp interaction mode:</p>
<div class="code">
<pre>
<code>(global-set-key "\C-cl" 'dired-emacs-lisp)</code>
</pre></div>
<p>If it is desired to have the above command and key binding always available when Emacs starts up, put them in <tt>~/.emacs.d/init.el</tt>.</p>

                    </div>
        </div>
      </div>
      <div id="license-area" class="license-area">
        <a href="https://github.com/clarkgrubb/hyperpolyglot/issues">issue tracker</a> |
        content of this page licensed under
        <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">
        creative commons attribution-sharealike 3.0</a>
        <br>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17129977-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
